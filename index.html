<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task & Mission Planner</title>
    <!-- Tailwind is used for layout, not theming. It will be removed eventually. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
/* ================================================================================= */
/* C-1.0: ROOT & THEME VARIABLES                                                     */
/* ================================================================================= */

:root {
    /* Base text colors for night mode (default) */
    --text-color-dark-primary: #FFFFFF;
    --text-color-dark-secondary: #D1D5DB; /* gray-300 */
    --text-color-dark-tertiary: #9CA3AF;  /* gray-400 */
    --text-color-dark-quaternary: #6B7280; /* gray-500 */

    /* Base text colors for light mode */
    --text-color-light-primary: #1F2937;   /* gray-800 */
    --text-color-light-secondary: #374151;/* gray-700 */
    --text-color-light-tertiary: #4B5563; /* gray-600 */
    --text-color-light-quaternary: #6B7280;/* gray-500 */

    /* Dynamic variables that will be set by JS */
    --text-color-primary: var(--text-color-dark-primary);
    --text-color-secondary: var(--text-color-dark-secondary);
    --text-color-tertiary: var(--text-color-dark-tertiary);
    --text-color-quaternary: var(--text-color-dark-quaternary);
    --text-shadow: none;
    --border-color-primary: #4A5568; /* Default border for night mode */
    --border-color-secondary: #374151;
    --focus-ring-color: #63B3ED; /* blue-400 */
}

/* ================================================================================= */
/* C-2.0: LAYOUT & CORE ELEMENTS                                                     */
/* ================================================================================= */

.bg-main {
    font-family: 'Inter', sans-serif;
    transition: background-color 0.3s ease, color 0.3s ease;
}

.bg-secondary {
    padding: 1rem;
    border-radius: 0.5rem;
    /* The border is removed to create a softer, more layered look. */
    /* It will be replaced by shadows on specific components where needed. */
}

.bg-modal {
    margin: auto;
    padding: 2rem;
    border: 1px solid var(--border-color-primary);
    width: 90%;
    max-width: 550px;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-height: 90vh;
    overflow-y: auto;
}

/* ================================================================================= */
/* C-3.0: BUTTONS                                                                    */
/* ================================================================================= */

.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    border: 1px solid transparent;
    transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
    cursor: pointer;
}
.btn:focus-visible {
    outline: 2px solid var(--focus-ring-color);
    outline-offset: 2px;
}
.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* SIZES */
.btn-lg {
    padding: 0.5rem 1rem; /* py-2 px-4 */
    border-radius: 0.5rem; /* rounded-lg */
    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
}

.btn-md {
    padding: 0.5rem 1rem; /* py-2 px-4 */
    border-radius: 0.375rem; /* rounded-md */
}

.btn-sm {
    padding: 0.5rem; /* p-2 */
    border-radius: 0.375rem; /* rounded-md */
}

.btn-xs {
    padding: 0.25rem 0.75rem; /* py-1 px-3 */
    font-size: 0.875rem; /* text-sm */
    border-radius: 0.375rem; /* rounded-md */
}

/* TYPES */
.btn-primary, .btn-secondary, .btn-tertiary, .btn-confirm, .btn-deny {
    /* Colors to be applied by JS */
}

.btn-clear {
    padding: 0.25rem 0.5rem;
    background-color: transparent;
    border-color: transparent;
    box-shadow: none;
    font-weight: 500;
    /* JS will set text color and hover background color */
}

/* ================================================================================= */
/* C-4.0: GENERAL & UTILITY                                                          */
/* ================================================================================= */

body {
    color: var(--text-color-primary);
}

body.modal-open {
    overflow: hidden;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.5);
    justify-content: center;
    align-items: center;
}

#icon-picker-modal {
    z-index: 1050;
}

.modal-content {
    color: var(--text-color-primary);
}

.close-button {
    color: var(--text-color-tertiary);
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}
.close-button:hover, .close-button:focus {
    color: var(--text-color-primary);
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal.active {
    display: flex;
    animation: fadeIn 0.3s ease-out;
}

.hidden {
    display: none !important;
}

/* Custom Scrollbar */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: #1F2937; } /* Will be themed by JS */
::-webkit-scrollbar-thumb { background: #4B5563; border-radius: 4px; } /* Will be themed by JS */
::-webkit-scrollbar-thumb:hover { background: #6B7280; } /* Will be themed by JS */


/* ================================================================================= */
/* C-5.0: TASK & MANAGER STYLES                                                      */
/* ================================================================================= */

#task-manager-view .controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

#task-manager-view .controls .button-group {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.5rem;
}

#task-manager-view .controls .sort-group {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 1rem;
}

.task-item {
    transition: border-left-color 0.3s ease, background-color 0.3s ease, opacity 0.2s ease, border 0.2s ease;
    padding: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
}
.task-card-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    flex-wrap: wrap;
    gap: 0.25rem 0.5rem; /* row-gap column-gap */
}
.task-completed {
    opacity: 0.6;
}
.task-completed h3 {
    text-decoration: line-through;
}
.task-confirming-delete {
    border-style: dashed !important;
    border-width: 2px !important;
}
.countdown-timer {
    font-size: 0.75rem;
    font-style: italic;
    line-height: 1.2; /* Ensure line height is tight */
    padding-bottom: 0.25rem; /* Add a little space at the bottom */
    min-height: 1rem; /* Keep a min-height to prevent jank when empty */
    color: var(--text-color-secondary);
}
.progress-display {
    font-size: 0.85rem;
    font-weight: 500;
    display: inline-block;
    margin-right: 0.25rem;
}
.misses-display {
    font-size: 0.75rem;
    font-weight: 500;
}
.action-area-text {
    font-size: 0.75rem;
    font-weight: 600;
    margin-right: 0.5rem;
    flex-shrink: 1;
}

/* ================================================================================= */
/* C-6.0: FORM ELEMENTS                                                              */
/* ================================================================================= */

.form-group {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem; /* Adds a little space when wrapping */
    padding: 0.5rem 0;
}
.form-label {
    display: block;
    font-size: 0.875rem;
    font-weight: 500;
    /* margin-bottom is removed to work better with flex align-items */
    color: var(--text-color-secondary);
}
.form-hint {
    font-size: 0.75rem;
    margin-top: 0.25rem;
    font-style: italic;
    color: var(--text-color-quaternary);
}
input[type="text"], input[type="number"], input[type="datetime-local"], input[type="date"], textarea, select {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border-width: 1px;
    border-radius: 0.375rem;
    box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
    transition: border-color 0.2s, box-shadow 0.2s;
    /* Colors to be applied by JS */
}
input:focus, textarea:focus, select:focus {
    border-color: var(--focus-ring-color);
    box-shadow: 0 0 0 1px var(--focus-ring-color);
    outline: none;
}
.duration-input {
    width: 6rem;
}
.miss-input {
    font-size: 0.75rem;
    border-width: 1px;
    border-radius: 0.25rem;
    padding: 0.25rem;
    width: 2.5rem;
    text-align: center;
    margin: 0 0.25rem;
    /* BG color will be transparent, text/border set by JS */
}
fieldset {
    border-width: 1px;
    padding: 0.75rem;
    border-radius: 0.375rem;
    margin-bottom: 1rem;
}
/* Remove border from fieldsets within the task modal's advanced view for a cleaner look */
#advanced-task-fields > fieldset {
    border: none;
    padding-left: 0;
    padding-right: 0;
}
legend {
    font-size: 0.875rem;
    font-weight: 500;
    padding: 0 0.25rem;
    color: var(--text-color-tertiary);
}
.form-legend {
    width: 100%;
    padding-bottom: 0.5rem;
    border-bottom-width: 1px;
    margin-bottom: 1rem;
    font-size: 1.25rem;
    font-weight: 600;
}
.toggle-checkbox {
    position: relative;
    width: 3rem; height: 1.5rem; padding: 0.125rem;
    border-radius: 9999px;
    appearance: none;
    cursor: pointer;
    transition: background-color 0.2s ease-in-out;
}
.toggle-checkbox::before {
    content: '';
    position: absolute;
    left: 2px; top: 2px;
    width: 1.25rem; height: 1.25rem;
    background-color: var(--toggle-peg-color, white); /* Default to white */
    border-radius: 9999px;
    transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out;
    transform: scale(0.8);
}
.toggle-checkbox:checked::before {
    transform: translateX(1.5rem) scale(0.8);
}

/* ================================================================================= */
/* C-7.0: COMPONENT-SPECIFIC STYLES                                                  */
/* ================================================================================= */

/* This is now handled dynamically by the applyTheme function in script.js  */
/* to allow for better theming and layering. The old static styles are      */
/* removed to prevent conflicts.                                            */

/* ======================================================================== */
/* JOURNAL                                                                  */
/* ======================================================================== */
.journal-entry {
    padding: 1rem;
    border-radius: 0.5rem;
}

.journal-week-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 0.5rem;
    cursor: pointer;
    border-bottom: 2px solid var(--border-color-secondary);
    border-radius: 0;
    transition: background-color 0.2s;
}

.journal-icon-header {
    /* This class now primarily acts as a selector. */
    /* All structural and transition styles are inherited from .collapsible-header */
    /* which is defined in the applyTheme() function in script.js */
}

.journal-entry .prose {
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* ======================================================================== */
/* FULLCALENDAR                                                             */
/* ======================================================================== */
#mainPlannerSection {
    background: var(--bg-calendar-border, transparent); /* This will be the gradient */
    padding: 14px;
    border-radius: 0.75rem; /* A slightly larger radius for the outer border */
}

#calendar-inner-wrapper {
    background: var(--bg-secondary); /* This will be the solid color */
    border-radius: 0.25rem; /* A smaller, inner radius */
    overflow: hidden; /* To ensure the inner content respects the border radius */
}

#calendar {
    min-height: 70vh;
    background-color: var(--bg-secondary);
}

.fc .fc-button {
    text-transform: capitalize;
    transition: background-color 0.2s;
    border: none;
}
.fc-event {
    cursor: pointer;
    padding: 2px 4px;
    font-weight: 500;
    font-size: 0.75rem;
    border-width: 2px !important; /* Make border always visible */
    border-style: solid;
    line-height: 1.3;
}
/* --- Calendar Event Readability Improvements --- */
.fc-event-main-inner {
    display: flex;
    flex-direction: column; /* Default vertical layout for normal events */
    height: 100%;
    overflow: hidden;
    padding: 2px;
}

.fc-event-time-title-group {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    flex-grow: 1;
}

.fc-event-icon {
    text-shadow: 0 0 3px rgba(0,0,0,0.5);
    margin-bottom: 2px;
}

.fc-event-time {
    font-weight: 600;
}

.fc-event-title {
    white-space: normal; /* Allow title to wrap */
    word-wrap: break-word;
}

.fc .fc-timegrid-now-indicator-line {
    border-width: 2px;
}
.fc .fc-timegrid-now-indicator-arrow {
    border-top-color: var(--fc-now-indicator-color, #ff4500);
}

/* ======================================================================== */
/* HINTS BANNER                                                             */
/* ======================================================================== */
.hints-banner {
    padding: 0.5rem 0;
    overflow: hidden;
    white-space: nowrap;
    box-sizing: border-box;
    border-radius: 0.375rem;
    margin-bottom: 1rem;
    font-size: 0.875rem;
}
.hints-content {
    display: inline-block;
    padding-left: 100%;
    animation: scroll-left 30s linear infinite;
}
@keyframes scroll-left {
    0% { transform: translateX(0); }
    100% { transform: translateX(-100%); }
}

/* ================================================================================= */
/* C-8.0: RESPONSIVE & MEDIA QUERIES                                                 */
/* ================================================================================= */

/* These classes will be removed in the next steps as the HTML is updated.  */
/* For now, they are left here to avoid breaking the UI completely.         */
/* ======================================================================== */
.themed-button-primary, .themed-button-secondary, .themed-button-tertiary, .themed-button-clear {
    /* To be replaced by .btn and variants */
}
.control-button-yellow, .control-button-red, .control-button-green, .control-button-gray, .control-button-blue {
    /* To be replaced by .btn-confirm, .btn-deny, etc. */
}
.light-mode {
    /* All color logic will be handled by JS, this class will only be a marker */
}
.bg-gray-800, .bg-gray-900, .border-gray-700 {
    /* To be replaced by .bg-main, .bg-secondary, etc. */
}
.nav-btn, .view-btn {
    /* To be replaced by .btn and variants */
}
.active-view-btn, .fc-button-active {
    /* "Lit up" effect for active buttons */
    box-shadow: 0 0 8px 2px var(--focus-ring-color), inset 0 0 5px rgba(255,255,255,0.2);
    transform: translateY(-1px);
}

/* ================================================================================= */
/* C-9.0: DEPRECATED / TO BE REMOVED                                                 */
/* ================================================================================= */

.calendar-header {
    display: flex;
    flex-direction: column;
    gap: 0.75rem; /* space-y-3 */
}

.calendar-title-row {
    width: 100%;
    text-align: center;
}

.calendar-nav-row, .calendar-view-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem; /* gap-2 */
}

.calendar-nav-row {
    justify-content: center; /* Center the nav buttons by default */
}

.calendar-nav-row > :first-child {
    margin-right: auto; /* Pushes prev button to the left */
}
.calendar-nav-row > :last-child {
    margin-left: auto; /* Pushes next button to the right */
}

/* ======================================================================== */
/* MAIN VIEW NAVIGATION                                                     */
/* ======================================================================== */
#main-view-nav {
    display: grid;
    /* Create responsive columns: they will be at least 160px wide, */
    /* and the grid will fit as many as possible, distributing extra space. */
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 0.5rem; /* 8px */
}

/* On smaller screens, stack the view controls for better layout */
@media (max-width: 480px) {
    .calendar-view-row {
        flex-direction: column;
        align-items: stretch;
    }
    .calendar-view-row > div {
        display: flex;
        justify-content: center;
    }
    .calendar-view-row > button {
        width: 100%;
    }
}

/* On smaller screens, stack form group items in advanced options to prevent overflow */
@media (max-width: 480px) {
    #advanced-options-content .form-group {
        flex-direction: column;
        align-items: flex-start;
    }
}

/* ======================================================================== */
/* RESPONSIVE GRIDS & FLEX CONTAINERS                                       */
/* ======================================================================== */

.confirm-miss-area {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-end;
    gap: 0.5rem;
    width: 100%;
}

.confirm-miss-area .action-area-text {
    flex-grow: 1;
    text-align: right;
}

.confirm-miss-area .miss-input {
    width: 60px; /* Give it a fixed width */
    flex-shrink: 0;
}

.confirm-miss-area .button-group {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
}

@media (max-width: 480px) {
    .confirm-miss-area {
        flex-direction: column;
        align-items: center; /* Center items horizontally */
    }
    .confirm-miss-area .action-area-text {
        text-align: center;
        margin-bottom: 0.5rem;
    }
    .confirm-miss-area .miss-input {
        width: 80%; /* Don't take full width, allow for some padding */
        max-width: 150px; /* Prevent it from getting too large on slightly wider small screens */
    }
    .confirm-miss-area .button-group {
        width: 100%;
        justify-content: center;
    }
    .confirm-miss-area .button-group > button {
        flex-grow: 1;
        max-width: 100px; /* Give the buttons a max width to keep them reasonable */
    }
}

.responsive-button-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 0.75rem; /* 12px */
}

/* For the KPI nav buttons: < Prev | Today | Next > */
.kpi-nav-container {
    display: flex;
    justify-content: space-between; /* This is key for the alignment */
    align-items: center;
    gap: 0.5rem;
    width: 100%;
    max-width: 500px; /* Prevents buttons from separating too far on wide screens */
    margin-left: auto;
    margin-right: auto;
}
.kpi-nav-container > .btn {
    flex-grow: 1; /* Allows buttons to expand and fill space */
    max-width: 150px; /* But not grow too large */
}

/* For the KPI controls: Range | View */
.kpi-controls-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap; /* Allows wrapping on small screens */
    gap: 1.5rem; /* Space between controls */
}

/* Wrapper for stacked KPI charts to create a single border */
.kpi-chart-stack-wrapper {
    background: var(--bg-calendar-border, transparent); /* The gradient */
    padding: 14px;
    border-radius: 0.75rem;
    margin-top: 1rem;
}
.kpi-chart-stack-wrapper .gradient-bordered-content {
    margin-top: 0; /* Override default margin for items inside the stack */
    margin-bottom: 14px; /* Add space between charts in the stack */
}
.kpi-chart-stack-wrapper .gradient-bordered-content:last-child {
    margin-bottom: 0; /* No margin on the last chart */
}

/* ======================================================================== */
/* NEW MONTH VIEW STYLES                                                    */
/* ======================================================================== */
.month-view-event-list {
    display: flex;
    flex-direction: column;
    gap: 2px;
    height: 100%;
    overflow: hidden;
}

.month-view-event-item {
    display: flex;
    align-items: center;
    padding: 1px 4px;
    border-radius: 2px;
    background-color: var(--bg-secondary);
    border-width: 2px; /* Set a consistent border width */
    border-style: solid; /* Set a consistent border style */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.75rem; /* 12px */
    line-height: 1.2;
}

.month-view-icon {
    margin-right: 4px;
    flex-shrink: 0;
}

.month-view-time {
    margin-right: 4px;
    font-weight: 500;
    opacity: 0.8;
}

.month-view-name {
    flex-grow: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.month-view-group-count {
    margin-left: 4px;
    font-weight: bold;
    background-color: var(--bg-main);
    padding: 0 4px;
    border-radius: 4px;
    font-size: 0.65rem;
}
#weeklyGoals {
  white-space: pre-wrap;
}

</style>
    <!-- This style block will be dynamically populated by script.js -->
    <style id="dynamic-theme-styles"></style>
</head>
<body class="bg-main p-4 md:p-6">

    <!-- Main Application -->
    <div id="app" class="max-w-7xl mx-auto">
        <header class="mb-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold"></h1>
            <p class="mt-1"></p>
        </header>

        <!-- Hints and Tips Banner -->
        <div id="hints-banner" class="hints-banner">
            <div class="hints-content">
                <span></span>
            </div>
        </div>

        <!-- Main View Navigation -->
        <div id="main-view-nav" class="mt-6 mb-6 flex flex-wrap justify-center gap-2">
                <button id="show-dashboard-btn" type="button" class="btn btn-primary btn-lg active-view-btn view-toggle-btn">
                    <i class="fa-solid fa-chart-line mr-2"></i>Dashboard
                </button>
                <button id="show-calendar-btn" type="button" class="btn btn-primary btn-lg view-toggle-btn">
                    <i class="fa-solid fa-calendar-days mr-2"></i>Calendar
                </button>
                <button id="show-task-manager-btn" type="button" class="btn btn-primary btn-lg view-toggle-btn">
                    <i class="fa-solid fa-tasks mr-2"></i>Task Manager
                </button>
                <button id="show-journal-btn" type="button" class="btn btn-primary btn-lg view-toggle-btn">
                    <i class="fa-solid fa-book-journal-whills mr-2"></i>Journal
                </button>
                <button id="advancedOptionsBtnMain" class="btn btn-secondary btn-lg">Advanced Options</button>
        </div>

        <!-- Main Content Area -->
        <div id="main-content">
            <!-- Journal View -->
            <div id="journal-view" class="hidden">
                <div class="space-y-4">
                    <div class="flex justify-between items-center flex-wrap gap-2">
                        <h2 class="text-2xl font-bold">Journal</h2>
                        <button id="add-journal-entry-btn" data-action="addJournal" class="btn btn-tertiary btn-md">New Entry</button>
                    </div>
                    <div class="journal-controls flex justify-between items-center flex-wrap gap-2">
                        <div class="flex-grow">
                            <input type="search" id="journal-search-input" placeholder="Search journal entries..." class="w-full max-w-sm">
                        </div>
                        <div class="flex items-center gap-2">
                            <select id="journal-sort-by">
                                <option value="date">Sort by Date</option>
                                <option value="icon">Sort by Icon</option>
                            </select>
                            <select id="journal-sort-direction">
                                <option value="desc">Descending</option>
                                <option value="asc">Ascending</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="journal-list" class="space-y-4 mt-4"></div>
            </div>

            <!-- Calendar View -->
            <div id="calendar-view" class="hidden">
                <div id="mainPlannerSection">
                    <div id="calendar-inner-wrapper">
                        <div class="calendar-header p-3 space-y-3">
                            <div class="calendar-title-row">
                                <h2 id="weekStatus" class="text-xl md:text-2xl font-bold text-center"></h2>
                            </div>
                            <div class="calendar-nav-row">
                                <button id="prevWeekBtn" class="btn btn-secondary btn-sm">&lt; Prev</button>
                                <button id="todayBtn" class="btn btn-secondary btn-sm">Today</button>
                                <button id="nextWeekBtn" class="btn btn-secondary btn-sm">Next &gt;</button>
                            </div>
                            <div class="calendar-view-row">
                                <div class="flex items-center space-x-2">
                                    <button data-view="daily" class="btn btn-secondary btn-sm view-btn">Day</button>
                                    <button data-view="weekly" class="btn btn-secondary btn-sm view-btn">Week</button>
                                    <button data-view="month" class="btn btn-secondary btn-sm view-btn">Month</button>
                                </div>
                                <button id="addNewTaskBtnPlanner" class="btn btn-tertiary btn-md">Add New Task</button>
                            </div>
                        </div>
                        <div id="calendar" class="p-4"></div>
                    </div>
                </div>
                <div id="calendar-category-filters" class="mt-4">
                    <!-- Category filter controls will be rendered here by script.js -->
                </div>
            </div>

            <!-- Dashboard View -->
            <div id="dashboard-view">
                <div class="mb-4 bg-secondary p-2 rounded-lg flex justify-between items-center gap-2 flex-wrap">
                    <div class="flex-1"></div> <!-- Spacer -->
                    <div class="flex items-center gap-2">
                        <button id="dashboard-prev-week-btn" class="btn btn-secondary btn-sm">&lt; Prev</button>
                        <button id="dashboard-today-btn" class="btn btn-secondary btn-sm">Today</button>
                        <button id="dashboard-next-week-btn" class="btn btn-secondary btn-sm">Next &gt;</button>
                    </div>
                    <div id="dashboard-week-display" class="flex-1 text-right text-sm font-semibold"></div>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div class="bg-secondary lg:col-span-1">
                        <h2 id="weekly-goal-label" class="text-lg font-semibold mb-3 border-b pb-2"></h2>
                        <div id="weeklyGoals" contenteditable="true" class="prose prose-sm min-h-[100px] p-2 rounded-md focus:outline-none focus:ring-2"></div>
                    </div>

                    <div id="category-pie-chart-container" class="bg-secondary lg:col-span-2">
                        <h2 class="text-lg font-semibold mb-3 border-b pb-2 text-center">Weekly Time by Category</h2>
                        <div class="relative" style="min-height: 400px;">
                            <canvas id="category-pie-chart"></canvas>
                        </div>
                        <div id="category-pie-chart-legend" class="flex flex-wrap justify-center gap-4 mt-4"></div>
                    </div>

                    <div class="bg-secondary lg:col-span-3">
                        <div class="flex flex-col items-center mb-3 border-b pb-2 gap-4">
                            <h2 class="text-lg font-semibold">Key Performance Indicators</h2>
                            <div id="kpi-controls" class="kpi-controls-container"></div>
                        </div>
                        <div id="kpi-chart-container" class="relative" style="min-height: 400px;">
                            <!-- Chart(s) will be rendered here. The JS will add the gradient wrapper if needed. -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Task Manager View -->
            <div id="task-manager-view" class="hidden">
                <div class="controls">
                    <div class="button-group">
                        <button id="add-task-btn" class="btn btn-tertiary btn-md">
                            Add New Task
                        </button>
                        <button id="view-historical-tasks-btn" class="btn btn-secondary btn-md">View All History</button>
                    </div>
                    <div class="sort-group">
                        <div>
                            <label for="sort-by" class="form-label sr-only">Sort By:</label>
                            <select id="sort-by">
                                <option value="status">Sort by Status</option>
                                <option value="category">Sort by Category</option>
                                <option value="dueDate">Sort by Due Date</option>
                            </select>
                        </div>
                        <div>
                            <label for="sort-direction" class="form-label sr-only">Sort Direction:</label>
                            <select id="sort-direction">
                                <option value="asc">Ascending</option>
                                <option value="desc">Descending</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="task-list" class="space-y-2"></div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="task-modal" class="modal">
        <div class="modal-content bg-modal">
            <button class="close-button" aria-label="Close Task Form">&times;</button>
            <div class="flex justify-between items-center mb-4">
                <h2 id="modal-title" class="text-2xl font-semibold">Add New Task</h2>
                <div class="flex items-center space-x-2">
                    <span id="simple-mode-label" class="text-sm font-medium">Simple</span>
                    <input type="checkbox" id="simple-mode-toggle" class="toggle-checkbox">
                    <span class="text-sm font-medium">Advanced</span>
                </div>
            </div>
             <form id="task-form" class="space-y-4">
                <input type="hidden" id="task-id">
                <div class="mb-4">
                    <label for="task-name" class="form-label">Task Name:</label>
                    <input type="text" id="task-name" name="task-name" required>
                </div>

                <!-- Fields for Simple Mode -->
                <fieldset>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                           <label for="task-category" class="form-label">Category:</label>
                           <select id="task-category" name="task-category">
                               <option value="">None</option>
                               <option value="new_category">-- Add New Category --</option>
                           </select>
                       </div>
                       <div id="new-category-group" class="hidden">
                           <label for="new-category-name" class="form-label">New Category Name:</label>
                           <input type="text" id="new-category-name" name="new-category-name">
                       </div>
                        <div>
                            <label for="task-icon" class="form-label">Icon:</label>
                            <div class="flex items-center space-x-2">
                                <input type="text" id="task-icon" name="task-icon" placeholder="e.g., fa-solid fa-plane" class="flex-grow">
                                <button type="button" id="open-icon-picker" class="btn btn-clear">Choose</button>
                            </div>
                        </div>
                    </div>
                </fieldset>
                <fieldset id="simple-time-fieldset">
                    <div id="time-input-container" class="mb-4">
                        <label class="form-label">Time Input Type:</label>
                        <select id="time-input-type" name="time-input-type">
                            <option value="due">Due Time</option>
                            <option value="start">Start Time</option>
                        </select>
                    </div>
                     <div id="due-date-group" class="mb-4">
                        <label for="task-due-date" class="form-label">Due Date & Time:</label>
                        <input type="datetime-local" id="task-due-date" name="task-due-date">
                    </div>
                    <div id="start-date-group" class="mb-4 hidden">
                        <label for="task-start-date" class="form-label">Start Date & Time:</label>
                        <input type="datetime-local" id="task-start-date" name="task-start-date">
                    </div>
                </fieldset>

                <!-- Advanced Fields -->
                <div id="advanced-task-fields" class="hidden space-y-4">
                    <fieldset>
                        <legend class="form-legend">General</legend>
                        <div class="mb-4">
                            <label for="completion-type" class="form-label">Completion Type:</label>
                            <select id="completion-type" name="completion-type">
                                <option value="simple">Simple (Mark Done)</option>
                                <option value="count">Count</option>
                                <option value="time">Time</option>
                            </select>
                        </div>
                        <div id="completion-count-group" class="mb-4 hidden">
                             <label for="count-target" class="form-label">Target Count:</label>
                             <input type="number" id="count-target" name="count-target" min="1" placeholder="e.g., 100">
                             <p class="form-hint">The total count needed to complete the task.</p>
                        </div>
                        <div id="completion-time-group" class="mb-4 hidden">
                             <label for="time-target-amount" class="form-label">Target Time:</label>
                             <div class="flex space-x-2 items-center">
                                 <input type="number" id="time-target-amount" name="time-target-amount" min="1" placeholder="e.g., 30" class="duration-input">
                                 <select id="time-target-unit" name="time-target-unit" class="flex-grow">
                                    <option value="minutes">Minute(s)</option>
                                    <option value="hours">Hour(s)</option>
                                 </select>
                             </div>
                             <p class="form-hint">The total time needed to complete the task.</p>
                         </div>
                        <div class="mb-4">
                            <label for="task-description" class="form-label">Description:</label>
                            <textarea id="task-description" name="task-description" rows="3"></textarea>
                        </div>
                        <div class="mb-4">
                           <label class="flex items-center">
                               <input type="checkbox" id="is-kpi" name="is-kpi" class="h-4 w-4 rounded">
                               <span class="ml-2 text-sm">Set as Key Performance Indicator (KPI)</span>
                           </label>
                           <p class="form-hint">KPIs are tracked on the dashboard.</p>
                       </div>
                    </fieldset>
                    <fieldset id="advanced-time-fieldset">
                        <legend class="form-legend">Time and Scheduling</legend>
                         <div class="mb-4">
                            <label class="form-label">Due Date Type:</label>
                            <select id="due-date-type" name="due-date-type">
                                <option value="absolute">Absolute Date & Time</option>
                                <option value="relative">Relative Time</option>
                            </select>
                        </div>
                        <div id="advanced-time-inputs-placeholder"></div>
                        <div id="relative-due-date-group" class="mb-4 hidden">
                            <label id="relative-due-date-label" class="form-label">Due In:</label>
                            <div class="flex space-x-2 items-center">
                                <input type="number" id="relative-amount" name="relative-amount" min="1" value="1" class="duration-input">
                                <select id="relative-unit" name="relative-unit" class="flex-grow">
                                    <option value="minutes">Minute(s)</option>
                                    <option value="hours">Hour(s)</option>
                                    <option value="days">Day(s)</option>
                                    <option value="weeks">Week(s)</option>
                                    <option value="months">Month(s)</option>
                                </select>
                            </div>
                            <p class="form-hint">Due relative to the time the task is saved.</p>
                        </div>
                         <p class="form-hint">Estimate how long this task will take. Used for Yellow/Red status calculation.</p>
                         <div id="estimated-duration-group" class="mb-4">
                             <label class="form-label">Estimated Duration:</label>
                             <div class="flex space-x-2 items-center">
                                 <input type="number" id="estimated-duration-amount" name="estimated-duration-amount" min="1" placeholder="e.g., 30" class="duration-input">
                                 <select id="estimated-duration-unit" name="estimated-duration-unit" class="flex-grow">
                                    <option value="minutes">Minute(s)</option>
                                    <option value="hours">Hour(s)</option>
                                 </select>
                             </div>
                         </div>
                         <div class="mb-4">
                            <label class="form-label">Preparation Time:</label>
                            <div class="flex space-x-2 items-center">
                                <input type="number" id="prep-time-amount" name="prep-time-amount" min="1" placeholder="e.g., 15" class="duration-input">
                                <select id="prep-time-unit" name="prep-time-unit" class="flex-grow">
                                   <option value="minutes">Minute(s)</option>
                                   <option value="hours">Hour(s)</option>
                                </select>
                            </div>
                            <p class="form-hint">Optional. How long you need to prepare for or travel to this task.</p>
                        </div>
                         <div class="mb-4">
                               <label class="flex items-center">
                                   <input type="checkbox" id="requires-full-attention" name="requires-full-attention" checked class="h-4 w-4 rounded">
                                   <span class="ml-2 text-sm">This task requires my full attention.</span>
                               </label>
                               <p class="form-hint">Uncheck if you can do other things while this task is 'in progress'.</p>
                           </div>
                           <div class="mb-4">
                               <label class="flex items-center">
                                   <input type="checkbox" id="is-appointment" name="is-appointment" class="h-4 w-4 rounded">
                                   <span class="ml-2 text-sm">Is this an appointment?</span>
                               </label>
                               <p class="form-hint">Appointments must be accomplished at a specific time.</p>
                           </div>
                    </fieldset>
                    <fieldset>
                       <legend class="form-legend">Repetition & Failure Tracking</legend>
                        <div class="mb-4">
                            <select id="task-repetition" name="task-repetition">
                                <option value="none">Non-Repeating</option>
                                <option value="relative">Relative Interval</option>
                                <option value="absolute">Absolute Schedule</option>
                            </select>
                        </div>
                        <div id="repetition-relative-group" class="mb-4 hidden">
                            <label class="form-label">Repeat Every:</label>
                            <div class="flex space-x-2 items-center">
                                <input type="number" id="repetition-amount" name="repetition-amount" min="1" value="1" class="duration-input">
                                <select id="repetition-unit" name="repetition-unit" class="flex-grow">
                                    <option value="minutes">Minute(s)</option> <option value="hours">Hour(s)</option> <option value="days">Day(s)</option> <option value="weeks">Week(s)</option> <option value="months">Month(s)</option>
                                </select>
                            </div>
                        </div>
                        <div id="repetition-absolute-group" class="mb-4 hidden space-y-4">
                            <fieldset>
                                <legend>Frequency & Details</legend>
                                <div>
                                    <label class="form-label">Frequency:</label>
                                    <select id="absolute-frequency" name="absolute-frequency">
                                        <option value="weekly">Weekly</option>
                                        <option value="monthly">Monthly</option>
                                        <option value="yearly">Yearly</option>
                                    </select>
                                </div>
                                <div id="absolute-weekly-options" class="sub-option-group space-y-2">
                                    <label class="form-label">Repeat On Days:</label>
                                    <div class="grid-cols-checkboxes">
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="0" class="weekday-checkbox peer"> <span class="checkbox-label-text">Sun</span></label>
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="1" class="weekday-checkbox peer"> <span class="checkbox-label-text">Mon</span></label>
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="2" class="weekday-checkbox peer"> <span class="checkbox-label-text">Tue</span></label>
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="3" class="weekday-checkbox peer"> <span class="checkbox-label-text">Wed</span></label>
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="4" class="weekday-checkbox peer"> <span class="checkbox-label-text">Thu</span></label>
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="5" class="weekday-checkbox peer"> <span class="checkbox-label-text">Fri</span></label>
                                        <label class="checkbox-label"> <input type="checkbox" name="weekday" value="6" class="weekday-checkbox peer"> <span class="checkbox-label-text">Sat</span></label>
                                    </div>
                                </div>
                                <div id="absolute-monthly-options" class="hidden sub-option-group space-y-2">
                                    <label class="form-label">Repeat Monthly On:</label>
                                    <div>
                                        <label><input type="radio" name="monthlyOption" value="day_number" checked class="mr-1"> Day Number</label>
                                        <label><input type="radio" name="monthlyOption" value="day_of_week" class="ml-4 mr-1"> Day of Week</label>
                                    </div>
                                    <div id="monthly-day-number-options" class="sub-option-group">
                                         <label class="form-label text-xs">Day(s) of Month:</label>
                                         <div class="grid-cols-days">
                                              <script> for(let i=1; i<=31; i++) document.write(`<label class="day-checkbox-label"><input type="checkbox" name="monthlyDay" value="${i}" class="day-checkbox peer"> <span class="day-checkbox-label-text">${i}</span></label>`); </script>
                                              <label class="day-checkbox-label"><input type="checkbox" name="monthlyDay" value="third_last" class="day-checkbox peer"> <span class="day-checkbox-label-text">3rd Last</span></label>
                                              <label class="day-checkbox-label"><input type="checkbox" name="monthlyDay" value="second_last" class="day-checkbox peer"> <span class="day-checkbox-label-text">2nd Last</span></label>
                                              <label class="day-checkbox-label"><input type="checkbox" name="monthlyDay" value="last" class="day-checkbox peer"> <span class="day-checkbox-label-text">Last</span></label>
                                         </div>
                                    </div>
                                    <div id="monthly-day-of-week-options" class="sub-option-group hidden space-y-2">
                                         <label class="form-label text-xs">Which Week(s):</label>
                                         <div class="grid-cols-checkboxes">
                                             <label class="checkbox-label"><input type="checkbox" name="monthlyOccurrence" value="1" class="occurrence-checkbox peer"> <span class="checkbox-label-text">First</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="monthlyOccurrence" value="2" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Second</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="monthlyOccurrence" value="3" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Third</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="monthlyOccurrence" value="4" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Fourth</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="monthlyOccurrence" value="last" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Last</span></label>
                                         </div>
                                         <label class="form-label text-xs">Day(s) of Week:</label>
                                         <div class="grid-cols-checkboxes">
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="0" class="weekday-checkbox peer"> <span class="checkbox-label-text">Sun</span></label>
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="1" class="weekday-checkbox peer"> <span class="checkbox-label-text">Mon</span></label>
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="2" class="weekday-checkbox peer"> <span class="checkbox-label-text">Tue</span></label>
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="3" class="weekday-checkbox peer"> <span class="checkbox-label-text">Wed</span></label>
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="4" class="weekday-checkbox peer"> <span class="checkbox-label-text">Thu</span></label>
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="5" class="weekday-checkbox peer"> <span class="checkbox-label-text">Fri</span></label>
                                            <label class="checkbox-label"><input type="checkbox" name="monthlyWeekday" value="6" class="weekday-checkbox peer"> <span class="checkbox-label-text">Sat</span></label>
                                        </div>
                                    </div>
                                </div>
                                <div id="absolute-yearly-options" class="hidden sub-option-group space-y-2">
                                    <label class="form-label">Repeat Yearly In Month(s):</label>
                                    <div class="grid-cols-checkboxes">
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="0" class="month-checkbox peer"> <span class="checkbox-label-text">Jan</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="1" class="month-checkbox peer"> <span class="checkbox-label-text">Feb</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="2" class="month-checkbox peer"> <span class="checkbox-label-text">Mar</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="3" class="month-checkbox peer"> <span class="checkbox-label-text">Apr</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="4" class="month-checkbox peer"> <span class="checkbox-label-text">May</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="5" class="month-checkbox peer"> <span class="checkbox-label-text">Jun</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="6" class="month-checkbox peer"> <span class="checkbox-label-text">Jul</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="7" class="month-checkbox peer"> <span class="checkbox-label-text">Aug</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="8" class="month-checkbox peer"> <span class="checkbox-label-text">Sep</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="9" class="month-checkbox peer"> <span class="checkbox-label-text">Oct</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="10" class="month-checkbox peer"> <span class="checkbox-label-text">Nov</span></label>
                                         <label class="checkbox-label"><input type="checkbox" name="yearlyMonth" value="11" class="month-checkbox peer"> <span class="checkbox-label-text">Dec</span></label>
                                    </div>
                                    <div class="mt-2">
                                        <label><input type="radio" name="yearlyOption" value="day_number" checked class="mr-1"> On Day Number</label>
                                        <label><input type="radio" name="yearlyOption" value="day_of_week" class="ml-4 mr-1"> On Day of Week</label>
                                    </div>
                                    <div id="yearly-day-number-options" class="sub-option-group">
                                        <label class="form-label text-xs">Day(s) of Month:</label>
                                        <div class="grid-cols-days">
                                              <script> for(let i=1; i<=31; i++) document.write(`<label class="day-checkbox-label"><input type="checkbox" name="yearlyDay" value="${i}" class="day-checkbox peer"> <span class="day-checkbox-label-text">${i}</span></label>`); </script>
                                              <label class="day-checkbox-label"><input type="checkbox" name="yearlyDay" value="third_last" class="day-checkbox peer"> <span class="day-checkbox-label-text">3rd Last</span></label>
                                              <label class="day-checkbox-label"><input type="checkbox" name="yearlyDay" value="second_last" class="day-checkbox peer"> <span class="day-checkbox-label-text">2nd Last</span></label>
                                              <label class="day-checkbox-label"><input type="checkbox" name="yearlyDay" value="last" class="day-checkbox peer"> <span class="day-checkbox-label-text">Last</span></label>
                                         </div>
                                    </div>
                                    <div id="yearly-day-of-week-options" class="sub-option-group hidden">
                                        <label class="form-label text-xs">Which Week(s):</label>
                                        <div class="grid-cols-checkboxes">
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyOccurrence" value="1" class="occurrence-checkbox peer"> <span class="checkbox-label-text">First</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyOccurrence" value="2" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Second</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyOccurrence" value="3" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Third</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyOccurrence" value="4" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Fourth</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyOccurrence" value="last" class="occurrence-checkbox peer"> <span class="checkbox-label-text">Last</span></label>
                                         </div>
                                         <label class="form-label text-xs">Day(s) of Week:</label>
                                         <div class="grid-cols-checkboxes">
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="0" class="weekday-checkbox peer"> <span class="checkbox-label-text">Sun</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="1" class="weekday-checkbox peer"> <span class="checkbox-label-text">Mon</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="2" class="weekday-checkbox peer"> <span class="checkbox-label-text">Tue</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="3" class="weekday-checkbox peer"> <span class="checkbox-label-text">Wed</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="4" class="weekday-checkbox peer"> <span class="checkbox-label-text">Thu</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="5" class="weekday-checkbox peer"> <span class="checkbox-label-text">Fri</span></label>
                                             <label class="checkbox-label"><input type="checkbox" name="yearlyWeekday" value="6" class="weekday-checkbox peer"> <span class="checkbox-label-text">Sat</span></label>
                                        </div>
                                    </div>
                                </div>
                            </fieldset>
                        </div>
                        <div id="repeating-options-group" class="mb-4 hidden">
                            <fieldset>
                                <legend>Repetition End Condition</legend>
                                <div class="mb-2">
                                    <label><input type="radio" name="repeat-until-mode" value="date" checked class="mr-1"> On date</label>
                                    <label><input type="radio" name="repeat-until-mode" value="occurrences" class="ml-4 mr-1"> After a number of occurrences</label>
                                </div>
                                <div id="repeat-until-date-group">
                                    <label for="repeat-until-date" class="form-label sr-only">Repeat Until Date:</label>
                                    <input type="datetime-local" id="repeat-until-date" name="repeat-until-date">
                                    <p class="form-hint">The task will not repeat after this date.</p>
                                </div>
                                <div id="repeat-until-occurrences-group" class="hidden">
                                    <label for="repeat-until-occurrences" class="form-label sr-only">Number of Occurrences:</label>
                                    <input type="number" id="repeat-until-occurrences" name="repeat-until-occurrences" min="1" placeholder="e.g., 10">
                                    <p class="form-hint">The task will stop repeating after this many occurrences.</p>
                                </div>
                            </fieldset>
                            <fieldset>
                                <legend>Failure Tracking</legend>
                                <div id="max-misses-group" class="mb-4">
                                    <label for="max-misses" class="form-label">Max Misses Before Failure:</label>
                                    <input type="number" id="max-misses" name="max-misses" min="1" placeholder="e.g., 3">
                                </div>
                                <div class="mb-4">
                                   <label class="flex items-center">
                                       <input type="checkbox" id="track-misses" name="track-misses" checked class="h-4 w-4 rounded">
                                       <span class="ml-2 text-sm">Track Misses?</span>
                                   </label>
                               </div>
                            </fieldset>
                        </div>
                    </fieldset>
                </div>
                <div class="flex justify-end space-x-3 mt-8">
                   <button type="button" class="btn btn-clear cancel-task-button"> Cancel </button>
                   <button type="submit" class="btn btn-confirm btn-md"> Save Task </button>
               </div>
             </form>
        </div>
    </div>

    <div id="icon-picker-modal" class="modal">
        <div class="modal-content bg-modal">
            <button class="close-button" aria-label="Close Icon Picker">&times;</button>
            <h2 class="text-2xl font-semibold mb-4">Choose an Icon</h2>
            <div id="icon-picker-content" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
        </div>
    </div>

    <div id="advanced-options-modal" class="modal">
        <div class="modal-content bg-modal">
            <button class="close-button" aria-label="Close Advanced Options">&times;</button>
            <h2 class="text-2xl font-semibold mb-6">Advanced Options</h2>
            <div id="advanced-options-content" class="space-y-2">
                <!-- 1. Appearance Section -->
                <div class="collapsible-section" data-section-key="appearance">
                    <h3 class="collapsible-header">
                        <span>Appearance</span>
                        <i class="fas fa-chevron-down"></i>
                    </h3>
                    <div class="collapsible-content">
                        <fieldset>
                            <legend>Theme Engine</legend>
                            <div id="theme-manager-content" class="space-y-3">
                                <div class="form-group">
                                    <label class="form-label" title="Choose the color mode for the application. 'Auto' will sync with your operating system's setting.">Mode:</label>
                                    <div id="theme-mode-selector" class="flex space-x-1 rounded-md p-1 bg-secondary">
                                        <button data-mode="light" class="btn btn-secondary btn-sm flex-1 theme-mode-btn" title="Set the application to light mode.">Day</button>
                                        <button data-mode="night" class="btn btn-secondary btn-sm flex-1 theme-mode-btn" title="Set the application to dark mode.">Night</button>
                                        <button data-mode="auto" class="btn btn-secondary btn-sm flex-1 theme-mode-btn" title="Automatically switch between light and dark mode based on your system settings.">Auto</button>
                                    </div>
                                </div>
                                <div class="form-group flex items-center justify-between">
                                    <label for="theme-enabled-toggle" class="form-label mb-0" title="Enable to use a custom color for the entire application interface.">Enable Custom Theme Engine:</label>
                                    <input type="checkbox" id="theme-enabled-toggle" data-action="toggleTheme" class="toggle-checkbox">
                                </div>
                                <div id="theme-controls" class="hidden space-y-3">
                                    <div class="form-group flex items-center justify-between">
                                        <label for="theme-base-color" class="form-label mb-0" title="Select the main color for your custom theme.">Theme Base Color:</label>
                                        <input type="color" id="theme-base-color" data-action="setThemeColor" class="h-8 w-12 border-none cursor-pointer rounded">
                                    </div>
                                    <button data-action="randomizeTheme" class="btn btn-tertiary btn-md w-full" title="Select a new random color for your custom theme.">Randomize Theme</button>
                                </div>
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Status & Colors</legend>
                            <div class="space-y-2" id="status-color-manager"></div>
                        </fieldset>
                        <fieldset>
                            <legend>Display Options</legend>
                            <div class="space-y-3">
                                <div class="flex items-center justify-between">
                                    <label for="time-format-toggle" class="form-label mb-0" title="Switch between 12-hour (AM/PM) and 24-hour time formats throughout the application.">Use 24-Hour Time Format:</label>
                                    <input type="checkbox" id="time-format-toggle" data-action="toggleTimeFormat" class="toggle-checkbox">
                                </div>
                                <div id="task-card-display-options" class="grid grid-cols-2 gap-2" title="Choose which details to show on tasks in the Task Manager view.">
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showDueDate" class="task-display-toggle"><span>Show Due Date</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showRepetition" class="task-display-toggle"><span>Show Repetition</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showDuration" class="task-display-toggle"><span>Show Duration</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showCategory" class="task-display-toggle"><span>Show Category</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showCountdown" class="task-display-toggle"><span>Show Countdown</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showProgress" class="task-display-toggle"><span>Show Progress Bar</span></label>
                                </div>
                            </div>
                        </fieldset>
                    </div>
                </div>

                <!-- 2. Task Behavior Section -->
                <div class="collapsible-section" data-section-key="behavior">
                    <h3 class="collapsible-header"><span>Task Behavior</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content">
                        <fieldset>
                             <legend>Planner Sensitivity</legend>
                             <div class="space-y-3">
                                 <div class="flex items-center justify-between">
                                     <label for="planner-sensitivity-default-toggle" class="form-label mb-0" title="Check this to use the balanced, default sensitivity setting.">Use Default Sensitivity:</label>
                                     <input type="checkbox" id="planner-sensitivity-default-toggle" class="toggle-checkbox">
                                 </div>
                                 <div class="flex items-center space-x-3">
                                     <span title="Tasks will change status (e.g., to Yellow or Red) much later, giving you more time.">Easy</span>
                                     <input type="range" id="planner-sensitivity-slider" min="0" max="1" step="0.01" class="w-full" title="Adjust how early the planner warns you about upcoming tasks.">
                                     <span title="Tasks will change status much earlier, giving you more advance warning.">Hard</span>
                                 </div>
                             </div>
                         </fieldset>
                        <fieldset>
                            <legend>Grading System</legend>
                            <div class="form-group">
                                <label for="gpa-system-select" class="form-label" title="Choose the letter grade scale used for task history and statistics.">GPA Scale:</label>
                                <select id="gpa-system-select">
                                    <option value="standard">Standard (A-F)</option>
                                    <option value="extended">Extended (S-F)</option>
                                </select>
                            </div>
                        </fieldset>
                         <fieldset>
                            <legend>Icon Synchronization</legend>
                            <div class="flex items-center justify-between">
                                <label for="sync-task-icons-toggle" class="form-label mb-0" title="When enabled, changing a task's icon will also change the icon for all of its historical records.">Sync Task Icons Across History:</label>
                                <input type="checkbox" id="sync-task-icons-toggle" data-action="toggleSyncTaskIcons" class="toggle-checkbox">
                            </div>
                        </fieldset>
                    </div>
                </div>

                <!-- 3. Calendar & Scheduling Section -->
                <div class="collapsible-section" data-section-key="scheduling">
                    <h3 class="collapsible-header"><span>Calendar & Scheduling</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content">
                        <fieldset>
                            <legend>General Calendar</legend>
                             <div class="form-group">
                                <label for="calendar-gradient-toggle" class="form-label" title="Choose whether the glowing border around the calendar is based on the current task status spectrum or your custom theme color.">Calendar Border Source:</label>
                                <div id="calendar-gradient-selector" class="flex flex-wrap space-x-1 rounded-md p-1 bg-secondary">
                                     <button data-action="setCalendarGradientSource" data-source="status" class="btn btn-secondary btn-sm flex-1 calendar-gradient-btn" title="The border will be a gradient of your current status colors (e.g., Blue, Green, Yellow, Red).">Status</button>
                                     <button data-action="setCalendarGradientSource" data-source="theme" class="btn btn-secondary btn-sm flex-1 calendar-gradient-btn" title="The border will be a gradient based on your selected custom theme color.">Theme</button>
                                </div>
                            </div>
                             <div class="flex items-center justify-between">
                                <label for="allow-creation-on-click-toggle" class="form-label mb-0" title="Enable this to create a new task by clicking or tapping directly on an empty time slot in the calendar.">Create Task on Calendar Click:</label>
                                <input type="checkbox" id="allow-creation-on-click-toggle" data-action="toggleCreationOnClick" class="toggle-checkbox">
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Calendar View Options</legend>
                             <div class="flex items-center justify-between">
                                <label for="show-calendar-filters-toggle" class="form-label mb-0" title="Show or hide the category filter checkboxes that appear below the calendar.">Show Category Filters:</label>
                                <input type="checkbox" id="show-calendar-filters-toggle" data-action="toggleShowCalendarFilters" class="toggle-checkbox">
                            </div>
                            <div id="month-view-display-options" class="mt-4" title="Choose what information to display for events in the Month view.">
                                <p class="form-label mb-1">Month View Display:</p>
                                <div class="grid grid-cols-2 gap-2">
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showIcon" class="month-view-display-toggle"><span>Show Icon</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showTime" class="month-view-display-toggle"><span>Show Time</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showName" class="month-view-display-toggle"><span>Show Name</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="groupTasks" class="month-view-display-toggle"><span>Group Tasks</span></label>
                                </div>
                            </div>
                            <div id="week-view-display-options" class="mt-4" title="Choose what information to display for events in the Week view.">
                                <p class="form-label mb-1">Week View Display:</p>
                                <div class="grid grid-cols-2 gap-2">
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showIcon" class="week-view-display-toggle"><span>Show Icon</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showTime" class="week-view-display-toggle"><span>Show Time</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showName" class="week-view-display-toggle"><span>Show Name</span></label>
                                </div>
                            </div>
                             <div id="day-view-display-options" class="mt-4" title="Choose what information to display for events in the Day view.">
                                <p class="form-label mb-1">Day View Display:</p>
                                <div class="grid grid-cols-2 gap-2">
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showIcon" class="day-view-display-toggle"><span>Show Icon</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showTime" class="day-view-display-toggle"><span>Show Time</span></label>
                                    <label class="flex items-center space-x-2"><input type="checkbox" name="showName" class="day-view-display-toggle"><span>Show Name</span></label>
                                </div>
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>"Early is on Time" Rule</legend>
                            <div class="space-y-3">
                                <div class="flex items-center justify-between">
                                    <label for="early-on-time-toggle" class="form-label mb-0" title="Enable a 15-minute grace period, where tasks completed slightly early are still considered 'on time'.">Enable "15 mins early is on time":</label>
                                    <input type="checkbox" id="early-on-time-toggle" data-action="toggleEarlyOnTime" class="toggle-checkbox">
                                </div>
                                <div id="early-on-time-options" class="hidden space-y-3 pl-4 border-l-2 border-gray-700">
                                    <div class="flex items-center justify-between">
                                        <label for="early-on-time-appointments-toggle" class="form-label mb-0" title="Restrict this rule so it only applies to tasks marked as 'appointments'.">Apply rule only to appointments:</label>
                                        <input type="checkbox" id="early-on-time-appointments-toggle" data-action="toggleEarlyOnTimeAppointments" class="toggle-checkbox">
                                    </div>
                                </div>
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Buffer Management</legend>
                            <div id="buffer-management-content"></div>
                        </fieldset>
                        <fieldset>
                            <legend>Vacation Schedule</legend>
                            <div id="vacation-manager-content"></div>
                        </fieldset>
                    </div>
                </div>

                <!-- 4. Content Management Section -->
                <div class="collapsible-section" data-section-key="content">
                    <h3 class="collapsible-header"><span>Content Management</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content">
                        <fieldset>
                            <legend>Category Management</legend>
                            <div id="category-manager-list" class="space-y-2"></div>
                            <div id="add-category-form-container" class="mt-4"></div>
                        </fieldset>
                         <fieldset>
                            <legend>Banner Naming</legend>
                            <div class="space-y-3">
                                <div>
                                    <label for="app-title-input" class="form-label" title="The main title displayed at the top of the application.">App Title:</label>
                                    <input type="text" id="app-title-input" class="w-full">
                                </div>
                                <div>
                                    <label for="app-subtitle-input" class="form-label" title="The smaller text displayed below the main title.">App Subtitle:</label>
                                    <input type="text" id="app-subtitle-input" class="w-full">
                                </div>
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Journal & Goals</legend>
                            <div class="space-y-3">
                                 <div id="journal-settings-content"></div>
                                 <div>
                                    <label for="app-goal-label-input" class="form-label" title="The text label displayed above the weekly goal editor on the Dashboard.">Weekly Goal Label:</label>
                                    <input type="text" id="app-goal-label-input" class="w-full">
                                </div>
                            </div>
                        </fieldset>
                    </div>
                </div>

                <!-- 5. Automation & Performance -->
                <div class="collapsible-section" data-section-key="automation">
                    <h3 class="collapsible-header"><span>Automation & Performance</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content">
                        <fieldset>
                             <legend>Task Form Automation</legend>
                             <div class="flex items-center justify-between">
                                    <label for="smart-form-defaults-toggle" class="form-label mb-0" title="Remembers your most frequently used settings for fields like task type and time units, and sets them as the default for new tasks.">Enable Smart Form Defaults:</label>
                                    <input type="checkbox" id="smart-form-defaults-toggle" data-action="toggleSmartFormDefaults" class="toggle-checkbox">
                                </div>
                        </fieldset>
                        <fieldset>
                            <legend>KPI Automation</legend>
                            <div id="kpi-automation-settings"></div>
                        </fieldset>
                        <fieldset>
                             <legend>Performance</legend>
                             <p class="form-hint mb-2" title="Defines how far into the future to calculate repeating tasks. Shorter horizons can improve performance on devices with many complex tasks.">Calculation Horizon:</p>
                             <div class="flex items-center space-x-2">
                                 <input type="number" id="calculation-horizon-amount" value="1" min="1" class="w-20">
                                 <select id="calculation-horizon-unit">
                                     <option value="weeks">Weeks</option>
                                     <option value="months">Months</option>
                                     <option value="years">Years</option>
                                 </select>
                             </div>
                        </fieldset>
                    </div>
                </div>

                <!-- 6. Notifications Section -->
                <div class="collapsible-section" data-section-key="notifications">
                    <h3 class="collapsible-header"><span>Notifications</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content">
                        <fieldset>
                            <legend>Desktop Notifications</legend>
                            <div id="notification-manager-content"></div>
                        </fieldset>
                    </div>
                </div>

                <!-- 7. Data Management Section -->
                <div class="collapsible-section" data-section-key="data">
                    <h3 class="collapsible-header"><span>Data Management</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content space-y-4">
                        <fieldset>
                            <legend>Import / Export</legend>
                            <div class="grid grid-cols-2 gap-2">
                                <button data-action="exportData" data-export-type="all" class="btn btn-secondary btn-md" title="Export all tasks, categories, history, and settings into a single JSON file.">Export All Data</button>
                                <button data-action="exportData" data-export-type="tasks" class="btn btn-secondary btn-md" title="Export only your active tasks and their associated categories.">Export Tasks Only</button>
                                <button data-action="importData" class="btn btn-secondary btn-md col-span-2" title="Import data from a previously exported JSON file.">Import from File</button>
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Cleanup & Migration</legend>
                            <div class="grid grid-cols-1 gap-2">
                                <button data-action="openMigrationTool" class="btn btn-secondary btn-md" title="Find and delete orphaned history records or migrate data from a different version.">Open Data Migration / Cleanup Tool</button>
                            </div>
                        </fieldset>
                    </div>
                </div>

                 <!-- 8. Feature Flags & Toggles -->
                <div class="collapsible-section" data-section-key="features">
                    <h3 class="collapsible-header"><span>Feature Flags & Toggles</span><i class="fas fa-chevron-down"></i></h3>
                    <div class="collapsible-content space-y-4">
                        <fieldset>
                            <legend>Task View Behavior</legend>
                             <div class="flex items-center justify-between">
                                <label for="close-modal-after-action-toggle" class="form-label mb-0" title="When enabled, the task detail pop-up will close automatically after you complete, miss, or delete a task from it.">Close modal after action:</label>
                                <input type="checkbox" id="close-modal-after-action-toggle" data-action="toggleCloseModalAfterAction" class="toggle-checkbox">
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Hint Banners</legend>
                            <div id="hint-manager-content" class="space-y-3">
                                <!-- Hint management controls will be injected by script.js -->
                            </div>
                        </fieldset>
                        <fieldset>
                            <legend>Danger Zone</legend>
                            <div id="restore-defaults-container" class="mt-2">
                                <button data-action="restoreDefaults" class="btn btn-deny btn-md w-full" title="This will reset all theme, color, and naming settings to their original defaults.">Restore All View Defaults</button>
                            </div>
                        </fieldset>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="data-migration-modal" class="modal"><div class="modal-content bg-modal"></div></div>

    <div id="task-view-modal" class="modal">
        <!-- This new wrapper will hold the gradient border -->
        <div id="task-view-modal-border-wrapper" style="border-radius: 0.75rem; padding: 14px; transition: background 0.5s ease;">
            <div class="modal-content bg-modal">
                <button class="close-button" aria-label="Close Task View">&times;</button>
                <div id="task-view-content"></div>
                <div id="task-stats-content" class="hidden"></div>
            </div>
        </div>
    </div>

    <div id="historical-overview-modal" class="modal">
        <div class="modal-content bg-modal" style="max-width: 800px;">
            <button class="close-button">&times;</button>
            <h2 class="text-2xl font-semibold mb-4">Historical Task Overview</h2>
            <div class="flex justify-end items-center mb-4 gap-2">
                <label for="historical-sort-by" class="form-label mb-0">Sort By:</label>
                <select id="historical-sort-by">
                    <option value="name">Name</option>
                    <option value="lastCompleted">Last Completed</option>
                    <option value="gpa">Average GPA</option>
                </select>
                <select id="historical-sort-direction">
                    <option value="asc">Ascending</option>
                    <option value="desc">Descending</option>
                </select>
            </div>
            <div id="historical-overview-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-[70vh] overflow-y-auto p-2">
                <!-- Historical task cards will be injected here -->
            </div>
        </div>
    </div>

    <div id="journal-modal" class="modal">
        <div class="modal-content bg-modal">
            <button class="close-button" aria-label="Close Journal Entry">&times;</button>
            <h2 id="journal-modal-title" class="text-2xl font-semibold mb-4">New Journal Entry</h2>
            <form id="journal-form" class="space-y-4">
                <input type="hidden" id="journal-entry-id">
                <div>
                    <label for="journal-entry-title" class="form-label">Title:</label>
                    <input type="text" id="journal-entry-title" required>
                </div>
                <div>
                    <label for="journal-entry-icon" class="form-label">Icon:</label>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="journal-entry-icon" placeholder="e.g., fa-solid fa-book" class="flex-grow">
                        <button type="button" id="open-journal-icon-picker" data-action="openIconPicker" data-context="journal" class="btn btn-clear">Choose Icon</button>
                    </div>
                </div>
                <div>
                    <label for="journal-entry-content" class="form-label">Content:</label>
                    <textarea id="journal-entry-content" rows="10"></textarea>
                </div>
                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" class="btn btn-clear cancel-journal-button">Cancel</button>
                    <button type="submit" class="btn btn-confirm btn-md">Save Entry</button>
                </div>
            </form>
        </div>
    </div>

    <script type="module">
import { Calendar } from 'https://esm.sh/@fullcalendar/core@6.1.19';
import dayGridPlugin from 'https://esm.sh/@fullcalendar/daygrid@6.1.19';
import timeGridPlugin from 'https://esm.sh/@fullcalendar/timegrid@6.1.19';
import interactionPlugin from 'https://esm.sh/@fullcalendar/interaction@6.1.19';
import { Chart, registerables } from 'https://esm.sh/chart.js@4.4.3';
import { startOfWeek, format } from 'https://esm.sh/date-fns@3.6.0';

// --- task-logic.js ---
// =================================================================================
// TL-1.0: CORE UTILITIES
// =================================================================================

const MS_PER_MINUTE = 60000;
const MS_PER_HOUR = 3600000;
const MS_PER_DAY = 86400000;

function getDurationMs(amount, unit) {
  if (!amount || !unit || amount <= 0) return 0;
  amount = parseInt(amount, 10);
  let ms = 0;
  switch (unit) {
  case 'minutes': ms = amount * MS_PER_MINUTE; break;
  case 'hours': ms = amount * MS_PER_HOUR; break;
  case 'days': ms = amount * MS_PER_DAY; break;
  case 'weeks': ms = amount * 7 * MS_PER_DAY; break;
  case 'months': ms = amount * 30 * MS_PER_DAY; break; // Approximation
  default: console.warn('Unknown duration unit:', unit); ms = 0;
  }
  return ms;
}

// =================================================================================
// TL-2.0: OCCURRENCE & DATE GENERATION
// =================================================================================

function checkDayOfMonthMatch(date, daysOfMonth) {
  if (!daysOfMonth || daysOfMonth.length === 0) return false;
  const day = date.getDate();
  const year = date.getFullYear();
  const month = date.getMonth();
  const daysInMonth = new Date(year, month + 1, 0).getDate();
  for (const selectedDay of daysOfMonth) {
    const selectedDayStr = String(selectedDay);
    if (selectedDayStr === 'last' && day === daysInMonth) return true;
    if (selectedDayStr === 'second_last' && day === daysInMonth - 1) return true;
    if (selectedDayStr === 'third_last' && day === daysInMonth - 2) return true;
    const selectedDayNum = parseInt(selectedDayStr, 10);
    if (!isNaN(selectedDayNum) && selectedDayNum === day) {
      return true;
    }
  }
  return false;
}
function checkNthWeekdayMatch(date, occurrences, weekdays) {
  if (!occurrences || occurrences.length === 0 || !weekdays || weekdays.length === 0) return false;
  const targetDayOfWeek = date.getDay();
  if (!weekdays.includes(targetDayOfWeek)) {
    return false;
  }
  const dayOfMonth = date.getDate();
  const month = date.getMonth();
  const occurrenceNumber = Math.ceil(dayOfMonth / 7);
  for (const selectedOcc of occurrences) {
    const selectedOccStr = String(selectedOcc);
    if (selectedOccStr === 'last') {
      let nextWeekDate = new Date(date);
      nextWeekDate.setDate(dayOfMonth + 7);
      if (nextWeekDate.getMonth() !== month) return true;
    } else {
      const selectedOccNum = parseInt(selectedOccStr, 10);
      if (!isNaN(selectedOccNum) && selectedOccNum === occurrenceNumber) {
        return true;
      }
    }
  }
  return false;
}
function generateAbsoluteOccurrences(task, startDate, endDate) {
  if (task.repetitionType !== 'absolute' || !task.repetitionAbsoluteFrequency || !startDate || isNaN(startDate) || !endDate || isNaN(endDate) || endDate < startDate) {
    // console.error(`Invalid input for generateAbsoluteOccurrences for task ${task.id}`);
    return [];
  }
  let occurrences = [];
  let currentDate = new Date(startDate);
  currentDate.setHours(0, 0, 0, 0);
  const maxDaysToScan = 366 * 10;
  let daysScanned = 0;
  const applyTime = (date) => {
    const originalTimeSource = task.dueDate || startDate;
    if (originalTimeSource && !isNaN(originalTimeSource)) {
      date.setHours(originalTimeSource.getHours(), originalTimeSource.getMinutes(), originalTimeSource.getSeconds(), originalTimeSource.getMilliseconds());
    } else {
      date.setHours(0, 0, 0, 0);
    }
    return date;
  };
  while (currentDate <= endDate && daysScanned < maxDaysToScan) {
    daysScanned++;
    let month = currentDate.getMonth();
    let dayOfWeek = currentDate.getDay();
    let isMatch = false;
    try {
      switch (task.repetitionAbsoluteFrequency) {
      case 'weekly':
        if (task.repetitionAbsoluteWeeklyDays?.includes(dayOfWeek)) isMatch = true;
        break;
      case 'monthly':
        if (task.repetitionAbsoluteMonthlyMode === 'day_number') {
          if (checkDayOfMonthMatch(currentDate, task.repetitionAbsoluteDaysOfMonth)) isMatch = true;
        } else {
          if (checkNthWeekdayMatch(currentDate, task.repetitionAbsoluteNthWeekdayOccurrence, task.repetitionAbsoluteNthWeekdayDays)) isMatch = true;
        }
        break;
      case 'yearly':
        if (task.repetitionAbsoluteYearlyMonths?.includes(month)) {
          if (task.repetitionAbsoluteYearlyMode === 'day_number') {
            if (checkDayOfMonthMatch(currentDate, task.repetitionAbsoluteYearlyDaysOfMonth)) isMatch = true;
          } else {
            if (checkNthWeekdayMatch(currentDate, task.repetitionAbsoluteYearlyNthWeekdayOccurrence, task.repetitionAbsoluteYearlyNthWeekdayDays)) isMatch = true;
          }
        }
        break;
      }
    } catch (e) {
      console.error(`Error checking match for ${task.id} on ${currentDate} in generateAbsoluteOccurrences:`, e);
    }
    if (isMatch) {
      let occurrenceDate = applyTime(new Date(currentDate));
      if (occurrenceDate.getTime() >= startDate.getTime() && occurrenceDate.getTime() <= endDate.getTime()) {
        occurrences.push(occurrenceDate);
      }
    }
    currentDate.setDate(currentDate.getDate() + 1);
    currentDate.setHours(0, 0, 0, 0);
  }
  if (daysScanned >= maxDaysToScan) {
    console.warn(`generateAbsoluteOccurrences reached scan limit (${maxDaysToScan} days) for task ${task.id}`);
  }
  occurrences.sort((a, b) => a.getTime() - b.getTime());
  return occurrences;
}

function getOccurrences(task, startDate, endDate) {
  const dueDates = [];
  if (!task.dueDate) return dueDates;

  const repeatUntilDate = task.repeatUntil ? new Date(task.repeatUntil) : null;
  const finalEndDate = (repeatUntilDate && repeatUntilDate < endDate) ? repeatUntilDate : endDate;

  const initialDueDate = new Date(task.dueDate);

  if (task.repetitionType === 'none') {
    if (initialDueDate >= startDate && initialDueDate <= finalEndDate) {
      dueDates.push(initialDueDate);
    }
  } else if (task.repetitionType === 'absolute') {
    return generateAbsoluteOccurrences(task, startDate, finalEndDate);
  } else if (task.repetitionType === 'relative') {
    const intervalMs = getDurationMs(task.repetitionAmount, task.repetitionUnit);
    if (intervalMs > 0) {
      let currentDate = new Date(initialDueDate);
      while (currentDate.getTime() < startDate.getTime()) {
        currentDate = new Date(currentDate.getTime() + intervalMs);
      }
      let i = 0; // Safety break
      while (currentDate.getTime() <= finalEndDate.getTime() && i < 500) {
        dueDates.push(new Date(currentDate));
        currentDate = new Date(currentDate.getTime() + intervalMs);
        i++;
      }
    }
  }
  return dueDates;
}


function isDateInVacation(date, vacations) {
  if (!vacations || vacations.length === 0) return false;
  const checkTime = new Date(date).setHours(0, 0, 0, 0);

  for (const vacation of vacations) {
    const startTime = new Date(vacation.startDate).setHours(0, 0, 0, 0);
    const endTime = new Date(vacation.endDate).setHours(23, 59, 59, 999);
    if (checkTime >= startTime && checkTime <= endTime) {
      return vacation; // Return the vacation object if found
    }
  }
  return false;
}

function adjustDateForVacation(date, vacations, taskCategoryId, allCategories) {
  const category = allCategories.find(c => c.id === taskCategoryId);
  const canBypassVacation = category ? category.bypassVacation : false;

  if (canBypassVacation || !date) {
    return date;
  }

  const originalHours = date.getHours();
  const originalMinutes = date.getMinutes();
  const originalSeconds = date.getSeconds();

  let currentDate = new Date(date);
  let vacation = isDateInVacation(currentDate, vacations);
  while (vacation) {
    const vacationEndDate = new Date(vacation.endDate);
    currentDate = new Date(vacationEndDate.getFullYear(), vacationEndDate.getMonth(), vacationEndDate.getDate() + 1, originalHours, originalMinutes, originalSeconds);
    vacation = isDateInVacation(currentDate, vacations);
  }
  return currentDate;
}

// =================================================================================
// TL-3.0: CALCULATION PIPELINE
// =================================================================================

/**
 * The new V11 GPA-based calculation pipeline. This is the single source of truth for task status and scheduling.
 * @param {Array} tasks - The array of all active tasks.
 * @param {Date} calculationHorizon - The date until which to project tasks.
 * @param {object} settings - An object containing user settings like sensitivity, vacations, and categories.
 * @returns {Array} A new array of all processed task occurrences, not the original tasks.
 */
function runCalculationPipeline(tasks, calculationHorizon, settings, now_for_testing) {
  const now = now_for_testing || new Date();
  const nowMs = now.getTime();
  const { sensitivity, vacations, categories, calendarCategoryFilters, earlyOnTimeSettings = { enabled: false, displaceCalendar: false, onlyAppointments: false } } = settings;

  // --- Step 0: Filter tasks based on calendar 'schedule' settings ---
  const filteredTasks = tasks.filter(task => {
    if (!calendarCategoryFilters) return true; // If setting doesn't exist, don't filter
    const catId = task.categoryId || 'null';
    const filter = calendarCategoryFilters[catId];
    // A category is excluded ONLY if its 'schedule' property is explicitly false.
    return !filter || filter.schedule !== false;
  });

  // --- Step 1: Generate all occurrences ---
  let allOccurrences = [];
  filteredTasks.forEach(task => {
    if (!task.dueDate) return;
    // Ensure the task has an overrides object
    if (!task.occurrenceOverrides) {
      task.occurrenceOverrides = {};
    }

    if (task.repetitionType === 'none') {
      if (!task.completed) {
        const occurrenceId = `${task.id}_${new Date(task.dueDate).toISOString()}`;
        const override = task.occurrenceOverrides[occurrenceId] || {};
        allOccurrences.push({
          ...task,
          ...override, // Apply any specific overrides
          originalId: task.id,
          id: occurrenceId,
          occurrenceDueDate: new Date(task.dueDate),
        });
      }
    } else {
      const startScanDate = (task.overdueStartDate) ? new Date(task.overdueStartDate) : now;
      const dueDates = getOccurrences(task, startScanDate, calculationHorizon);

      dueDates.forEach(dueDate => {
        // This is the new unique ID for each projected instance.
        const occurrenceId = `${task.id}_${dueDate.toISOString()}`;
        const override = task.occurrenceOverrides[occurrenceId] || {};

        let finalOccurrenceDueDate = dueDate;
        // If an override has a date, prioritize it over the calculated recurrence date
        if (override.dueDate) {
          finalOccurrenceDueDate = new Date(override.dueDate);
        } else if (override.occurrenceDueDate) {
             // Fallback if saved differently
             finalOccurrenceDueDate = new Date(override.occurrenceDueDate);
        }

        allOccurrences.push({
          ...task,
          ...override, // Apply any specific overrides
          originalId: task.id,
          id: occurrenceId,
          occurrenceDueDate: finalOccurrenceDueDate,
        });
      });
    }
  });

  // --- Step 2.1: Calculate "Positioning GPA" & Prioritize ---
  allOccurrences.forEach(occurrence => {
    const task = occurrence;
    const baseDueDate = adjustDateForVacation(new Date(task.occurrenceDueDate), vacations, task.categoryId, categories);
    task.baseDueDate = baseDueDate;

    const prepTimeMs = getDurationMs(task.prepTimeAmount, task.prepTimeUnit);
    const estimatedDurationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
    const urgencySourceDuration = prepTimeMs > 0 ? prepTimeMs : estimatedDurationMs;
    const warningWindow = urgencySourceDuration * 4;
    const timeUntilDue = baseDueDate.getTime() - nowMs;

    let timeDemerit = (warningWindow > 0 && timeUntilDue <= warningWindow) ? (1 - (timeUntilDue / warningWindow)) * 3.0 : 0;
    timeDemerit = Math.max(0, Math.min(timeDemerit, 3.0));

    // Adjust demerit based on progress. A task that is 50% done will have its time-based urgency penalty cut in half.
    // This makes timed and count-based tasks feel less urgent as they are worked on.
    let progressRatio = 0;
    if (task.completionType === 'time' && task.currentProgress > 0) {
      const totalDurationMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
      if (totalDurationMs > 0) {
        progressRatio = task.currentProgress / totalDurationMs;
      }
    } else if (task.completionType === 'count' && task.currentProgress > 0) {
      if (task.countTarget > 0) {
        progressRatio = task.currentProgress / task.countTarget;
      }
    }
    progressRatio = Math.max(0, Math.min(progressRatio, 1)); // Clamp between 0 and 1

    if (progressRatio > 0) {
      timeDemerit = timeDemerit * (1 - progressRatio);
    }

    let habitDemerit = (task.repetitionType !== 'none' && task.trackMisses && task.maxMisses > 0) ? (task.misses / task.maxMisses) * 2.0 : 0;
    habitDemerit = Math.max(0, Math.min(habitDemerit, 2.0));

    task.positioningGpa = 4.0 - timeDemerit - habitDemerit;
  });

  // --- Step 2.2: De-conflict the Calendar ("Scheduling Forward") ---
  const appointments = allOccurrences.filter(o => o.isAppointment);
  const flexibleTasks = allOccurrences.filter(o => !o.isAppointment);
  flexibleTasks.sort((a, b) => a.positioningGpa - b.positioningGpa);

  let busySlots = [];
  appointments.forEach(task => {
    const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
    if (!task.baseDueDate) return;
    task.scheduledStartTime = new Date(task.baseDueDate.getTime() - durationMs);
    task.scheduledEndTime = new Date(task.baseDueDate);
    busySlots.push({ start: task.scheduledStartTime.getTime(), end: task.scheduledEndTime.getTime() });
  });

  // Augment busy slots with buffers for appointments
  appointments.forEach(task => {
    if (!task.scheduledStartTime) return;

    // Note: The variable 'ruleApplies' here needs to match the specific logic:
    const effectiveRuleApplies = earlyOnTimeSettings.enabled && (!earlyOnTimeSettings.onlyAppointments || task.isAppointment);

    let currentStart = task.scheduledStartTime.getTime();

    if (effectiveRuleApplies) {
        const earlyMs = 15 * MS_PER_MINUTE;
        busySlots.push({ start: currentStart - earlyMs, end: currentStart });
        currentStart -= earlyMs;
    }

    const prepMs = getDurationMs(task.prepTimeAmount, task.prepTimeUnit);
    if (prepMs > 0) {
        busySlots.push({ start: currentStart - prepMs, end: currentStart });
    }
  });

  busySlots.sort((a, b) => a.start - b.start);

  flexibleTasks.forEach(task => {
    // Calculate total duration needed (Prep + Early + Task)
    const taskDurationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit) || 60000;

    const ruleApplies = earlyOnTimeSettings.enabled && !earlyOnTimeSettings.onlyAppointments; // Flexible tasks only get early buffer if NOT "only appointments"
    const earlyMs = ruleApplies ? 15 * MS_PER_MINUTE : 0;
    const prepMs = getDurationMs(task.prepTimeAmount, task.prepTimeUnit);

    const totalDurationMs = taskDurationMs + earlyMs + prepMs;

    if (!task.baseDueDate) {
      // Default to now, but respecting the structure [Prep][Early][Task]
      // Start time represents the start of the TASK, so we need to offset.
      // Actually, for immediate tasks, we probably just want to schedule the whole block starting now?
      // Let's stick to the pattern: scheduledStartTime is the task start.
      const nowMs = Date.now();
      task.scheduledStartTime = new Date(nowMs + prepMs + earlyMs);
      task.scheduledEndTime = new Date(task.scheduledStartTime.getTime() + taskDurationMs);
      return;
    }

    let potentialTaskEndTime = new Date(task.baseDueDate);

    let foundSlot = false;
    // We scan backwards from due date.
    // The "Block" we are trying to fit is [Prep][Early][Task].
    // potentialTaskEndTime is the end of [Task].
    // The start of the block is potentialTaskEndTime - totalDurationMs.

    for (let i = 0; i < 500 && !foundSlot; i++) {
      let blockStartMs = potentialTaskEndTime.getTime() - totalDurationMs;
      let blockEndMs = potentialTaskEndTime.getTime();

      let conflict = false;
      for (const slot of busySlots) {
        // Check if the slot overlaps with our total block
        if (blockStartMs < slot.end && blockEndMs > slot.start) {
          conflict = true;
          // If conflict, try to move the whole block to end at the start of the conflicting slot.
          // The new task end time would be the conflicting slot's start.
          // However, we need to account for the fact that the slot might be a buffer itself.
          // Simply pushing the task end to slot.start is the standard "scheduling backward" approach.
          potentialTaskEndTime = new Date(slot.start);
          break;
        }
      }

      if (!conflict) {
        // Found a spot!
        // The task starts after Prep and Early.
        task.scheduledStartTime = new Date(blockStartMs + prepMs + earlyMs);
        task.scheduledEndTime = new Date(potentialTaskEndTime);

        // Mark the whole block as busy
        busySlots.push({ start: blockStartMs, end: blockEndMs });
        busySlots.sort((a, b) => a.start - b.start);
        foundSlot = true;
      }
    }

    if (!foundSlot) { // Fallback
       // If no slot found (e.g. infinite loop protection), just place it at the due date
       // possibly overlapping.
       const blockStartMs = task.baseDueDate.getTime() - totalDurationMs;
       task.scheduledStartTime = new Date(blockStartMs + prepMs + earlyMs);
       task.scheduledEndTime = new Date(task.baseDueDate);
    }
  });

  // --- Step 2.3: Calculate Final "Coloring GPA" ---
  allOccurrences.forEach(occurrence => {
    if (!occurrence.scheduledStartTime) {
      occurrence.finalGpa = -1;
      occurrence.finalStatus = 'green';
      return;
    }

    // Determine if the "Early is on Time" rule applies to this specific occurrence
    const ruleApplies = earlyOnTimeSettings.enabled && (!earlyOnTimeSettings.onlyAppointments || occurrence.isAppointment);

    // --- GPA Calculation ---
    let gpaCalculationStartTimeMs = occurrence.scheduledStartTime.getTime();
    if (ruleApplies) {
      gpaCalculationStartTimeMs -= 15 * MS_PER_MINUTE; // Subtract 15 minutes for GPA calculation
    }

    const prepTimeMs = getDurationMs(occurrence.prepTimeAmount, occurrence.prepTimeUnit);
    const estimatedDurationMs = getDurationMs(occurrence.estimatedDurationAmount, occurrence.estimatedDurationUnit);
    const urgencySourceDuration = prepTimeMs > 0 ? prepTimeMs : estimatedDurationMs;
    const warningWindow = urgencySourceDuration * 4;
    const timeUntilDue = gpaCalculationStartTimeMs - nowMs;

    let finalTimeDemerit = (warningWindow > 0 && timeUntilDue <= warningWindow) ? (1 - (timeUntilDue / warningWindow)) * 3.0 : 0;
    finalTimeDemerit = Math.max(0, Math.min(finalTimeDemerit, 3.0));

    // Adjust demerit based on progress for timer and count tasks. This is crucial for ensuring that
    // tasks that are partially complete appear less red/urgent.
    let progressRatio = 0;
    if (occurrence.completionType === 'time' && occurrence.currentProgress > 0) {
      const totalDurationMs = getDurationMs(occurrence.timeTargetAmount, occurrence.timeTargetUnit);
      if (totalDurationMs > 0) {
        progressRatio = occurrence.currentProgress / totalDurationMs;
      }
    } else if (occurrence.completionType === 'count' && occurrence.currentProgress > 0) {
      if (occurrence.countTarget > 0) {
        progressRatio = occurrence.currentProgress / occurrence.countTarget;
      }
    }
    progressRatio = Math.max(0, Math.min(progressRatio, 1)); // Clamp between 0 and 1

    if (progressRatio > 0) {
      finalTimeDemerit = finalTimeDemerit * (1 - progressRatio);
    }

    // Standard display times match scheduled times
    occurrence.displayStartTime = occurrence.scheduledStartTime;
    occurrence.displayEndTime = occurrence.scheduledEndTime;

    let habitDemerit = (occurrence.repetitionType !== 'none' && occurrence.trackMisses && occurrence.maxMisses > 0) ? (occurrence.misses / occurrence.maxMisses) * 2.0 : 0;
    habitDemerit = Math.max(0, Math.min(habitDemerit, 2.0));

    occurrence.finalGpa = 4.0 - finalTimeDemerit - habitDemerit;

    const s = sensitivity.sValue || 0.5;
    const adjustedRedThreshold = 0.5 + (s - 0.5);
    const adjustedYellowThreshold = 1.5 + (s - 0.5);
    const adjustedGreenThreshold = 2.5 + (s - 0.5);

    if (occurrence.finalGpa < adjustedRedThreshold) occurrence.finalStatus = 'black';
    else if (occurrence.finalGpa < adjustedYellowThreshold) occurrence.finalStatus = 'red';
    else if (occurrence.finalGpa < adjustedGreenThreshold) occurrence.finalStatus = 'yellow';
    else occurrence.finalStatus = 'green';
  });

  // --- Step 2.4: Generate Buffer Occurrences ---
  const bufferOccurrences = [];
  allOccurrences.forEach(task => {
    // Only generate buffers for tasks that are scheduled and not themselves buffers
    if (!task.scheduledStartTime || task.type === 'buffer') return;

    const ruleApplies = earlyOnTimeSettings.enabled && (!earlyOnTimeSettings.onlyAppointments || task.isAppointment);
    const prepTimeMs = getDurationMs(task.prepTimeAmount, task.prepTimeUnit);

    let currentStartTime = new Date(task.scheduledStartTime);

    // 1. Early Buffer (15 mins)
    // Placed immediately before the task
    if (ruleApplies) {
      const earlyDurationMs = 15 * MS_PER_MINUTE;
      const earlyStart = new Date(currentStartTime.getTime() - earlyDurationMs);
      const earlyEnd = new Date(currentStartTime);

      bufferOccurrences.push({
        id: `${task.id}_early`, // Unique ID for buffer
        originalId: task.originalId, // Link to parent
        name: task.name, // Will be overridden by label in render
        scheduledStartTime: earlyStart,
        scheduledEndTime: earlyEnd,
        displayStartTime: earlyStart,
        displayEndTime: earlyEnd,
        occurrenceDueDate: earlyStart, // Ensure buffer has a due date reference
        type: 'buffer',
        subtype: 'early',
        categoryId: task.categoryId, // Inherit category for color
        isBusy: true,
        finalStatus: task.finalStatus // Inherit status for border color
      });

      // Shift the "cursor" back for the next buffer (Prep Time)
      currentStartTime = earlyStart;
    }

    // 2. Prep Time Buffer
    // Placed before the Early buffer (or the task if no early buffer)
    if (prepTimeMs > 0) {
      const prepStart = new Date(currentStartTime.getTime() - prepTimeMs);
      const prepEnd = new Date(currentStartTime);

      bufferOccurrences.push({
        id: `${task.id}_prep`,
        originalId: task.originalId,
        name: task.name,
        scheduledStartTime: prepStart,
        scheduledEndTime: prepEnd,
        displayStartTime: prepStart,
        displayEndTime: prepEnd,
        occurrenceDueDate: prepStart, // Ensure buffer has a due date reference
        type: 'buffer',
        subtype: 'prep',
        categoryId: task.categoryId,
        isBusy: true,
        finalStatus: task.finalStatus
      });
    }
  });

  // Add buffers to the busy slots for future scheduling steps (if we were to loop again)
  // Since we already did "Step 2.2: De-conflict", flexible tasks have already been placed.
  // Ideally, flexible tasks should respect these buffers.
  // To fix this, we should really generate buffers *before* step 2.2 if we want flexible tasks to dodge them.
  // However, buffers depend on the task's scheduled time.
  // Flexible tasks determine their own scheduled time.
  //
  // Appointments are fixed. Their buffers are fixed relative to them.
  // Flexible tasks are floating.
  //
  // If a Flexible Task A has prep time:
  // It effectively just has a longer duration.
  //
  // If an Appointment B has prep time:
  // That prep time creates a new "Busy Slot" that Flexible Task A must avoid.
  //
  // Current logic:
  // 1. Appointments placed.
  // 2. Flexible tasks placed around appointments.
  //
  // Correct logic with buffers:
  // 1. Appointments placed.
  // 2. Appointment BUFFERS generated and added to `busySlots`.
  // 3. Flexible tasks placed around (Appointments + Buffers).
  // 4. Flexible task BUFFERS generated (visual only? or do they push back?)
  //    If Flexible Task A is placed at 2:00, and has 30m prep, it effectively occupies 1:30-3:00.
  //    The `de-conflict` logic currently uses `estimatedDuration`.
  //    We should augment the `duration` used in Step 2.2 to include Prep + Early time.
  //    Then, in Step 2.4 (here), we split that block into [Prep][Early][Task].

  return [...allOccurrences, ...bufferOccurrences];
}



// --- templates.js ---
// =================================================================================
// T-1.0: UTILITY FUNCTIONS
// =================================================================================

function getAbsoluteRepetitionString(task) {
  if (!task.repetitionAbsoluteFrequency) return 'Absolute Schedule (Error)';
  const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const occurrences = { '1': 'First', '2': 'Second', '3': 'Third', '4': 'Fourth', 'last': 'Last' };
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const daySuffix = (day) => {
    if (day === 'last') return 'Last';
    if (day === 'second_last') return '2nd Last';
    if (day === 'third_last') return '3rd Last';
    const n = parseInt(day);
    if (isNaN(n)) return '?';
    if (n % 10 === 1 && n !== 11) return `${n}st`;
    if (n % 10 === 2 && n !== 12) return `${n}nd`;
    if (n % 10 === 3 && n !== 13) return `${n}rd`;
    return `${n}th`;
  };
  try {
    switch (task.repetitionAbsoluteFrequency) {
    case 'weekly':
      const selectedDaysW = (task.repetitionAbsoluteWeeklyDays || []).sort((a,b) => a-b).map(d => weekdays[d]).join(', ');
      return `Weekly on ${selectedDaysW || '...'}`;
    case 'monthly':
      if (task.repetitionAbsoluteMonthlyMode === 'day_of_week') {
        const occArr = (task.repetitionAbsoluteNthWeekdayOccurrence || []);
        const occStr = occArr.length > 0 ? occArr.map(o => occurrences[o] || '?').join(', ') : '...';
        const dayArr = (task.repetitionAbsoluteNthWeekdayDays || []);
        const dayStrM = dayArr.length > 0 ? dayArr.sort((a,b)=>a-b).map(d => weekdays[d]).join(', ') : '...';
        return `Monthly on the ${occStr} ${dayStrM}`;
      } else {
        const dayArr = (task.repetitionAbsoluteDaysOfMonth || []);
        const dayStr = dayArr.length > 0 ? dayArr.map(d => daySuffix(d)).join(', ') : '?';
        return `Monthly on day(s) ${dayStr}`;
      }
    case 'yearly':
      const monthArr = (task.repetitionAbsoluteYearlyMonths || []);
      const monthStr = monthArr.length > 0 ? monthArr.sort((a,b)=>a-b).map(m => months[m] || '?').join(', ') : '...';
      if (task.repetitionAbsoluteYearlyMode === 'day_of_week') {
        const occArr = (task.repetitionAbsoluteYearlyNthWeekdayOccurrence || []);
        const occStr = occArr.length > 0 ? occArr.map(o => occurrences[o] || '?').join(', ') : '?';
        const dayArr = (task.repetitionAbsoluteYearlyNthWeekdayDays || []);
        const dayStrY = dayArr.length > 0 ? dayArr.sort((a,b)=>a-b).map(d => weekdays[d]).join(', ') : '...';
        return `Yearly on the ${occStr} ${dayStrY} of ${monthStr}`;
      } else {
        const dayArr = (task.repetitionAbsoluteYearlyDaysOfMonth || []);
        const dayStr = dayArr.length > 0 ? dayArr.map(d => daySuffix(d)).join(', ') : '?';
        return `Yearly on ${monthStr} ${dayStr}`;
      }
    default: return `Repeats: ${task.repetitionAbsoluteFrequency}`;
    }
  } catch (e) {
    console.error('Error generating absolute repetition string:', task.id, e);
    return 'Absolute Schedule (Error)';
  }
}

function formatDateTime(date, use24HourFormat) {
  if (!date || isNaN(date)) return 'N/A';
  const dateOptions = { year: 'numeric', month: 'numeric', day: 'numeric' };
  const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: !use24HourFormat };
  return `${date.toLocaleDateString('en-US', dateOptions)} ${date.toLocaleTimeString('en-US', timeOptions)}`;
}

function formatDuration(amount, unit) {
  if (!amount || !unit || amount <= 0) return 'N/A';
  return `${amount} ${unit}`;
}

function formatMsToTime(ms) {
  if (isNaN(ms) || ms < 0) ms = 0;
  const totalSeconds = Math.floor(ms / 1000);
  const seconds = totalSeconds % 60;
  const totalMinutes = Math.floor(totalSeconds / 60);
  const minutes = totalMinutes % 60;
  const hours = Math.floor(totalMinutes / 60);
  const pad = (num) => String(num).padStart(2, '0');
  return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
}


function formatProgressNumber(num) {
  if (num === null || num === undefined) return 0;
  if (num % 1 !== 0) {
    return +num.toFixed(2);
  }
  return num;
}


// =================================================================================
// T-2.0: TASK & CATEGORY TEMPLATES
// =================================================================================

function taskTemplate(task, { categories, taskDisplaySettings, appSettings }) {
  const category = categories.find(c => c.id === task.categoryId);
  const categoryName = category ? category.name : 'Uncategorized';

  let categoryHtml = '';
  if (taskDisplaySettings.showCategory) {
    const categoryColor = category ? category.color : '#808080';
    categoryHtml = `<span class="text-xs font-medium px-2 py-1 rounded-full" style="background-color: ${categoryColor};">${categoryName}</span>`;
  }

  const dueDateStr = (task.dueDate && !isNaN(task.dueDate)) ? formatDateTime(task.dueDate, appSettings.use24HourFormat) : 'No due date';
  const dueDateHtml = taskDisplaySettings.showDueDate ? `<p class="text-sm opacity-80">Due: ${dueDateStr}</p>` : '';

  let repetitionStr = '';
  if (task.repetitionType === 'relative') {
    repetitionStr = `Repeats: Every ${task.repetitionAmount || '?'} ${task.repetitionUnit || '?'}`;
  } else if (task.repetitionType === 'absolute') {
    repetitionStr = `Repeats: ${getAbsoluteRepetitionString(task)}`;
  }
  const repetitionHtml = taskDisplaySettings.showRepetition && repetitionStr ? `<p class="text-sm opacity-70">${repetitionStr}</p>` : '';

  const durationStr = formatDuration(task.estimatedDurationAmount, task.estimatedDurationUnit);
  const durationHtml = taskDisplaySettings.showDuration ? `<p class="text-sm opacity-70">Est. Duration: ${durationStr}</p>` : '';

  const countdownHtml = taskDisplaySettings.showCountdown ? `<p id="countdown-${task.id}" class="countdown-timer"></p>` : '';

  let progressHtml = '';
  const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;
  if (taskDisplaySettings.showProgress && task.status !== 'blue' && !isCompletedNonRepeating && (task.completionType === 'count' || task.completionType === 'time')) {
    progressHtml = `<div id="progress-container-${task.id}" class="mt-1 h-5">`;
    let progressText = '';
    if (task.completionType === 'count' && task.countTarget) {
      progressText = `${formatProgressNumber(task.currentProgress) || 0} / ${task.countTarget}`;
    } else if (task.completionType === 'time' && task.timeTargetAmount) {
      const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
      progressText = `${formatMsToTime(task.currentProgress || 0)} / ${formatMsToTime(targetMs)}`;
    }
    progressHtml += `<span id="progress-${task.id}" class="progress-display">${progressText}</span>`;
    if (!task.confirmationState && task.status !== 'blue') {
      progressHtml += `<button data-action="editProgress" data-task-id="${task.id}" class="btn btn-clear text-xs" title="Edit Progress" aria-label="Edit progress for ${task.name}"><i class="fa-solid fa-pencil"></i></button>`;
    }
    progressHtml += '</div>';
  }

  const missesHtml = (task.repetitionType !== 'none' && task.maxMisses && task.trackMisses)
    ? `<p class="misses-display mt-1">Misses: ${task.misses}/${task.maxMisses}</p>`
    : '';

  const actionAreaContainer = `<div id="action-area-${task.id}" class="flex flex-col space-y-1 items-end flex-shrink-0 min-h-[50px]"></div>`;
  const commonButtonsContainer = `<div id="common-buttons-${task.id}" class="flex space-x-2 mt-2"></div>`;
  const iconToUse = task.icon || (category ? category.icon : null);
  const iconHtml = iconToUse ? `<i class="${iconToUse} mr-2"></i>` : '';

  return `<div class="flex-grow pr-4">
                <div class="task-card-header">
                    <h3 class="text-lg font-semibold">${iconHtml}${task.name || 'Unnamed Task'}</h3>
                    ${categoryHtml}
                </div>
                ${dueDateHtml}
                ${repetitionHtml}
                ${durationHtml}
                ${countdownHtml}
                ${progressHtml}
            </div>
            <div class="flex flex-col space-y-1 items-end flex-shrink-0">
                ${actionAreaContainer}
                ${missesHtml}
                ${commonButtonsContainer}
            </div>`;
}

function categoryManagerTemplate(categories) {
  let content = '';
  if (categories.length === 0) {
    content += '<p class="italic">No categories created yet.</p>';
  } else {
    content += categories.map(cat => `
            <div class="p-2 border-b" id="category-item-${cat.id}">
                <div class="flex items-center justify-between">
                    <div id="category-display-${cat.id}" class="flex-grow flex items-center" data-action="triggerCategoryEdit" data-category-id="${cat.id}">
                        <span class="font-medium cursor-pointer">${cat.icon ? `<i class="${cat.icon} mr-2"></i>` : ''}${cat.name}</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button data-action="openIconPicker" data-context="category" data-category-id="${cat.id}" class="btn btn-clear text-xs">Set Icon</button>
                        <input type="color" value="${cat.color}" data-category-id="${cat.id}" class="category-color-picker h-8 w-12 border-none cursor-pointer rounded">
                        <button data-action="deleteCategory" data-category-id="${cat.id}" class="btn btn-clear font-bold text-lg" aria-label="Delete category ${cat.name}">&times;</button>
                    </div>
                </div>
                <div class="mt-2 flex justify-between items-center">
                    <label class="text-xs flex items-center" title="If checked, new tasks created with this category will automatically use this icon.">
                        <input type="checkbox" data-action="toggleApplyIcon" data-category-id="${cat.id}" class="mr-2" ${cat.applyIconToNewTasks ? 'checked' : ''}>
                        Auto-apply icon
                    </label>
                    <div class="flex justify-end space-x-2">
                        <button data-action="bulkEdit" data-category-id="${cat.id}" class="btn btn-clear text-xs">Bulk Edit</button>
                        <button data-action="deleteCategoryTasks" data-category-id="${cat.id}" class="btn btn-clear text-xs">Delete All Tasks</button>
                    </div>
                </div>
                <div id="bulk-edit-container-${cat.id}" class="hidden mt-2"></div>
            </div>
        `).join('');
  }

  content += `
        <div class="mt-4">
            <button class="btn btn-secondary btn-md w-full" data-action="renderCategoryAdd">
                Add New Category
            </button>
            <div id="add-category-form-container" class="mt-2"></div>
        </div>
    `;

  return content;
}

function taskViewTemplate(task, { categories, appSettings, isHistorical }) {
  const category = categories.find(c => c.id === task.categoryId);
  const categoryName = category ? category.name : 'Uncategorized';
  const dueDate = isHistorical ? new Date(task.completionDate) : (task.dueDate ? new Date(task.dueDate) : null);
  const dueDateStr = (dueDate && !isNaN(dueDate)) ? formatDateTime(dueDate, appSettings.use24HourFormat) : 'No due date';
  const durationStr = formatDuration(task.durationAmount || task.estimatedDurationAmount, task.durationUnit || task.estimatedDurationUnit);

  let repetitionStr = 'Non-Repeating';
  if (!isHistorical && task.repetitionType) {
    if (task.repetitionType === 'relative') {
      repetitionStr = `Every ${task.repetitionAmount || '?'} ${task.repetitionUnit || '?'}`;
    } else if (task.repetitionType === 'absolute') {
      repetitionStr = getAbsoluteRepetitionString(task);
    }
  }

  let actionsHtml;
  let progressHtml = '';
  let missesHtml = '';

  if (isHistorical) {
    actionsHtml = `
            <div id="task-view-actions-${task.originalTaskId}" class="mt-6 responsive-button-grid">
                <button data-action="triggerDeleteHistoryRecordFromView" data-history-event-id="${task.id}" data-task-id="${task.originalTaskId}" class="btn btn-deny btn-sm" title="Delete this specific history record"><i class="fa-solid fa-trash"></i> Delete Record</button>
                <button data-action="viewTaskStats" data-task-id="${task.originalTaskId || task.id}" class="btn btn-clear" title="View aggregate stats for this task"><i class="fa-solid fa-chart-line"></i> View Stats</button>
            </div>
            <div id="task-view-confirmation-${task.id}" class="mt-4"></div>
        `;
  } else {
    // Replicate the structure from the main task list for consistency
    const actionAreaContent = actionAreaTemplate(task);
    const modalButtonOptions = { editAction: 'editTaskFromView', deleteAction: 'triggerDeleteFromView' };
    const commonButtonsContent = commonButtonsTemplate(task, modalButtonOptions);

    if (task.status !== 'blue' && (task.completionType === 'count' || task.completionType === 'time')) {
      progressHtml = `<div id="progress-container-${task.id}" class="mt-2 text-sm">`;
      let progressText = '';
      if (task.completionType === 'count' && task.countTarget) {
        progressText = `${task.currentProgress || 0} / ${task.countTarget}`;
      } else if (task.completionType === 'time' && task.timeTargetAmount) {
        const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
        progressText = `${formatMsToTime(task.currentProgress || 0)} / ${formatMsToTime(targetMs)}`;
      }
      progressHtml += `<span class="font-semibold">Progress:</span> <span id="progress-${task.id}">${progressText}</span>`;
      if (!task.confirmationState) {
        progressHtml += `<button data-action="editProgress" data-task-id="${task.id}" class="btn btn-clear text-xs ml-2" title="Edit progress"><i class="fa-solid fa-pencil"></i></button>`;
      }
      progressHtml += '</div>';
    }

    if (task.repetitionType !== 'none' && task.maxMisses && task.trackMisses) {
      missesHtml = `<p class="text-sm">Misses: ${task.misses}/${task.maxMisses}</p>`;
    }

    actionsHtml = `
            <div class="mt-6 flex flex-col items-end">
                <div id="task-view-action-area-${task.id}" class="w-full flex justify-end">
                    ${actionAreaContent}
                </div>
                <div id="task-view-confirmation-${task.id}" class="mt-4 w-full"></div>
                <div class="flex justify-between w-full items-center mt-4">
                    <div>${missesHtml}</div>
                    <div class="flex items-center space-x-2">
                         <button data-action="viewTaskStats" data-task-id="${task.id}" class="btn btn-clear" title="View task statistics"><i class="fa-solid fa-chart-line"></i></button>
                        ${commonButtonsTemplate(task, { editAction: 'editTaskFromView', deleteAction: 'triggerDeleteFromView' })}
                    </div>
                </div>
            </div>
        `;
  }
  const descriptionHtml = task.description ? `
    <div class="mt-4">
        <h4 class="font-bold">Description</h4>
        <p class="text-sm whitespace-pre-wrap">${task.description}</p>
    </div>
` : '';

  const thoughtsHtml = `
<div id="task-thoughts-section-${task.id}" class="mt-4">
    <div class="flex justify-between items-center">
        <h4 class="font-bold">Thoughts</h4>
        ${isHistorical ? `
            <div class="flex space-x-2">
                 <button data-action="editHistoryIcon" data-history-event-id="${task.id}" data-task-id="${task.originalTaskId}" class="btn btn-clear text-xs" title="Change icon for this history entry"><i class="fa-solid fa-image"></i></button>
                 <button data-action="editHistoryThoughts" data-history-event-id="${task.id}" class="btn btn-clear text-xs" title="Edit thoughts for this history entry"><i class="fa-solid fa-pencil"></i></button>
            </div>
        ` : ''}
    </div>
    <div id="task-thoughts-content-${task.id}"
         class="prose prose-sm min-h-[80px] p-2 rounded-md focus:outline-none focus:ring-2 whitespace-pre-wrap"
         ${!isHistorical ? 'contenteditable="true"' : ''}>
        ${task.thoughts || (isHistorical ? '<p class="text-sm italic">No thoughts for this instance.</p>' : '')}
    </div>
</div>
`;

  return `
        <h3 class="text-2xl font-bold mb-4">${task.icon ? `<i class="${task.icon} mr-2"></i>` : ''}${task.name}</h3>
        <div class="space-y-3">
            <p><strong>Status:</strong> <span class="font-semibold">${task.status.charAt(0).toUpperCase() + task.status.slice(1)}</span></p>
            <p><strong>Category:</strong> ${categoryName}</p>
            <p><strong>Due Date:</strong> ${dueDateStr}</p>
            <p><strong>Estimated Duration:</strong> ${durationStr}</p>
            ${!isHistorical ? `<p><strong>Repetition:</strong> ${repetitionStr}</p>` : '<p><strong>Repetition:</strong> N/A (Historical Record)</p>'}
        </div>
        ${descriptionHtml}
        ${thoughtsHtml}
        <div id="task-view-actions-${task.id}" class="mt-6 responsive-button-grid">
            ${actionsHtml}
        </div>
        <div id="task-view-confirmation-${task.id}" class="mt-4"></div>
    `;
}

function historyDeleteConfirmationTemplate(historyId, taskId) {
  return `
        <div class="history-delete-confirmation flex justify-end items-center space-x-2 w-full">
            <span class="text-sm font-semibold">Delete?</span>
            <button data-action="confirmHistoryDelete" data-history-id="${historyId}" data-task-id="${taskId}" data-delete-type="single" class="btn btn-deny btn-xs">This Entry</button>
            <button data-action="confirmHistoryDelete" data-task-id="${taskId}" data-delete-type="all" class="btn btn-deny btn-xs">All History for Task</button>
            <button data-action="cancelHistoryDelete" data-history-id="${historyId}" data-task-id="${taskId}" class="btn btn-clear text-xs">Cancel</button>
        </div>
    `;
}

function confirmCategoryIconApplyTemplate(categoryId, iconClass) {
  return `
        <div id="confirm-category-icon-modal" class="modal active">
            <div class="modal-content bg-modal">
                <h3 class="text-xl font-semibold mb-4">Apply Category Icon</h3>
                <p class="mb-4 text-sm">You've selected the icon <i class="${iconClass}"></i>. How would you like to apply it?</p>
                <div class="flex flex-col space-y-2">
                    <button data-action="apply-icon-to-all" data-category-id="${categoryId}" data-icon="${iconClass}" class="btn btn-primary">Apply to All Existing & Future Tasks</button>
                    <button data-action="apply-icon-to-future" data-category-id="${categoryId}" data-icon="${iconClass}" class="btn btn-secondary">Apply Only to Future Tasks</button>
                    <button data-action="cancel-apply-icon" class="btn btn-tertiary mt-4">Cancel</button>
                </div>
            </div>
        </div>
    `;
}

function confirmOverrideModalTemplate(occurrenceId) {
  return `
        <div class="modal active" id="confirm-override-modal">
            <div class="modal-content">
                <h2 class="text-xl font-bold mb-4">Apply Changes</h2>
                <p class="mb-6">Do you want to apply this change to just this specific occurrence or to this and all future occurrences of the task?</p>
                <div class="flex justify-end space-x-4">
                    <button data-action="cancel-override" class="btn btn-secondary">Cancel</button>
                    <button data-action="apply-override" data-scope="single" data-occurrence-id="${occurrenceId}" class="btn btn-primary">Just This One</button>
                    <button data-action="apply-override" data-scope="future" data-occurrence-id="${occurrenceId}" class="btn btn-primary">This and All Future</button>
                </div>
            </div>
        </div>
    `;
}

function vacationChangeConfirmationModalTemplate(changedTasks) {
  const taskListHtml = changedTasks.map(t => `
        <li class="text-sm p-1 rounded">
            <strong>${t.name}</strong>: <span class="line-through">${new Date(t.oldDueDate).toLocaleString()}</span> -> <span class="font-semibold">${new Date(t.newDueDate).toLocaleString()}</span>
        </li>
    `).join('');

  return `
        <div id="vacation-change-confirm-modal" class="modal">
            <div class="modal-content bg-modal">
                 <button class="close-button" id="vacation-change-close-btn">&times;</button>
                <h3 class="text-xl font-semibold mb-4">Confirm Schedule Changes</h3>
                <p class="mb-4 text-sm">The recent change to vacations or categories will affect the following tasks. Please review the changes and confirm.</p>
                <div class="max-h-60 overflow-y-auto border rounded p-2 mb-4">
                    <ul class="space-y-2">
                        ${taskListHtml || '<li class="text-sm italic">No tasks were affected by this change.</li>'}
                    </ul>
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancel-vacation-change-btn" class="btn btn-tertiary btn-md">Cancel</button>
                    <button id="confirm-vacation-change-btn" class="btn btn-secondary btn-md">Confirm Changes</button>
                </div>
            </div>
        </div>
    `;
}

const appointmentConflictModalTemplate = (conflictedTasks) => `
<div class="modal-content bg-modal">
    <button id="appointment-conflict-close-btn" class="close-button" aria-label="Close">&times;</button>
    <h2 class="text-2xl font-semibold mb-4">Appointment Conflict</h2>
    <p class="mb-4">The following appointments are scheduled during a vacation period. How would you like to proceed?</p>
    <div class="space-y-2 mb-6 max-h-60 overflow-y-auto p-2 rounded">
        ${conflictedTasks.map(task => `
            <div class="p-2 rounded-md">
                <p class="font-semibold">${task.name}</p>
                <p class="text-sm">Current Date: ${new Date(task.dueDate).toLocaleString()}</p>
            </div>
        `).join('')}
    </div>
    <div class="flex justify-end space-x-4">
        <button id="keep-appointments-btn" class="btn btn-secondary btn-md">Keep As Is</button>
        <button id="reschedule-appointments-btn" class="btn btn-primary btn-md">Reschedule Automatically</button>
    </div>
</div>
`;

function vacationManagerTemplate(vacations, categories) {
  const vacationListHtml = vacations.length > 0 ? vacations.map(v => `
        <div class="flex items-center justify-between p-2 border-b">
            <div>
                <p class="font-medium">${v.name}</p>
                <p class="text-xs">
                    ${new Date(v.startDate).toLocaleDateString()} - ${new Date(v.endDate).toLocaleDateString()}
                </p>
            </div>
            <button data-action="deleteVacation" data-id="${v.id}" class="btn btn-clear font-bold text-lg">&times;</button>
        </div>
    `).join('') : '<p class="text-sm italic">No vacations scheduled.</p>';

  const categoryBypassHtml = categories.map(cat => `
        <label class="flex items-center space-x-2">
            <input type="checkbox" data-action="toggleVacationBypass" data-category-id="${cat.id}" class="category-vacation-bypass-checkbox" ${cat.bypassVacation ? 'checked' : ''}>
            <span>${cat.name}</span>
        </label>
    `).join('');

  return `
        <div>
            <h4 class="font-semibold mb-2">Scheduled Vacations</h4>
            <div id="vacation-list" class="space-y-2 mb-4">${vacationListHtml}</div>
            <form id="add-vacation-form" class="space-y-3 p-3 border rounded-md">
                <input type="text" id="vacation-name" placeholder="Vacation Name" required>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label for="vacation-start-date" class="text-sm">Start Date</label>
                        <input type="date" id="vacation-start-date" required>
                    </div>
                    <div>
                        <label for="vacation-end-date" class="text-sm">End Date</label>
                        <input type="date" id="vacation-end-date" required>
                    </div>
                </div>
                <button type="submit" class="btn btn-secondary btn-md w-full">Add Vacation</button>
            </form>
        </div>
        <div class="mt-4">
             <h4 class="font-semibold mb-2">Category Vacation Bypass</h4>
             <p class="text-xs italic mb-2">Tasks in checked categories will NOT be pushed by vacations.</p>
             <div id="category-bypass-list" class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                ${categoryBypassHtml}
             </div>
        </div>
    `;
}

function taskViewDeleteConfirmationTemplate(taskId) {
  return `
        <div class="p-3 rounded-lg border-2 border-dashed">
            <p class="text-center font-semibold">Are you sure?</p>
            <div class="flex justify-center space-x-4 mt-3">
                <button data-action="confirmDeleteFromView" data-task-id="${taskId}" class="btn btn-deny btn-sm">Yes, Delete</button>
                <button data-action="cancelDeleteFromView" data-task-id="${taskId}" class="btn btn-clear">No, Cancel</button>
            </div>
        </div>
    `;
}

function taskViewHistoryDeleteConfirmationTemplate(historyEventId, originalTaskId) {
  return `
        <div class="p-3 rounded-lg border-2 border-dashed">
            <p class="text-center font-semibold">Delete this record?</p>
            <div class="flex justify-center space-x-4 mt-3">
                <button data-action="confirmDeleteHistoryRecordFromView" data-history-event-id="${historyEventId}" data-task-id="${originalTaskId}" class="btn btn-deny btn-sm">Yes, Delete</button>
                <button data-action="cancelDeleteHistoryRecordFromView" class="btn btn-clear">No, Cancel</button>
            </div>
        </div>
    `;
}

function dataMigrationModalTemplate() {
  return `
    <div class="modal-content bg-modal">
        <h3 class="text-xl font-semibold mb-4">Data Migration & Integrity Tool</h3>
        <button class="close-button">&times;</button>

        <div id="goal-timezone-fix-section" data-section="goal-fix" class="hidden mb-4 p-3 border rounded">
            <h4 class="font-semibold">Weekly Goal Timezone Correction</h4>
            <p id="goal-fix-summary" class="text-sm my-2"></p>
            <p class="text-xs mb-3">The following weekly goals appear to have an incorrect timezone offset and will be shifted to the start of the week in your local time.</p>
            <div id="goal-fix-list-container" class="max-h-60 overflow-y-auto border rounded p-2 space-y-2"></div>
            <div class="mt-3 flex justify-end">
                <button id="fix-goals-btn" data-action="fixTimezoneGoals" class="btn btn-confirm btn-sm">Fix All Goals</button>
            </div>
        </div>

        <div id="orphan-cleanup-section" data-section="orphan-cleanup" class="hidden mb-4 p-3 border rounded">
            <h4 class="font-semibold">Orphaned History Cleanup</h4>
            <p id="orphan-summary" class="text-sm my-2"></p>
            <p class="text-xs mb-3">The following records belong to deleted tasks.</p>
            <div id="orphan-list-container" class="max-h-60 overflow-y-auto border rounded p-2 space-y-2"></div>
            <div class="mt-3 flex justify-between items-center">
                <label class="text-xs flex items-center"><input type="checkbox" id="select-all-orphans-checkbox" class="mr-2">Select All</label>
                <button id="delete-selected-orphans-btn" data-action="deleteSelectedOrphans" class="btn btn-deny btn-sm">Delete Selected</button>
            </div>
        </div>
        <div class="mt-6 pt-4 border-t" data-section="danger-zone">
            <h4 class="font-semibold">Danger Zone</h4>
            <p class="text-sm my-2">This action is permanent and cannot be undone.</p>
            <button id="delete-all-history-btn" data-action="deleteAllHistory" class="btn btn-deny btn-md w-full">Delete All Task History</button>
        </div>
    </div>
    `;
}

function journalSettingsTemplate(settings) {
  return `
        <div>
            <label for="weekly-goal-icon-input" class="form-label">Weekly Goal Icon:</label>
            <div class="flex items-center space-x-2">
                <input type="text" id="weekly-goal-icon-input" value="${settings.weeklyGoalIcon}" class="flex-grow">
                <button type="button" id="open-weekly-goal-icon-picker" data-action="openIconPicker" data-context="journalGoal" class="btn btn-clear">Choose</button>
            </div>
        </div>
    `;
}

function bulkEditFormTemplate(categoryId, settings) {
  const { durationAmount = '', durationUnit = 'minutes', completionType = '' } = settings;
  return `
        <div class="p-4 rounded-md bg-secondary">
            <h4 class="font-bold mb-3">Bulk Edit Tasks</h4>
            <form id="bulk-edit-form-${categoryId}" class="space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="form-label">Set Duration:</label>
                        <div class="flex space-x-2 items-center">
                            <input type="number" name="durationAmount" value="${durationAmount}" min="1" class="duration-input">
                            <select name="durationUnit" class="flex-grow">
                                <option value="minutes" ${durationUnit === 'minutes' ? 'selected' : ''}>Minute(s)</option>
                                <option value="hours" ${durationUnit === 'hours' ? 'selected' : ''}>Hour(s)</option>
                            </select>
                        </div>
                    </div>
                    <div>
                        <label class="form-label">Set Completion Type:</label>
                        <select name="completionType">
                            <option value="">-- No Change --</option>
                            <option value="simple" ${completionType === 'simple' ? 'selected' : ''}>Simple</option>
                            <option value="count" ${completionType === 'count' ? 'selected' : ''}>Count</option>
                            <option value="time" ${completionType === 'time' ? 'selected' : ''}>Time</option>
                        </select>
                    </div>
                </div>
                <div class="flex justify-end items-center space-x-3 pt-4 border-t">
                    <button type="button" data-action="deleteAllInCategory" data-category-id="${categoryId}" class="btn btn-deny btn-sm">Delete All In Category</button>
                    <button type="submit" class="btn btn-confirm btn-md">Apply Changes</button>
                </div>
            </form>
        </div>
    `;
}

function taskStatsTemplate(task, stats, historyHtml, hasChartData, isFullyCompleted) {
  const chartHtml = hasChartData ? '<div class="mt-4 gradient-bordered-content"><canvas id="task-history-chart"></canvas></div>' : '<p class="italic mt-4">Not enough history for a chart.</p>';
  const reinstateButtonHtml = isFullyCompleted
    ? `<button data-action="reinstateTask" data-task-id="${task.id}" class="btn btn-secondary btn-md">Reinstate Task</button>`
    : '';

  const overallGpaHtml = stats.overallGpa
    ? `<span class="font-bold inline-block text-center w-10 rounded py-1 ml-2"
                 style="background-color: ${stats.overallGpa.color}; color: ${stats.overallGpa.textColor}; text-shadow: ${stats.overallGpa.textShadow};">
              ${stats.overallGpa.grade}
           </span>`
    : '';

  return `
        <div class="flex justify-between items-start">
            <div>
                <h3 class="text-xl font-semibold mb-4">Stats for: ${task.name}</h3>
                <div class="space-y-2">
                    <div class="flex items-center">
                        <strong>Completion Rate:</strong>
                        <span class="ml-2">${stats.completionRate}% (${stats.completions} / ${stats.total})</span>
                        ${overallGpaHtml}
                    </div>
                </div>
            </div>
            <div class="relative">
                <button data-action="openHistoryMenu" data-task-id="${task.id}" class="btn btn-clear text-xl p-2" title="Edit Task History">
                    <i class="fa-solid fa-pen-to-square"></i>
                </button>
                <div id="history-menu-${task.id}" class="absolute right-0 mt-2 w-48 bg-secondary rounded-md shadow-lg z-10 hidden">
                    <!-- Menu content will be injected here -->
                </div>
            </div>
        </div>

        <h4 class="text-lg font-semibold mt-6 mb-2">Performance</h4>
        ${chartHtml}
        <h4 class="text-lg font-semibold mt-6 mb-2">Detailed History</h4>
        <div id="detailed-history-list" class="space-y-2 max-h-48 overflow-y-auto border rounded p-2">${historyHtml}</div>
        <div id="history-delete-confirmation-container" class="mt-4"></div>
        <div class="flex justify-start items-center space-x-4 mt-6">
             <button data-action="backToTaskView" class="btn btn-clear">Back to Details</button>
             ${reinstateButtonHtml}
        </div>
    `;
}

function editHistoryMenuTemplate(taskId) {
  return `
        <div class="p-2">
            <h4 class="font-bold text-sm px-2 pb-1 border-b">Edit Task History</h4>
            <button data-action="bulkUpdateIcon" data-task-id="${taskId}" class="w-full text-left p-2 text-sm hover:bg-main rounded">Set Icon for All History</button>
            <button data-action="triggerDeleteAllHistory" data-task-id="${taskId}" class="w-full text-left p-2 text-sm hover:bg-main rounded">Delete All History</button>
        </div>
    `;
}

function deleteAllHistoryConfirmationTemplate(taskId) {
  return `
        <div class="p-3 rounded-lg border-2 border-dashed flex justify-center items-center space-x-4">
            <p class="text-center font-semibold">Delete all history for this task?</p>
            <button data-action="confirmDeleteAllHistory" data-task-id="${taskId}" class="btn btn-deny btn-sm">Yes, Delete All</button>
            <button data-action="cancelDeleteAllHistory" data-task-id="${taskId}" class="btn btn-clear">Cancel</button>
        </div>
    `;
}


// Renders the primary action area for a task, which changes based on the task's state.
// This includes completion buttons, timers, count controls, and confirmation dialogs.
// Uses Font Awesome icons for actions like increment, decrement, and bypass.
function actionAreaTemplate(task) {
  const cycles = task.pendingCycles || 1;
  const hasProgress = (task.completionType === 'count' || task.completionType === 'time') && task.currentProgress > 0;

  switch (task.confirmationState) {
  case 'confirming_complete':
    let isFull = true;
    if (task.completionType === 'count' && task.countTarget) {
      if ((task.currentProgress || 0) < task.countTarget) isFull = false;
    } else if (task.completionType === 'time' && task.timeTargetAmount) {
      const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
      if ((task.currentProgress || 0) < targetMs) isFull = false;
    }

    const text = (isFull || !hasProgress)
      ? (cycles > 1 ? `Confirm Completion (${cycles} cycles)?` : 'Confirm Completion?')
      : 'Confirm Partial Completion?';
    return `<div class="flex items-center space-x-1"><span class="action-area-text">${text}</span> <button data-action="confirmCompletion" data-task-id="${task.id}" data-confirmed="true" class="btn btn-confirm btn-sm">Yes</button> <button data-action="confirmCompletion" data-task-id="${task.id}" data-confirmed="false" class="btn btn-deny btn-sm">No</button></div>`;
  case 'awaiting_overdue_input':
    let buttons = `<button data-action="handleOverdue" data-task-id="${task.id}" data-choice="completed" class="btn btn-confirm btn-sm">Done</button> <button data-action="handleOverdue" data-task-id="${task.id}" data-choice="missed" class="btn btn-deny btn-sm">Missed</button>`;
    if (hasProgress) {
      buttons += ` <button data-action="handleOverdue" data-task-id="${task.id}" data-choice="partial" class="btn btn-secondary btn-sm">Partial</button>`;
    }
    return `<div class="flex items-center space-x-1"><span class="action-area-text">Past Due:</span> ${buttons}</div>`;
  case 'confirming_miss':
    if (hasProgress) {
      return `<div class="flex items-center space-x-1"><span class="action-area-text">Confirm Partial Miss?</span> <button data-action="confirmMiss" data-task-id="${task.id}" data-confirmed="true" class="btn btn-confirm btn-sm">Yes</button> <button data-action="confirmMiss" data-task-id="${task.id}" data-confirmed="false" class="btn btn-deny btn-sm">No</button></div>`;
    }
    const promptText = cycles > 1 ? 'Confirm Misses:' : 'Confirm Miss?';
    const inputControl = cycles > 1 ? `<input type="number" id="miss-count-input-${task.id}" value="${cycles}" min="0" max="${cycles}" class="miss-input"> of ${cycles}` : '';
    return `<div class="confirm-miss-area">
                        <span class="action-area-text">${promptText} ${inputControl}</span>
                        <div class="button-group">
                            <button data-action="confirmMiss" data-task-id="${task.id}" data-confirmed="true" class="btn btn-confirm btn-xs">Yes</button>
                            <button data-action="confirmMiss" data-task-id="${task.id}" data-confirmed="false" class="btn btn-deny btn-xs">No</button>
                        </div>
                    </div>`;
  case 'confirming_delete':
    return `<div class="flex items-center space-x-1"><span class="action-area-text">Delete Task?</span> <button data-action="confirmDelete" data-task-id="${task.id}" data-confirmed="true" class="btn btn-confirm btn-sm">Yes</button> <button data-action="confirmDelete" data-task-id="${task.id}" data-confirmed="false" class="btn btn-deny btn-sm">Cancel</button></div>`;
  case 'confirming_undo':
    return `<div class="flex items-center space-x-1"><span class="action-area-text">Undo Completion?</span> <button data-action="confirmUndo" data-task-id="${task.id}" data-confirmed="true" class="btn btn-confirm btn-sm">Yes</button> <button data-action="confirmUndo" data-task-id="${task.id}" data-confirmed="false" class="btn btn-deny btn-sm">Cancel</button></div>`;
  }

  if (task.status === 'blue') return `<button data-action="triggerUndo" data-task-id="${task.id}" class="btn btn-clear" title="Undo Completion">Undo</button>`;
  if (task.repetitionType === 'none' && task.completed) return '<span class="text-xs italic">Done</span>';


  switch (task.completionType) {
  case 'count':
    return `<div class="flex items-center space-x-1">
                        <button data-action="decrementCount" data-task-id="${task.id}" class="btn btn-clear w-8 h-8 flex items-center justify-center" title="Decrement count"><i class="fa-solid fa-minus"></i></button>
                        <button data-action="incrementCount" data-task-id="${task.id}" class="btn btn-clear w-8 h-8 flex items-center justify-center" title="Increment count"><i class="fa-solid fa-plus"></i></button>
                        <button data-action="bypass" data-task-id="${task.id}" class="btn btn-confirm btn-xs" title="Mark as fully complete"><i class="fa-solid fa-check"></i></button>
                    </div>`;
  case 'time':
    const btnText = task.isTimerRunning ? 'Pause' : (task.currentProgress > 0 ? 'Resume' : 'Start');
    const timerIcon = task.isTimerRunning ? 'fa-pause' : 'fa-play';
    return `<div class="flex items-center space-x-2">
                        <button data-action="toggleTimer" data-task-id="${task.id}" id="timer-btn-${task.id}" class="btn btn-clear" title="${btnText} timer"><i class="fa-solid ${timerIcon} mr-1"></i>${btnText}</button>
                        <button data-action="bypass" data-task-id="${task.id}" class="btn btn-confirm btn-xs" title="Mark as fully complete"><i class="fa-solid fa-check"></i></button>
                    </div>`;
  default:
    return `<button data-action="triggerCompletion" data-task-id="${task.id}" class="btn btn-confirm btn-sm">Complete</button>`;
  }
}

// Renders the common secondary buttons for a task (Edit, Delete).
// Uses Font Awesome icons for a clean and consistent UI.
function commonButtonsTemplate(task, options = {}) {
  const { editAction = 'edit', deleteAction = 'triggerDelete' } = options;
  if (task.confirmationState) return '';
  const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;
  if (isCompletedNonRepeating) {
    return `<button data-action="${deleteAction}" data-task-id="${task.id}" class="btn btn-clear" title="Delete Task"><i class="fa-solid fa-trash"></i></button>`;
  }
  return `<div class="flex space-x-1">
            <button data-action="${editAction}" data-task-id="${task.id}" class="btn btn-clear" title="Edit Task"><i class="fa-solid fa-pencil"></i></button>
            <button data-action="${deleteAction}" data-task-id="${task.id}" class="btn btn-clear" title="Delete Task"><i class="fa-solid fa-trash"></i></button>
        </div>`;
}

function statusManagerTemplate(statusNames, statusColors, defaultStatusNames, theming) {
  const isThemeEnabled = theming.enabled;
  const isUsingThemeForStatus = theming.useThemeForStatus;

  const statusOrder = ['blue', 'green', 'yellow', 'red', 'black'];

  const statusRows = statusOrder.map(key => `
        <div id="status-display-${key}" class="flex items-center justify-between py-2">
            <span class="font-semibold">${statusNames[key]}</span>
            <div class="flex items-center space-x-3">
                <input type="color"
                       class="status-color-picker p-1 h-10 w-14 block bg-white border border-gray-200 cursor-pointer rounded-lg disabled:opacity-50 disabled:pointer-events-none"
                       value="${statusColors[key]}"
                       data-status-key="${key}"
                       ${isThemeEnabled && isUsingThemeForStatus ? 'disabled' : ''}>
                <span class="text-xs text-gray-400">${isThemeEnabled && isUsingThemeForStatus ? '(From Theme)' : ''}</span>
                <button data-action="triggerStatusNameEdit" data-status-key="${key}" class="btn btn-clear" title="Rename ${statusNames[key]}">
                    <i class="fa-solid fa-pen-to-square"></i>
                </button>
            </div>
        </div>
    `).join('');

  return `
        <div class="space-y-4">
            <p class="text-sm text-gray-400">Customize the names and colors for task statuses. These colors are used in the task list. When theming is on, you can choose to derive status colors from the theme.</p>

             <div class="flex items-center justify-between py-2 border-y border-gray-700">
                <label for="theme-for-status-toggle" class="font-semibold">Use Theme Gradient for Statuses</label>
                <div class="flex items-center">
                    <span class="text-xs mr-2 ${!isThemeEnabled ? 'text-gray-500' : ''}">${isThemeEnabled ? (isUsingThemeForStatus ? 'On' : 'Off') : 'Theme Disabled'}</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="theme-for-status-toggle" class="sr-only peer" data-action="toggleThemeForStatus" ${isUsingThemeForStatus ? 'checked' : ''} ${!isThemeEnabled ? 'disabled' : ''}>
                        <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
            </div>

            ${statusRows}
            <div class="pt-4 border-t border-gray-700">
                <button data-action="restoreDefaults" class="btn btn-tertiary w-full">Restore Status Colors & Names to Default</button>
            </div>
        </div>
    `;
}

function categoryFilterTemplate(categories, categoryFilter) {
  if (categories.length === 0) return '<p class="italic">No categories to filter.</p>';
  const allLabel = `<label><input type="checkbox" class="category-filter-checkbox" value="all" ${categoryFilter.length === 0 ? 'checked' : ''}> Show All</label>`;
  const uncategorizedLabel = `<label><input type="checkbox" class="category-filter-checkbox" value="null" ${categoryFilter.includes(null) ? 'checked' : ''}> Uncategorized</label>`;
  const categoryLabels = categories.map(cat => `<label><input type="checkbox" class="category-filter-checkbox" value="${cat.id}" ${categoryFilter.includes(cat.id) ? 'checked' : ''}> ${cat.name}</label>`).join('');
  return allLabel + uncategorizedLabel + categoryLabels;
}

function iconPickerTemplate(iconCategories) {
  const categoriesHtml = Object.entries(iconCategories).map(([category, icons]) => `
        <div class="icon-picker-category">
            <div class="icon-picker-category-header p-2 font-bold rounded cursor-pointer flex justify-between items-center">
                ${category} <span class="transform transition-transform duration-200"></span>
            </div>
            <div class="icon-grid hidden p-2 grid grid-cols-6 sm:grid-cols-8 md:grid-cols-10 gap-2">
                ${icons.map(iconClass => {
    const isBrand = iconClass.startsWith('fa-brands');
    const finalIconClass = isBrand ? iconClass : `fa-solid ${iconClass}`;
    return `<div class="p-2 flex justify-center items-center rounded-md hover:bg-gray-300 cursor-pointer" data-icon="${finalIconClass}"><i class="${finalIconClass} fa-2x"></i></div>`;
  }).join('')}
            </div>
        </div>
    `).join('');

  return `<div id="icon-picker-list-container">${categoriesHtml}</div>`;
}

function editProgressTemplate(taskId, currentValue, max) {
  return `<input type="number" id="edit-progress-input-${taskId}" value="${currentValue}" min="0" ${max !== Infinity ? `max="${max}"` : ''} class="progress-input">
            <button data-action="saveProgress" data-task-id="${taskId}" class="btn btn-confirm btn-xs ml-1" title="Save progress"><i class="fa-solid fa-check"></i></button>
            <button data-action="cancelProgress" data-task-id="${taskId}" class="btn btn-clear text-xs ml-1" title="Cancel edit"><i class="fa-solid fa-xmark"></i></button>`;
}

function editCategoryTemplate(categoryId, currentName) {
  return `<input type="text" id="edit-category-input-${categoryId}" value="${currentName}" class="progress-input flex-grow">
            <button data-action="saveCategoryEdit" data-category-id="${categoryId}" class="btn btn-confirm btn-xs ml-1">Save</button>
            <button data-action="cancelCategoryEdit" data-category-id="${categoryId}" class="btn btn-clear text-xs ml-1">Cancel</button>`;
}

function editStatusNameTemplate(statusKey, currentName) {
  return `<input type="text" id="edit-status-input-${statusKey}" value="${currentName}" class="progress-input flex-grow">
            <button data-action="saveStatusNameEdit" data-status-key="${statusKey}" class="btn btn-confirm btn-xs ml-1">Save</button>
            <button data-action="cancelStatusNameEdit" data-status-key="${statusKey}" class="btn btn-clear text-xs ml-1">Cancel</button>`;
}

function restoreDefaultsConfirmationTemplate() {
  return `<div class="flex flex-col items-center gap-2 text-center">
                <p class="text-sm">Reset all view and theme settings to their original defaults?</p>
                <div class="flex gap-2 mt-2">
                    <button data-action="confirmRestoreDefaults" data-confirmed="true" class="btn btn-deny btn-md">Yes, Reset</button>
                    <button data-action="confirmRestoreDefaults" data-confirmed="false" class="btn btn-secondary btn-md">No, Cancel</button>
                </div>
            </div>`;
}

function taskGroupHeaderTemplate(groupName, groupColor, textStyle, isCollapsed = false) {
  // Sanitize groupName to create a valid ID
  const groupId = `task-group-header-${groupName.replace(/[^a-zA-Z0-9]/g, '-')}`;
  const collapsedClass = isCollapsed ? 'collapsed' : '';
  const iconStyle = isCollapsed ? 'transform: rotate(-90deg);' : '';

  return `<div id="${groupId}"
                 class="collapsible-header p-2 rounded-md cursor-pointer flex justify-between items-center mt-4 ${collapsedClass}"
                 data-group="${groupName}"
                 style="background-color: ${groupColor}; color: ${textStyle.color}; text-shadow: ${textStyle.textShadow};">
                <h4 class="font-bold">${groupName}</h4>
                <span class="transform transition-transform duration-200" style="${iconStyle}"></span>
            </div>`;
}

function sensitivityControlsTemplate(settings) {
  const { sValue, isAdaptive } = settings;
  const sliderDisabled = isAdaptive ? 'disabled' : '';
  return `<div class="flex items-center justify-between">
                <label for="adaptive-sensitivity-toggle" class="form-label mb-0">Adaptive Sensitivity:</label>
                <input type="checkbox" id="adaptive-sensitivity-toggle" data-action="toggleAdaptiveSensitivity" class="toggle-checkbox" ${isAdaptive ? 'checked' : ''}>
            </div>
            <div class="space-y-2 ${isAdaptive ? 'opacity-50' : ''}">
                <label for="sensitivity-slider" class="form-label">Manual Sensitivity:</label>
                <div class="flex items-center space-x-4">
                    <span>Least</span>
                    <input type="range" id="sensitivity-slider" min="0" max="1" step="0.01" value="${sValue}" class="w-full" ${sliderDisabled}>
                    <span>Most</span>
                </div>
            </div>`;
}

function notificationManagerTemplate(notificationSettings, categories) {
  const categoryItems = categories.map(cat => `
        <div class="flex items-center justify-between p-2 border rounded-md">
            <span class="font-medium">${cat.name}</span>
            <input type="checkbox" data-action="toggleCategoryNotification" data-category-id="${cat.id}" class="toggle-checkbox" ${notificationSettings.categories[cat.id] !== false ? 'checked' : ''}>
        </div>`).join('');
  return `<div class="flex items-center justify-between">
                <label for="master-notification-toggle" class="form-label mb-0">Enable All Notifications:</label>
                <input type="checkbox" id="master-notification-toggle" data-action="toggleAllNotifications" class="toggle-checkbox" ${notificationSettings.enabled ? 'checked' : ''}>
            </div>
            <div id="notification-details" class="${notificationSettings.enabled ? '' : 'hidden'} space-y-4">
                <div>
                    <label class="form-label">Rate Limit:</label>
                    <div class="flex space-x-2 items-center">
                        <input type="number" id="notification-rate-amount" value="${notificationSettings.rateLimit.amount}" min="1" class="duration-input">
                        <select id="notification-rate-unit" class="flex-grow">
                            <option value="minutes" ${notificationSettings.rateLimit.unit === 'minutes' ? 'selected' : ''}>Minute(s)</option>
                            <option value="hours" ${notificationSettings.rateLimit.unit === 'hours' ? 'selected' : ''}>Hour(s)</option>
                            <option value="days" ${notificationSettings.rateLimit.unit === 'days' ? 'selected' : ''}>Day(s)</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label class="form-label">Notify for categories:</label>
                    <div id="notification-category-list" class="space-y-2">${categories.length > 0 ? categoryItems : '<p class="italic text-sm">No categories to configure.</p>'}</div>
                </div>
            </div>`;
}

function kpiAutomationSettingsTemplate(settings) {
  const { autoKpiEnabled, autoKpiRemovable } = settings;
  return `<p class="form-hint">Automatically create KPIs for categories based on a GPA-like model.</p>
            <div class="flex items-center justify-between">
                <label for="auto-kpi-enabled-toggle" class="form-label mb-0" title="Auto-flag a task as a KPI when it reaches max misses.">Enable Auto-KPI:</label>
                <input type="checkbox" id="auto-kpi-enabled-toggle" data-action="toggleAutoKpi" class="toggle-checkbox" ${autoKpiEnabled ? 'checked' : ''}>
            </div>
            <div class="flex items-center justify-between mt-4">
                <label for="auto-kpi-removable-toggle" class="form-label mb-0" title="Auto-remove KPI status on recovery.">Auto-remove on Recovery:</label>
                <input type="checkbox" id="auto-kpi-removable-toggle" data-action="toggleAutoKpiRemovable" class="toggle-checkbox" ${autoKpiRemovable ? 'checked' : ''}>
            </div>`;
}

function historicalTaskCardTemplate(task) {
  const categoryColor = task.categoryColor || '#374151'; // Default to a neutral gray
  const gpaColor = task.gpaColor || '#4A5568';
  const lastCompleted = task.lastCompleted ? new Date(task.lastCompleted).toLocaleDateString() : 'N/A';

  return `
        <div class="historical-task-card p-3 rounded-lg cursor-pointer"
             data-task-id="${task.id}"
             style="background-color: ${categoryColor}; border: 3px solid ${gpaColor};">
            <h4 class="font-bold truncate">${task.name}</h4>
            <p class="text-xs opacity-80 mt-1">Last completed: ${lastCompleted}</p>
        </div>
    `;
}

function hintManagerTemplate(hints, uiSettings) {
  const hintItemsHtml = hints.map(hint => {
    const isCompleted = uiSettings.userInteractions[hint.interaction];
    return `
            <label class="flex items-center justify-between p-2 border rounded-md text-sm">
                <span>${hint.text.replace('', '').trim()}</span>
                <input type="checkbox" data-interaction="${hint.interaction}" class="h-4 w-4 rounded hint-seen-checkbox" ${isCompleted ? 'checked' : ''}>
            </label>
        `;
  }).join('');

  return `
        <div class="flex items-center justify-between">
            <label for="disable-hints-toggle" class="form-label mb-0">Disable All Hint Banners:</label>
            <input type="checkbox" id="disable-hints-toggle" data-action="toggleAllHints" class="toggle-checkbox" ${uiSettings.hintsDisabled ? 'checked' : ''}>
        </div>
        <fieldset id="hint-details-container" class="space-y-3 mt-3 border-none p-0" ${uiSettings.hintsDisabled ? 'disabled' : ''}>
            <p class="text-xs italic">Uncheck hints to see them again. The banner shows one random, un-checked hint at a time.</p>
            <div id="hint-list" class="space-y-2 max-h-48 overflow-y-auto border rounded p-2">
                ${hintItemsHtml}
            </div>
            <button data-action="resetAllHints" class="btn btn-secondary btn-md w-full">Reset All Hints (Show All)</button>
        </fieldset>
    `;
}

// =================================================================================
// T-3.0: MODAL & OVERLAY TEMPLATES
// =================================================================================

function calendarCategoryFilterTemplate(categories, filterSettings = {}, filterTargetView = 'all') {
  const renderRow = (id, name, isItalic = false) => {
    const settings = filterSettings[id] || { show: true, schedule: true };
    const nameClass = isItalic ? 'italic' : 'font-semibold';
    return `
            <div class="flex items-center justify-between p-2 rounded-md hover:bg-secondary">
                <span class="${nameClass}">${name}</span>
                <div class="flex items-center space-x-4">
                    <label class="text-xs flex items-center space-x-2 cursor-pointer" title="Show/hide tasks from this category on the calendar view.">
                        <span>Show</span>
                        <input type="checkbox" data-action="toggleCalendarFilter" data-filter-type="show" data-category-id="${id}" class="toggle-checkbox" ${settings.show ? 'checked' : ''}>
                    </label>
                    <label class="text-xs flex items-center space-x-2 cursor-pointer" title="Include/exclude tasks from this category in scheduling calculations (e.g., GPA, status changes).">
                        <span>Schedule</span>
                        <input type="checkbox" data-action="toggleCalendarFilter" data-filter-type="schedule" data-category-id="${id}" class="toggle-checkbox" ${settings.schedule ? 'checked' : ''}>
                    </label>
                </div>
            </div>
        `;
  };

  const categoryRows = categories.map(cat => renderRow(cat.id, cat.name)).join('');
  const uncategorizedRow = renderRow('null', 'Uncategorized', true);

  return `
        <div class="space-y-1 p-2 bg-main rounded-lg mt-4">
            <div class="flex justify-between items-center mb-2">
                 <h4 class="font-bold">Calendar Category Filters</h4>
                 <div class="flex items-center space-x-2">
                    <label for="calendar-filter-view-select" class="text-sm">Apply to:</label>
                    <select id="calendar-filter-view-select" data-action="setCalendarFilterView" class="text-sm p-1 rounded-md">
                        <option value="all" ${filterTargetView === 'all' ? 'selected' : ''}>All Views</option>
                        <option value="timeGridDay" ${filterTargetView === 'timeGridDay' ? 'selected' : ''}>Day</option>
                        <option value="timeGridWeek" ${filterTargetView === 'timeGridWeek' ? 'selected' : ''}>Week</option>
                        <option value="dayGridMonth" ${filterTargetView === 'dayGridMonth' ? 'selected' : ''}>Month</option>
                    </select>
                </div>
            </div>
            ${categoryRows}
            ${uncategorizedRow}
        </div>
    `;
}

function welcomeModalTemplate() {
  return `
        <div id="welcome-modal" class="modal">
            <div class="modal-content bg-modal">
                <h2 class="text-2xl font-semibold mb-4">Welcome!</h2>
                <p class="mb-4">To personalize your experience, please pick your favorite color. We'll use it to generate a custom theme for you.</p>
                <div class="flex items-center justify-center space-x-4 my-6">
                    <input type="color" id="welcome-color-picker" value="#3b82f6" class="p-1 h-16 w-16 bg-white border border-gray-200 cursor-pointer rounded-lg">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="welcome-no-thanks" class="btn btn-tertiary btn-md">No Thanks</button>
                    <button id="welcome-submit" class="btn btn-confirm btn-md">Set Theme</button>
                </div>
            </div>
        </div>
    `;
}

function categoryIconApplyConfirmModalTemplate(category) {
  const iconHtml = category.icon ? `<i class="${category.icon} text-2xl mr-2"></i>` : '<span class="text-2xl mr-2"></span>';
  const isDarkMode = !document.body.classList.contains('light-mode');
  const textColor = isDarkMode ? 'text-gray-200' : 'text-gray-800';

  return `
<div id="category-icon-confirm-modal" class="modal active" style="z-index: 1060;">
  <div class="modal-content max-w-lg bg-modal">
    <div class="modal-header">
      <h3 class="text-xl font-bold ${textColor}">Apply Category Icon?</h3>
      <button data-action="cancel" class="close-button">&times;</button>
    </div>
    <div class="modal-body ${textColor}">
      <div class="flex items-center mb-4">
        ${iconHtml}
        <p>You've enabled "Apply icon automatically" for the category "<strong>${category.name}</strong>".</p>
      </div>
      <p class="mb-4">How would you like to apply this icon?</p>
      <div class="flex flex-col space-y-2">
        <button data-action="apply-all" data-category-id="${category.id}" class="btn btn-primary text-left p-3">
          <strong>Apply to All Existing & Future Tasks</strong>
          <span class="text-xs block font-normal">Overwrite the icon on all current, historical, and archived tasks in this category.</span>
        </button>
        <button data-action="apply-future" data-category-id="${category.id}" class="btn btn-secondary text-left p-3">
          <strong>Apply to Future Tasks Only</strong>
          <span class="text-xs block font-normal">Only new tasks created in this category will get this icon automatically.</span>
        </button>
        <button data-action="cancel" class="btn btn-tertiary mt-4">Cancel</button>
      </div>
    </div>
  </div>
</div>
`;
}




function transferChangesConfirmationModalTemplate() {
  return `
    <div id="transfer-changes-modal" class="modal active" style="z-index: 1060;">
      <div class="modal-content bg-modal">
        <h3 class="text-xl font-semibold mb-4">Unsaved Changes Detected</h3>
        <p class="mb-6 text-sm">You have unsaved changes. Would you like to apply them to the main task before editing it?</p>
        <div class="flex flex-col space-y-2 md:flex-row md:space-y-0 md:space-x-2 justify-end">
          <button data-action="cancel-transfer" class="btn btn-tertiary">Cancel</button>
          <button data-action="discard-changes" class="btn btn-secondary">Discard Changes & Edit</button>
          <button data-action="transfer-changes" class="btn btn-primary">Transfer Changes & Edit</button>
        </div>
      </div>
    </div>
  `;
}

function simpleEditFormTemplate(task, occurrence, categories) {
  const occurrenceId = occurrence ? occurrence.id : task.id;
  // If editing an override, use its date. Otherwise, use the occurrence date or the task's base due date.
  const override = task.occurrenceOverrides && task.occurrenceOverrides[occurrenceId];
  const dateToEdit = (override && override.dueDate) ? new Date(override.dueDate) : (occurrence ? new Date(occurrence.occurrenceDueDate) : new Date(task.dueDate));
  const nameToEdit = (override && override.name) ? override.name : task.name;
  const iconToEdit = (override && override.icon) ? override.icon : task.icon;
  const categoryToEdit = (override && override.categoryId) ? override.categoryId : task.categoryId;
  const durationAmountToEdit = (override && override.estimatedDurationAmount) ? override.estimatedDurationAmount : task.estimatedDurationAmount;
  const durationUnitToEdit = (override && override.estimatedDurationUnit) ? override.estimatedDurationUnit : task.estimatedDurationUnit;


  // Helper to format date for datetime-local input
  const formatDateForInput = (date) => {
    if (!date || isNaN(date)) return '';
    const pad = (num) => String(num).padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
  };

  const categoryOptions = categories.map(cat =>
    `<option value="${cat.id}" ${categoryToEdit === cat.id ? 'selected' : ''}>${cat.name}</option>`
  ).join('');


  return `
        <div id="simple-edit-modal" class="modal active">
            <div class="modal-content bg-modal">
                <form id="simple-edit-form">
                    <button class="close-button" type="button" data-action="close-simple-edit-modal">&times;</button>
                    <h3 class="text-xl font-semibold mb-4">Edit Occurrence</h3>
                     <button type="button" class="btn btn-clear text-xs -mt-2 mb-4" data-action="edit-base-task" data-task-id="${task.id}">
                        <i class="fa-solid fa-pencil"></i> Edit the main task instead
                    </button>
                    <p class="text-sm mb-4 italic">You are editing a single occurrence of a repeating task.</p>
                    <input type="hidden" id="simple-edit-task-id" value="${task.id}">
                    <input type="hidden" id="simple-edit-occurrence-id" value="${occurrenceId}">

                    <div class="space-y-4">
                        <div>
                            <label for="simple-edit-task-name" class="form-label">Task Name</label>
                            <input type="text" id="simple-edit-task-name" value="${nameToEdit}" class="w-full" required>
                        </div>

                        <div>
                            <label class="form-label">Time</label>
                            <div class="grid grid-cols-2 gap-2">
                                <select id="simple-edit-time-input-type" class="form-input">
                                    <option value="due" ${task.timeInputType !== 'start' ? 'selected' : ''}>Due Time</option>
                                    <option value="start" ${task.timeInputType === 'start' ? 'selected' : ''}>Start Time</option>
                                </select>
                                <input type="datetime-local" id="simple-edit-due-date" value="${formatDateForInput(dateToEdit)}" class="w-full" required>
                            </div>
                        </div>

                        <div>
                            <label for="simple-edit-category" class="form-label">Category</label>
                            <select id="simple-edit-category" name="categoryId" class="form-input">
                                <option value="">-- No Category --</option>
                                ${categoryOptions}
                            </select>
                        </div>

                        <div>
                            <label for="simple-edit-icon" class="form-label">Icon</label>
                            <div class="flex items-center space-x-2">
                                <input type="text" id="simple-edit-icon" value="${iconToEdit || ''}" class="w-full">
                                <button type="button" data-action="open-icon-picker-simple" class="btn btn-secondary">Choose</button>
                            </div>
                        </div>

                        <div>
                            <label class="form-label">Estimated Duration</label>
                            <div class="flex space-x-2 items-center">
                                <input type="number" id="simple-edit-duration-amount" value="${durationAmountToEdit || ''}" min="1" class="duration-input">
                                <select id="simple-edit-duration-unit" class="flex-grow">
                                    <option value="minutes" ${durationUnitToEdit === 'minutes' ? 'selected' : ''}>Minute(s)</option>
                                    <option value="hours" ${durationUnitToEdit === 'hours' ? 'selected' : ''}>Hour(s)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-2 mt-6">
                        <button type="button" data-action="close-simple-edit-modal" class="btn btn-tertiary">Cancel</button>
                        <button type="submit" class="btn btn-confirm">Update Occurrence</button>
                    </div>
                </form>
            </div>
        </div>
    `;
}

function orphanedOverrideModalTemplate(orphans, task, newOccurrences) {
  const occurrencesDropdown = (orphanId) => `
        <select data-action="select-relink-target" data-orphan-id="${orphanId}" class="relink-select">
            <option value="">-- Select a new date --</option>
            ${newOccurrences.map(occ => `<option value="${occ.id}">${new Date(occ.occurrenceDueDate).toLocaleString()}</option>`).join('')}
        </select>
    `;

  const orphansHtml = orphans.map(orphan => `
        <div class="orphaned-item p-3 border rounded-md mb-3" data-orphan-id="${orphan.occurrenceId}">
            <p class="text-sm italic"><strong>Original Date:</strong> ${new Date(orphan.originalDate).toLocaleString()}</p>
            <div class="my-2 p-2 bg-main rounded prose prose-sm">${orphan.thoughts}</div>
            <div class="flex flex-wrap items-center justify-end gap-2 text-sm">
                ${occurrencesDropdown(orphan.occurrenceId)}
                <button data-action="relink-override" data-orphan-id="${orphan.occurrenceId}" class="btn btn-secondary btn-xs" disabled>Re-link</button>
                <button data-action="journal-override" data-orphan-id="${orphan.occurrenceId}" class="btn btn-tertiary btn-xs">Journal</button>
                <button data-action="delete-override" data-orphan-id="${orphan.occurrenceId}" class="btn btn-deny btn-xs">Delete</button>
            </div>
        </div>
    `).join('');

  return `
        <div id="orphaned-override-modal" class="modal active">
            <div class="modal-content bg-modal">
                <h3 class="text-xl font-semibold mb-2">Edits Detected on Changed Repetition</h3>
                <p class="text-sm mb-4">You've changed the repetition rules for "<strong>${task.name}</strong>", and we found notes attached to future dates that no longer exist. Please decide what to do with them.</p>
                <div class="max-h-80 overflow-y-auto p-1">
                    ${orphansHtml}
                </div>
                <div class="flex justify-end mt-4">
                    <button data-action="finish-override-handling" class="btn btn-primary btn-md">Done</button>
                </div>
            </div>
        </div>
    `;
}

function addIconPromptModalTemplate(taskId) {
  return `
        <div id="add-icon-prompt-modal" class="modal active">
            <div class="modal-content bg-modal">
                <h3 class="text-xl font-semibold mb-4">Assign an Icon?</h3>
                <p class="mb-4 text-sm">This task doesn't have an icon. Would you like to assign one? Icons help with sorting in the Journal.</p>
                <div class="flex justify-end space-x-2">
                    <button id="prompt-no-thanks" class="btn btn-tertiary btn-md">No, Thanks</button>
                    <button id="prompt-choose-icon" data-task-id="${taskId}" class="btn btn-secondary btn-md">Yes, Choose Icon</button>
                </div>
            </div>
        </div>
    `;
}

function conflictResolutionModalTemplate(conflicts) {
  const conflictItemsHtml = conflicts.map((conflict, index) => `
        <div class="conflict-item p-4 border rounded-lg mb-4">
            <h4 class="font-bold text-lg mb-2">Conflict ${index + 1}: ${conflict.type} - "${conflict.id}"</h4>
            <div class="grid grid-cols-2 gap-4">
                <div class="p-2 border rounded">
                    <h5 class="font-semibold mb-2">Existing Data</h5>
                    <pre class="text-xs whitespace-pre-wrap">${JSON.stringify(conflict.existing, null, 2)}</pre>
                    <button data-action="resolve-conflict" data-index="${index}" data-choice="existing" class="btn btn-secondary btn-sm mt-2 w-full">Keep Existing</button>
                </div>
                <div class="p-2 border rounded">
                    <h5 class="font-semibold mb-2">Imported Data</h5>
                    <pre class="text-xs whitespace-pre-wrap">${JSON.stringify(conflict.imported, null, 2)}</pre>
                    <button data-action="resolve-conflict" data-index="${index}" data-choice="imported" class="btn btn-primary btn-sm mt-2 w-full">Use Imported</button>
                </div>
            </div>
        </div>
    `).join('');

  return `
        <div id="conflict-resolution-modal" class="modal">
            <div class="modal-content bg-modal">
                <h3 class="text-xl font-semibold mb-2">Resolve Import Conflicts</h3>
                <p class="text-sm mb-4">The following items in the import file have the same ID as existing items but contain different data. Please choose which version to keep for each conflict.</p>
                <div id="conflict-list" class="max-h-96 overflow-y-auto mb-4">${conflictItemsHtml}</div>
                <div class="flex justify-end">
                    <button id="finish-merge-btn" class="btn btn-confirm btn-md">Finish Merge</button>
                </div>
            </div>
        </div>
    `;
}

function importModalTemplate() {
  return `
        <div id="import-modal" class="modal">
            <div class="modal-content bg-modal">
                <button class="close-button" id="import-modal-close-btn">&times;</button>
                <h3 class="text-xl font-semibold mb-4">Import Data</h3>
                <p class="mb-4 text-sm">Please select how you would like to import the data from your backup file.</p>
                <div class="space-y-4">
                    <div>
                        <button id="import-replace-btn" class="btn btn-primary btn-lg w-full">
                            <h4 class="font-bold">Replace</h4>
                            <p class="text-xs font-normal">Delete all current data and replace it with the data from the file.</p>
                        </button>
                    </div>
                    <div>
                        <button id="import-merge-btn" class="btn btn-secondary btn-lg w-full">
                            <h4 class="font-bold">Merge</h4>
                            <p class="text-xs font-normal">Add new data from the file. If any tasks, categories, or settings have the same ID, you will be asked how to resolve the conflict.</p>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// --- script.js ---
// =================================================================================
// S-1.0: GLOBAL STATE & CONFIGURATION
// =================================================================================

Chart.register(...registerables);

// =================================================================================
// S-1.1: Core Application State
// =================================================================================
let isInitializing = true; // Flag to prevent premature saves
let tasks = [];
let categories = [];
const defaultStatusColors = { blue: '#00BFFF', green: '#22c55e', yellow: '#facc15', red: '#991b1b', black: '#4b5563' };
const defaultStatusNames = { blue: 'Locked', green: 'Ready', yellow: 'Start Soon', red: 'Do Right Now', black: 'Overdue' };
let statusColors = { ...defaultStatusColors };
let statusNames = { ...defaultStatusNames };
let notificationSettings = { enabled: false, rateLimit: { amount: 5, unit: 'minutes' }, categories: {} };
let notificationEngine = { timeouts: [], lastNotificationTimestamps: {} };
let theming = { enabled: false, baseColor: '#3b82f6', mode: 'auto', useThemeForStatus: true, calendarGradientSource: 'status' };
let appSettings = {
  title: 'Task & Mission Planner',
  subtitle: 'Organize your tasks, plan your week, and track your progress.',
  weeklyGoalLabel: 'Mission/Goals for this Week',
  use24HourFormat: false,
  autoKpiEnabled: false,
  autoKpiRemovable: false,
  gpaSystem: 'standard', // 'standard' or 'extended'
};
let calendarSettings = { categoryFilter: [], syncFilter: true, lastView: 'timeGridWeek', allowCreationOnClick: false };
let lastBulkEditSettings = {};
let oldTasksData = [];
let editingTaskId = null;
let editingHistoryEventId = null;
let editingCategoryIdForIcon = null;
let kpiChart = null; // For single chart view
let kpiCharts = []; // For stacked chart view
let modalStack = [];
let initialFormState = '';
let calendarMonthEvents = [];
let calendarTimeGridEvents = [];
// let taskViewBorderInterval = null; // This is no longer needed
let taskViewListenerController = new AbortController(); // To manage event listeners
// isSimpleMode is now part of uiSettings
let countdownIntervals = {};
let mainUpdateInterval = null;
let taskTimers = {};
let sortBy = 'status';
let sortDirection = 'asc';
let categoryFilter = [];
let plannerSettings = { defaultCategoryId: 'Planner' };
let taskDisplaySettings = {
  showDueDate: true, showRepetition: true, showDuration: true,
  showCategory: true, showCountdown: true, showProgress: true,
};
let uiSettings = {
  isSimpleMode: true,
  activeView: 'dashboard-view', // Default view
  kpiChartMode: 'single', // 'single' or 'stacked'
  kpiChartDateRange: '8d', // '8d', '30d', etc.
  journalIconCollapseState: {},
  journalWeekCollapseState: {},
  advancedOptionsCollapseState: {},
  taskManagerCollapseState: {},
  calculationHorizonAmount: 1,
  calculationHorizonUnit: 'years',
  hintsDisabled: false,
  closeModalAfterAction: false,
  calendarCategoryFilters: {},
  showCalendarFilters: true, // New setting
  monthView: {
    showIcon: true,
    showTime: false,
    showName: true,
    groupTasks: true,
  },
  weekView: { // New settings for week view
    showIcon: true,
    showTime: true,
    showName: true,
  },
  dayView: { // New settings for day view
    showIcon: true,
    showTime: true,
    showName: true,
  },
  welcomeScreenShown: false,
  earlyOnTimeSettings: {
    enabled: false,
    displaceCalendar: false,
    onlyAppointments: false,
  },
  dashboardWeekOffset: 0,
  syncTaskIcons: true,
  useStartDateForSort: false,
  smartFormDefaults: {
    enabled: true
  },
  smartFormHistory: {
    dateType: [],
    completionType: [],
    repetitionUnit: [],
    estimatedDurationUnit: [],
    prepTimeUnit: [],
  },
};
let journalSettings = {
  weeklyGoalIcon: 'fa-solid fa-bullseye',
};
// New global settings for prep and early buffers
let bufferSettings = {
  prep: { icon: 'fa-solid fa-suitcase-rolling', label: 'Prep' },
  early: { icon: 'fa-solid fa-clock', label: 'Early' },
  dashboard: { combinePrepTime: false }
};
let sensitivitySettings = { sValue: 0.5, isAdaptive: false };
const STATUS_UPDATE_INTERVAL = 15000;
const MS_PER_SECOND = 1000;

const iconCategories = {
  'General': ['fa-star', 'fa-heart', 'fa-check', 'fa-xmark', 'fa-flag', 'fa-bell', 'fa-bolt', 'fa-gift', 'fa-key', 'fa-lightbulb', 'fa-moon', 'fa-sun', 'fa-fire', 'fa-trophy', 'fa-shield-halved', 'fa-bookmark', 'fa-eye', 'fa-eye-slash', 'fa-thumbs-up', 'fa-thumbs-down', 'fa-circle-info', 'fa-circle-question', 'fa-circle-exclamation', 'fa-award', 'fa-magnet', 'fa-bomb', 'fa-recycle'],
  'Home & Family': ['fa-house', 'fa-baby', 'fa-child', 'fa-children', 'fa-user', 'fa-user-group', 'fa-users', 'fa-person-cane', 'fa-person-walking-with-cane', 'fa-wheelchair', 'fa-kitchen-set', 'fa-bath', 'fa-bed', 'fa-couch', 'fa-chair', 'fa-tv', 'fa-plug', 'fa-lightbulb', 'fa-fan', 'fa-jug-detergent', 'fa-church'],
  'Cleaning & Chores': ['fa-broom', 'fa-soap', 'fa-spray-can-sparkles', 'fa-trash', 'fa-pump-soap', 'fa-shower', 'fa-sink', 'fa-toilet', 'fa-trowel', 'fa-wrench', 'fa-hammer', 'fa-screwdriver-wrench', 'fa-paint-roller', 'fa-box-archive'],
  'Productivity & Work': ['fa-briefcase', 'fa-bullseye', 'fa-calendar-days', 'fa-clock', 'fa-file-signature', 'fa-laptop-file', 'fa-list-check', 'fa-pencil', 'fa-book-open', 'fa-graduation-cap', 'fa-chart-pie', 'fa-magnifying-glass-chart', 'fa-paperclip', 'fa-building', 'fa-sitemap', 'fa-network-wired', 'fa-calculator', 'fa-gears', 'fa-timeline', 'fa-clipboard-list'],
  'Communication': ['fa-at', 'fa-envelope', 'fa-phone', 'fa-comments', 'fa-users', 'fa-bullhorn', 'fa-address-book', 'fa-mobile-screen-button', 'fa-fax', 'fa-wifi', 'fa-rss', 'fa-satellite-dish'],
  'Finance & Shopping': ['fa-dollar-sign', 'fa-euro-sign', 'fa-pound-sign', 'fa-yen-sign', 'fa-credit-card', 'fa-wallet', 'fa-piggy-bank', 'fa-money-bill-wave', 'fa-receipt', 'fa-chart-line', 'fa-basket-shopping', 'fa-cart-shopping', 'fa-store', 'fa-tag', 'fa-barcode'],
  'Health & Fitness': ['fa-heart-pulse', 'fa-dumbbell', 'fa-person-running', 'fa-apple-whole', 'fa-pills', 'fa-stethoscope', 'fa-brain', 'fa-weight-scale', 'fa-spa', 'fa-dna', 'fa-first-aid', 'fa-notes-medical', 'fa-bicycle', 'fa-person-swimming', 'fa-fire-flame-curved'],
  'Travel & Transport': ['fa-plane', 'fa-car', 'fa-train', 'fa-bus', 'fa-ship', 'fa-earth-americas', 'fa-map-location-dot', 'fa-suitcase', 'fa-passport', 'fa-bed', 'fa-motorcycle', 'fa-rocket', 'fa-anchor', 'fa-taxi', 'fa-gas-pump'],
  'Food & Drink': ['fa-utensils', 'fa-mug-hot', 'fa-martini-glass', 'fa-ice-cream', 'fa-pizza-slice', 'fa-burger', 'fa-seedling', 'fa-carrot', 'fa-cookie-bite', 'fa-fish', 'fa-wine-bottle', 'fa-cheese', 'fa-pepper-hot', 'fa-lemon', 'fa-bowl-food', 'fa-bowl-rice', 'fa-candy-cane', 'fa-cake-candles', 'fa-blender', 'fa-whiskey-glass'],
  'Nature & Weather': ['fa-tree', 'fa-leaf', 'fa-mountain-sun', 'fa-water', 'fa-cloud-sun', 'fa-cloud-rain', 'fa-snowflake', 'fa-wind', 'fa-tornado', 'fa-volcano', 'fa-seedling', 'fa-feather', 'fa-plant-wilt'],
  'Animals': ['fa-cat', 'fa-dog', 'fa-hippo', 'fa-fish-fins', 'fa-crow', 'fa-spider', 'fa-otter', 'fa-dragon', 'fa-horse', 'fa-cow', 'fa-dove', 'fa-shrimp', 'fa-bugs', 'fa-worm', 'fa-paw', 'fa-bone', 'fa-horse-head', 'fa-frog', 'fa-kiwi-bird'],
  'Hobbies & Entertainment': ['fa-gamepad', 'fa-dice-d20', 'fa-ghost', 'fa-puzzle-piece', 'fa-music', 'fa-guitar', 'fa-paintbrush', 'fa-book', 'fa-film', 'fa-camera-retro', 'fa-theater-masks', 'fa-bowling-ball', 'fa-chess-knight', 'fa-wand-magic-sparkles', 'fa-clapperboard'],
  'Technology & Devices': ['fa-computer', 'fa-laptop', 'fa-mobile-alt', 'fa-tablet-alt', 'fa-keyboard', 'fa-mouse', 'fa-headphones', 'fa-server', 'fa-database', 'fa-code', 'fa-microchip', 'fa-robot', 'fa-vr-cardboard'],
  'Symbols & Shapes': ['fa-shapes', 'fa-diamond', 'fa-circle', 'fa-square', 'fa-bahai', 'fa-atom', 'fa-certificate', 'fa-anchor', 'fa-asterisk', 'fa-cube', 'fa-clover', 'fa-crosshairs', 'fa-genderless', 'fa-yin-yang'],
  'Brands': ['fa-brands fa-apple', 'fa-brands fa-windows', 'fa-brands fa-android', 'fa-brands fa-google', 'fa-brands fa-amazon', 'fa-brands fa-facebook', 'fa-brands fa-twitter', 'fa-brands fa-instagram', 'fa-brands fa-linkedin', 'fa-brands fa-github', 'fa-brands fa-youtube', 'fa-brands fa-discord', 'fa-brands fa-slack', 'fa-brands fa-figma']
};

const DUE_THRESHOLD_MS = 1000;
const MAX_CYCLE_CALCULATION = 100;

// DOM Element References (Task Manager)
let taskModal, taskForm, taskListDiv, modalTitle, taskIdInput, taskNameInput, taskDescriptionInput, taskThoughtsInput, taskIconInput,
  iconPickerModal, dataMigrationModal, journalModal, journalForm, journalModalTitle, journalEntryIdInput,
  journalEntryTitleInput, journalEntryIconInput, journalEntryContentInput,
  timeInputTypeSelect, dueDateGroup, taskDueDateInput, startDateGroup, taskStartDateInput,
  dueDateTypeSelect, relativeDueDateGroup,
  relativeAmountInput, relativeUnitSelect, taskRepetitionSelect, repetitionRelativeGroup,
  repetitionAmountInput, repetitionUnitSelect, repeatingOptionsGroup,
  maxMissesGroup, maxMissesInput, trackMissesInput,
  completionTypeSelect, estimatedDurationGroup,
  estimatedDurationAmountInput, estimatedDurationUnitSelect,
  completionCountGroup, countTargetInput,
  completionTimeGroup, timeTargetAmountInput, timeTargetUnitSelect,
  repetitionAbsoluteGroup, absoluteFrequencySelect,
  absoluteWeeklyOptions, absoluteMonthlyOptions, absoluteYearlyOptions,
  monthlyDayNumberOptions, monthlyDayOfWeekOptions, yearlyDayNumberOptions, yearlyDayOfWeekOptions,
  weekdayCheckboxes, monthlyOccurrenceCheckboxes, yearlyOccurrenceCheckboxes, yearlyMonthCheckboxes,
  monthlyWeekdayCheckboxes, yearlyWeekdayCheckboxes, monthlyDayCheckboxes, yearlyDayCheckboxes,
  requiresFullAttentionInput, isAppointmentInput,
  taskCategorySelect, newCategoryGroup, newCategoryNameInput,
  advancedOptionsModal,
  sortBySelect, sortDirectionSelect, categoryFilterList,
  plannerDefaultCategorySelect, dayNightToggle;

// DOM Element References (Planner)
let app, weeklyGoalsEl,
  addNewKpiBtn, setKpiBtn, kpiTaskSelect,
  calendarEl, // New element for FullCalendar
  progressTrackerContainer, viewBtns, startNewWeekBtn, confirmModal,
  cancelNewWeekBtn, confirmNewWeekBtn, prevWeekBtn, nextWeekBtn, todayBtn,
  weekStatusEl, weekDateRangeEl,
  showTaskManagerBtn, showCalendarBtn, showDashboardBtn, showJournalBtn, taskManagerView, calendarView, dashboardView, journalView,
  taskViewModal, taskViewContent, taskStatsContent;

// FullCalendar instance
let calendar;

// Planner State
const MAX_WEEKS_STORED = 6;
const CURRENT_WEEK_INDEX = 4;
const DATA_KEY = 'pilotPlannerDataV8';
const VIEW_STATE_KEY = 'pilotPlannerViewStateV8';

const appState = {
  weeks: [],
  indicators: [],
  historicalTasks: [],
  archivedTasks: [], // New: To store full task objects that are no longer active.
  journal: [],
  vacations: [], // New: To store vacation periods {id, name, startDate, endDate}
  viewingIndex: CURRENT_WEEK_INDEX, currentView: 'weekly', currentDayIndex: 0,
};



// Planner State is defined in S-1.1

// =================================================================================
// S-2.0: CORE UTILITY FUNCTIONS
// =================================================================================
function generateId() { return '_' + Math.random().toString(36).substr(2, 9); }
const pad = (num, length = 2) => String(num).padStart(length, '0');

function formatTime(date) {
  if (!date || isNaN(date)) return 'N/A';
  const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: !appSettings.use24HourFormat };
  return date.toLocaleTimeString('en-US', timeOptions);
}

function formatDateForInput(date) {
  if (!date || !(date instanceof Date) || isNaN(date)) return '';
  try {
    const yr = date.getFullYear();
    const mm = pad(date.getMonth() + 1);
    const dd = pad(date.getDate());
    const hh = pad(date.getHours());
    const min = pad(date.getMinutes());
    return `${yr}-${mm}-${dd}T${hh}:${min}`;
  } catch (e) { console.error('Error formatting date:', date, e); return ''; }
}
function calculateFutureDate(amount, unit, baseDate) {
  try {
    const date = new Date(baseDate);
    amount = parseInt(amount, 10);
    if (isNaN(amount) || amount <= 0) amount = 1;
    switch (unit) {
    case 'minutes': date.setMinutes(date.getMinutes() + amount); break;
    case 'hours': date.setHours(date.getHours() + amount); break;
    case 'days': date.setDate(date.getDate() + amount); break;
    case 'weeks': date.setDate(date.getDate() + amount * 7); break;
    case 'months': date.setMonth(date.getMonth() + amount); break;
    case 'years': date.setFullYear(date.getFullYear() + amount); break;
    default: console.warn('Unknown unit:', unit);
    }
    return date;
  } catch (e) { console.error('Error calculating future date:', e); return new Date(baseDate); }
}

function getCalculationHorizonDate() {
  const amount = uiSettings.calculationHorizonAmount || 1;
  const unit = uiSettings.calculationHorizonUnit || 'years';
  return calculateFutureDate(amount, unit, new Date());
}
function parseTimeToMs(timeStr) {
  if (!timeStr || typeof timeStr !== 'string') return 0;
  const parts = timeStr.split(':').map(Number);
  let ms = 0;
  if (parts.length === 3) {
    ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_HOUR;
    ms += (isNaN(parts[1]) ? 0 : parts[1]) * MS_PER_MINUTE;
    ms += (isNaN(parts[2]) ? 0 : parts[2]) * MS_PER_SECOND;
  } else if (parts.length === 2) {
    ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_MINUTE;
    ms += (isNaN(parts[1]) ? 0 : parts[1]) * MS_PER_SECOND;
  } else if (parts.length === 1) {
    ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_SECOND;
  }
  return ms;
}
function parseMinutesToMs(minutes) {
  minutes = parseInt(minutes, 10);
  return isNaN(minutes) || minutes < 0 ? 0 : minutes * MS_PER_MINUTE;
}
function calculatePendingCycles(task, nowMs) {
  let cycles = 0;
  const originalDueDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate ? new Date(task.dueDate) : null);
  if (!originalDueDate || isNaN(originalDueDate)) {
    console.warn(`Cannot calculate pending cycles for task ${task.id}: Invalid original due date.`);
    return 0;
  }
  const originalDueDateMs = originalDueDate.getTime();
  const nowDate = new Date(nowMs);
  if (task.repetitionType !== 'none' && originalDueDateMs < nowMs) {
    if (task.repetitionType === 'relative' && task.repetitionAmount && task.repetitionUnit) {
      const intervalMs = getDurationMs(task.repetitionAmount, task.repetitionUnit);
      if (intervalMs > 0) {
        cycles = Math.floor((nowMs - originalDueDateMs) / intervalMs) + 1;
      } else {
        console.warn(`Invalid relative interval for task ${task.id}. Defaulting to 1 cycle.`);
        cycles = 1;
      }
    } else if (task.repetitionType === 'absolute') {
      try {
        // Use the new, centralized function to find all occurrences between the start and now.
        const occurrences = getOccurrences(task, new Date(originalDueDate), new Date(nowDate));
        // The number of cycles is simply the number of dates found.
        cycles = occurrences.length;
      } catch (e) {
        console.error(`Error generating occurrences for pending cycles task ${task.id}:`, e);
        cycles = 1;
      }
    } else {
      cycles = 1;
    }
  }
  return Math.max(cycles, 0);
}
function sanitizeAndUpgradeTask(task) {
  // --- Data Migration ---
  // Handle the renaming of taskType to completionType for backward compatibility.
  if (task.hasOwnProperty('taskType') && !task.hasOwnProperty('completionType')) {
    task.completionType = task.taskType;
    delete task.taskType;
  }

  const defaults = {
    name: 'Unnamed Task',
    icon: null,
    timeInputType: 'due',
    dueDateType: 'absolute',
    dueDate: null,
    repetitionType: 'none',
    maxMisses: null,
    trackMisses: true,
    requiresFullAttention: true,
    completionType: 'simple',
    currentProgress: 0,
    isTimerRunning: false,
    timerLastStarted: null,
    confirmationState: null,
    overdueStartDate: null,
    pendingCycles: null,
    misses: 0,
    completed: false,
    status: 'green',
    createdAt: new Date(),
    cycleEndDate: null,
    completionReducedMisses: false,
    description: '',
    estimatedDurationAmount: null,
    estimatedDurationUnit: 'minutes',
    categoryId: null,
    relativeAmount: null,
    relativeUnit: null,
    repetitionAmount: null,
    repetitionUnit: null,
    repetitionAbsoluteFrequency: null,
    repetitionAbsoluteWeeklyDays: null,
    repetitionAbsoluteMonthlyMode: null,
    repetitionAbsoluteDaysOfMonth: null,
    repetitionAbsoluteNthWeekdayOccurrence: null,
    repetitionAbsoluteNthWeekdayDays: null,
    repetitionAbsoluteYearlyMonths: null,
    repetitionAbsoluteYearlyMode: null,
    repetitionAbsoluteYearlyDaysOfMonth: null,
    repetitionAbsoluteYearlyNthWeekdayOccurrence: null,
    repetitionAbsoluteYearlyNthWeekdayDays: null,
    countTarget: null,
    timeTargetAmount: null,
    timeTargetUnit: null,
    isKpi: false,
    isAutoKpi: false,
    isAppointment: false,
    prepTimeAmount: null,
    prepTimeUnit: 'minutes',
    thoughts: '',
    occurrenceOverrides: {},
    repeatUntilMode: 'date',
    repeatUntilOccurrences: null,
  };
  const originalTaskJSON = JSON.stringify(task);
  let upgradedTask = { ...defaults };
  for (const key in defaults) {
    if (task.hasOwnProperty(key) && task[key] !== undefined) {
      upgradedTask[key] = task[key];
    }
  }

  upgradedTask.id = task.id;
  if (task.createdAt) {
    upgradedTask.createdAt = task.createdAt;
  }
  if (task.estimatedDuration && !task.estimatedDurationAmount) {
    upgradedTask.estimatedDurationAmount = parseInt(task.estimatedDuration, 10);
    upgradedTask.estimatedDurationUnit = 'minutes';
  }
  if (upgradedTask.dueDateType !== 'relative') {
    upgradedTask.relativeAmount = null;
    upgradedTask.relativeUnit = null;
  }
  if (upgradedTask.repetitionType === 'none') {
    upgradedTask.repetitionAmount = null;
    upgradedTask.repetitionUnit = null;
    upgradedTask.repetitionAbsoluteFrequency = null;
    upgradedTask.maxMisses = null;
  }
  if (upgradedTask.repetitionType !== 'relative') {
    upgradedTask.repetitionAmount = null;
    upgradedTask.repetitionUnit = null;
  }
  if (upgradedTask.repetitionType !== 'absolute') {
    upgradedTask.repetitionAbsoluteFrequency = null;
  }
  if (upgradedTask.completionType !== 'count') {
    upgradedTask.countTarget = null;
  }
  if (upgradedTask.completionType !== 'time') {
    upgradedTask.timeTargetAmount = null;
    upgradedTask.timeTargetUnit = null;
  }
  if (JSON.stringify(upgradedTask) !== originalTaskJSON) {
    console.log(`Upgraded task ID ${task.id}:`, { from: JSON.parse(originalTaskJSON), to: upgradedTask });
  }
  return upgradedTask;
}
function getRandomColor() {
  // Get the current base color's HSL value.
  // If no base color exists, start with a random hue.
  const currentHue = theming.baseColor ? hexToHSL(theming.baseColor).h : Math.floor(Math.random() * 360);

  let newHue;
  let attempts = 0;
  do {
    newHue = Math.floor(Math.random() * 360);
    attempts++;
    // After 10 attempts, just accept the color to prevent an infinite loop in the unlikely case it's hard to find a distant color.
  } while (Math.min(Math.abs(currentHue - newHue), 360 - Math.abs(currentHue - newHue)) < 90 && attempts < 10);

  // Generate a color with the new hue, but with a controlled saturation and lightness for a pleasant look.
  // High saturation and mid-to-high lightness generally produce vibrant but not jarring colors.
  const newSaturation = 70 + Math.random() * 20; // Saturation between 70% and 90%
  const newLightness = 60 + Math.random() * 10; // Lightness between 60% and 70%

  return HSLToHex(newHue, newSaturation, newLightness);
}
// New helper function to get the luminance of a color (WCAG compliant)
function getLuminance(hexColor) {
  if (!hexColor || typeof hexColor !== 'string' || hexColor.length < 4) return 0; // Invalid color
  const rgbInt = parseInt(hexColor.slice(1), 16);
  let r = (rgbInt >> 16) & 0xff;
  let g = (rgbInt >> 8) & 0xff;
  let b = (rgbInt >> 0) & 0xff;

  const sRGB = [r / 255, g / 255, b / 255];
  const linearRGB = sRGB.map(val => {
    if (val <= 0.03928) {
      return val / 12.92;
    }
    return Math.pow((val + 0.055) / 1.055, 2.4);
  });

  return 0.2126 * linearRGB[0] + 0.7152 * linearRGB[1] + 0.0722 * linearRGB[2];
}

function getContrastRatio(color1, color2) {
  const lum1 = getLuminance(color1);
  const lum2 = getLuminance(color2);
  const lighterLum = Math.max(lum1, lum2);
  const darkerLum = Math.min(lum1, lum2);
  return (lighterLum + 0.05) / (darkerLum + 0.05);
}

function rgbStringToHex(rgbString) {
  if (!rgbString || !rgbString.startsWith('rgb')) return null;
  const rgb = rgbString.match(/\d+/g);
  if (!rgb || rgb.length < 3) return null;
  const [r, g, b] = rgb.map(Number);
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
}

// This function is now obsolete. The new `applyTheme` engine generates
// accessible themes by design, making this after-the-fact check unnecessary.
// function checkAllElementsContrast() { ... }


// New helper function to adjust the lightness of a color
function adjustColor(hex, percent) {
  const f = parseInt(hex.slice(1), 16),
    t = percent < 0 ? 0 : 255,
    p = percent < 0 ? percent * -1 : percent,
    R = f >> 16,
    G = (f >> 8) & 0x00FF,
    B = f & 0x0000FF;
  return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
}

function getContrastingTextColor(hexcolor) {
  if (!hexcolor) {
    // Return a default set of colors if no hex color is provided
    return {
      '--text-color-primary': 'var(--text-color-dark-primary)',
      '--text-color-secondary': 'var(--text-color-dark-secondary)',
      '--text-color-tertiary': 'var(--text-color-dark-tertiary)',
      '--text-color-quaternary': 'var(--text-color-dark-quaternary)',
      '--text-shadow': 'none'
    };
  }

  const black = '#000000';
  const white = '#FFFFFF';

  const contrastWithBlack = getContrastRatio(hexcolor, black);
  const contrastWithWhite = getContrastRatio(hexcolor, white);

  // Choose the text color with the highest contrast
  const primaryTextColor = contrastWithWhite > contrastWithBlack ? white : black;
  // The background is considered "dark" if white text provides better contrast
  const isBgDark = primaryTextColor === white;

  // When text is white (on dark bg), we want to make it darker (more gray) for secondary shades.
  // When text is black (on light bg), we want to make it lighter (more gray) for secondary shades.
  const adjustDirection = isBgDark ? -1 : 1;

  const shades = {
    '--text-color-primary': primaryTextColor,
    '--text-color-secondary': adjustColor(primaryTextColor, adjustDirection * 0.25), // 75%
    '--text-color-tertiary': adjustColor(primaryTextColor, adjustDirection * 0.45),  // 55%
    '--text-color-quaternary': adjustColor(primaryTextColor, adjustDirection * 0.60),// 40%
  };

  // Add a text shadow for colors with poor contrast against both black and white
  const maxContrast = Math.max(contrastWithWhite, contrastWithBlack);
  if (maxContrast < 4.5) { // If even the best option is poor, add a shadow
    const shadowColor = isBgDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
    shades['--text-shadow'] = `0 0 5px ${shadowColor}`;
  } else {
    shades['--text-shadow'] = 'none';
  }

  return shades;
}
function hexToRgb(hex) {
  let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}
function rgbToHex(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
}
function interpolateColor(color1, color2, factor) {
  let rgb1 = hexToRgb(color1);
  let rgb2 = hexToRgb(color2);
  if (!rgb1 || !rgb2) return color1; // Fallback

  let result = {
    r: Math.round(rgb1.r + factor * (rgb2.r - rgb1.r)),
    g: Math.round(rgb1.g + factor * (rgb2.g - rgb1.g)),
    b: Math.round(rgb1.b + factor * (rgb2.b - rgb1.b))
  };
  return rgbToHex(result.r, result.g, result.b);
}
function interpolateFiveColors(percent) {
  const colors = [statusColors.black, statusColors.red, statusColors.yellow, statusColors.green, statusColors.blue];
  if (percent <= 0) return colors[0];
  if (percent >= 1) return colors[4];

  const scaledPercent = percent * 4; // Scale to 0-4 range
  const colorIndex = Math.floor(scaledPercent);
  const factor = scaledPercent - colorIndex;

  const interpolatedHex = interpolateColor(colors[colorIndex], colors[colorIndex + 1], factor);

  // Adjust lightness to prevent colors from becoming too pale, ensuring text contrast.
  const hsl = hexToHSL(interpolatedHex);
  hsl.l = Math.max(25, Math.min(hsl.l, 85)); // Clamp lightness between 25% and 85%
  return HSLToHex(hsl.h, hsl.s, hsl.l);
}
function getDueDateGroup(dueDate) {
  if (!dueDate || isNaN(dueDate)) return { name: 'Unscheduled', index: 17 };

  const now = new Date();
  const diffMs = dueDate.getTime() - now.getTime();

  if (diffMs <= 0) return { name: 'Overdue', index: 0 };
  if (diffMs <= MS_PER_HOUR) return { name: 'Next Hour', index: 1 };
  if (diffMs <= MS_PER_HOUR * 4) return { name: 'Next 4 Hours', index: 2 };
  if (diffMs <= MS_PER_HOUR * 8) return { name: 'Next 8 Hours', index: 3 };

  const endOfDay = new Date(now);
  endOfDay.setHours(23, 59, 59, 999);
  if (dueDate <= endOfDay) return { name: 'End of Day', index: 4 };

  const tomorrow = new Date(now);
  tomorrow.setDate(now.getDate() + 1);
  tomorrow.setHours(23, 59, 59, 999);
  if (dueDate <= tomorrow) return { name: 'Tomorrow', index: 5 };

  const endOfWeek = new Date(now);
  // Sunday is day 0. If today is Sunday, we want today. If Monday (1), we want 6 days from now to get to next Sunday.
  endOfWeek.setDate(now.getDate() + (7 - now.getDay()) % 7);
  endOfWeek.setHours(23, 59, 59, 999);
  if (dueDate <= endOfWeek) return { name: 'End of Week', index: 6 };

  const endOfNextWeek = new Date(endOfWeek);
  endOfNextWeek.setDate(endOfWeek.getDate() + 7);
  if (dueDate <= endOfNextWeek) return { name: 'Next Week', index: 7 };

  const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
  if (dueDate <= endOfMonth) return { name: 'End of Month', index: 8 };

  const quarter = Math.floor(now.getMonth() / 3);
  const endOfQuarter = new Date(now.getFullYear(), quarter * 3 + 3, 0, 23, 59, 59, 999);
  if (dueDate <= endOfQuarter) return { name: 'This Quarter', index: 9 };

  const next6Months = new Date(now);
  next6Months.setMonth(now.getMonth() + 6);
  if (dueDate <= next6Months) return { name: 'Next 6 Months', index: 10 };

  const endOfYear = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
  if (dueDate <= endOfYear) return { name: 'End of Year', index: 11 };

  const endOfNextYear = new Date(now.getFullYear() + 1, 11, 31, 23, 59, 59, 999);
  if (dueDate <= endOfNextYear) return { name: 'Next Year', index: 12 };

  const endOf5Years = new Date(now.getFullYear() + 5, 11, 31, 23, 59, 59, 999);
  if (dueDate <= endOf5Years) return { name: '5 Years', index: 13 };

  const endOf10Years = new Date(now.getFullYear() + 10, 11, 31, 23, 59, 59, 999);
  if (dueDate <= endOf10Years) return { name: '10 Years', index: 14 };

  const endOf20Years = new Date(now.getFullYear() + 20, 11, 31, 23, 59, 59, 999);
  if (dueDate <= endOf20Years) return { name: '20 Years', index: 15 };

  return { name: 'Lifetime', index: 16 };
}

function updateAdaptiveSensitivity() {
  if (!sensitivitySettings.isAdaptive) return;

  const now = new Date();
  const sevenDaysFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

  const taskLoad = tasks.filter(t => {
    if (!t.dueDate || t.completed) return false;
    const dueDate = new Date(t.dueDate);
    return dueDate > now && dueDate <= sevenDaysFromNow;
  }).length;

  const minLoad = 70;
  const maxLoad = 490;

  let calculatedS = (taskLoad - minLoad) / (maxLoad - minLoad);
  // Clamp the value
  const newS = Math.max(0.0, Math.min(1.0, calculatedS));

  if (sensitivitySettings.sValue !== newS) {
    sensitivitySettings.sValue = newS;
    saveData();
  }
}

function openCategoryIconConfirmModal(categoryId) {
  const category = categories.find(c => c.id === categoryId);
  if (!category) return;

  // Remove existing modal if any
  const existingModal = document.getElementById('category-icon-confirm-modal');
  if (existingModal) existingModal.remove();

  // Create and append modal
  const modalHtml = categoryIconApplyConfirmModalTemplate(category);
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  const modalElement = document.getElementById('category-icon-confirm-modal');

  const closeModal = () => {
    deactivateModal(modalElement);
    // Use a timeout to allow the fade-out animation to complete before removing the element
    setTimeout(() => modalElement.remove(), 300);
    renderCategoryManager(); // Re-render to show the checkbox in its correct (original or updated) state
  };

  modalElement.addEventListener('click', (e) => {
    const target = e.target.closest('[data-action]');
    if (!target) return;

    const action = target.dataset.action;
    const catId = target.dataset.categoryId;
    const targetCategory = categories.find(c => c.id === catId);


    switch(action) {
    case 'apply-all':
      if (!targetCategory) return;
      targetCategory.applyIconToNewTasks = true;
      const iconToApply = targetCategory.icon;
      // Apply to active tasks
      tasks.forEach(task => {
        if (task.categoryId === catId) {
          task.icon = iconToApply;
        }
      });
      // Apply to archived tasks
      (appState.archivedTasks || []).forEach(task => {
        if (task.categoryId === catId) {
          task.icon = iconToApply;
        }
      });
      // Apply to historical tasks
      appState.historicalTasks.forEach(h => {
        if (h.categoryId === catId) {
          h.icon = iconToApply;
        }
      });
      saveData();
      renderTasks();
      if (calendar) calendar.refetchEvents();
      initialFormState = getFormState(taskForm);
    closeModal();
      break;
    case 'apply-future':
      if (!targetCategory) return;
      targetCategory.applyIconToNewTasks = true;
      saveData();
      initialFormState = getFormState(taskForm);
    closeModal(); // This will re-render the manager
      break;
    case 'cancel':
      // The category's state was never changed, so we just close the modal.
      initialFormState = getFormState(taskForm);
    closeModal();
      break;
    }

  });

  activateModal(modalElement);
}


function getSensitivityParameters() {
  let s = sensitivitySettings.sValue;

  // This calculation is now done in updateAdaptiveSensitivity
  // and the value is stored. We just use it here.

  const yellowWindow = 16 + s * (1176 - 16); // in hours
  const yellowBuffer = 2 + s * (10 - 2);
  const redBuffer = 1 + s * (5 - 1);
  const missRatio = 0.50 - s * (0.50 - 0.10);

  return {
    yellowWindowMs: yellowWindow * MS_PER_HOUR,
    yellowBuffer,
    redBuffer,
    missRatio
  };
}

function parseIconString(input) {
  if (!input || typeof input !== 'string') {
    return { icon: null, name: 'No Icon', isTextIcon: false };
  }

  const trimmedInput = input.trim();
  const faRegex = /^(fa-[a-z]+)\s+(fa-[a-z0-9-]+)/;
  const faMatch = trimmedInput.match(faRegex);

  // Case 1: Font Awesome icon with optional custom name
  if (faMatch) {
    const iconClass = `${faMatch[1]} ${faMatch[2]}`;
    let name = trimmedInput.substring(iconClass.length).trim();
    if (!name) {
      name = faMatch[2].replace('fa-', '').replace(/-/g, ' ');
      name = name.charAt(0).toUpperCase() + name.slice(1);
    }
    return { icon: iconClass, name: name.substring(0, 50), isTextIcon: false };
  }

  // Regex to detect emojis
  const emojiRegex = /(\p{Emoji_Presentation}|\p{Extended_Pictographic})/gu;
  const emojis = [...trimmedInput.matchAll(emojiRegex)].map(m => m[0]);

  // Case 2: Emoji(s) with optional text
  if (emojis.length > 0) {
    const icon = emojis.slice(0, 2).join('');
    // The name is the full string, which could be just emojis or emojis and text
    return { icon: icon, name: trimmedInput.substring(0, 50), isTextIcon: true };
  }

  // Case 3: Plain text
  const icon = trimmedInput.substring(0, 2);
  return { icon: icon, name: trimmedInput.substring(0, 50), isTextIcon: true };
}


function gpaToLetterGrade(gpa) {
  if (appSettings.gpaSystem === 'extended') {
    if (gpa === 4.0) return 'S+';
    if (gpa >= 3.7) return 'S';
    if (gpa >= 3.5) return 'S-';
    if (gpa >= 3.2) return 'A+';
    if (gpa >= 2.8) return 'A';
    if (gpa >= 2.5) return 'A-';
    if (gpa >= 2.2) return 'B+';
    if (gpa >= 1.8) return 'B';
    if (gpa >= 1.5) return 'B-';
    if (gpa >= 1.2) return 'C+';
    if (gpa >= 0.8) return 'C';
    if (gpa >= 0.5) return 'C-';
    if (gpa >= 0.2) return 'D';
    if (gpa > 0) return 'D-';
    return 'F';
  } else { // Standard
    if (gpa >= 4.0) return 'A+';
    if (gpa >= 3.7) return 'A';
    if (gpa >= 3.3) return 'A-';
    if (gpa >= 3.0) return 'B+';
    if (gpa >= 2.7) return 'B';
    if (gpa >= 2.3) return 'B-';
    if (gpa >= 2.0) return 'C+';
    if (gpa >= 1.7) return 'C';
    if (gpa >= 1.3) return 'C-';
    if (gpa >= 1.0) return 'D+';
    if (gpa >= 0.7) return 'D';
    if (gpa > 0) return 'D-';
    return 'F';
  }
}


function processTaskHistoryForChart(task, history) {
  if ((!history || history.length === 0) && !task) {
    return { labels: [], completions: [], misses: [] };
  }

  // 1. Group history items by day
  const dailyData = new Map();
  if (history) {
    history.forEach(item => {
      const date = new Date(item.completionDate);
      if (isNaN(date)) return;

      const dayKey = format(date, 'yyyy-MM-dd');
      if (!dailyData.has(dayKey)) {
        dailyData.set(dayKey, { completions: 0, misses: 0 });
      }
      const stats = dailyData.get(dayKey);
      const completionStatuses = ['blue', 'green', 'yellow'];
      if (completionStatuses.includes(item.status)) {
        stats.completions++;
      } else {
        stats.misses++;
      }
    });
  }

  // 2. Determine the date range for the chart
  const today = new Date();
  let chartStartDate;
  if (history && history.length > 0) {
    chartStartDate = new Date(history.reduce((min, h) => Math.min(min, new Date(h.completionDate).getTime()), Date.now()));
  } else {
    chartStartDate = new Date(task.createdAt || today);
  }
  chartStartDate.setHours(0,0,0,0);


  let lastEventDate;
  if (history && history.length > 0) {
    lastEventDate = new Date(history.reduce((max, h) => Math.max(max, new Date(h.completionDate).getTime()), 0));
  } else {
    lastEventDate = today;
  }
  const chartEndDate = today > lastEventDate ? today : lastEventDate;
  chartEndDate.setHours(23,59,59,999);


  // 3. Decide on the X-axis generation strategy
  const repetitionIntervalMs = (task && task.repetitionType === 'relative') ? getDurationMs(task.repetitionAmount, task.repetitionUnit) : 0;
  const isSparse = (task && task.repetitionType === 'absolute') || repetitionIntervalMs > MS_PER_DAY;

  let labels = [];
  if (isSparse && task.repetitionType !== 'none') {
    const occurrences = getOccurrences(task, chartStartDate, chartEndDate);
    labels = occurrences.map(d => format(d, 'yyyy-MM-dd'));
    const todayKey = format(today, 'yyyy-MM-dd');
    if (!labels.includes(todayKey) && chartEndDate.toDateString() === today.toDateString()) {
      labels.push(todayKey);
      labels.sort();
    }
  } else {
    let currentDate = new Date(chartStartDate);
    while (currentDate <= chartEndDate) {
      labels.push(format(currentDate, 'yyyy-MM-dd'));
      currentDate.setDate(currentDate.getDate() + 1);
    }
  }

  if (labels.length === 0 && task) {
    labels.push(format(today, 'yyyy-MM-dd'));
  }

  // 4. Populate datasets based on labels
  const completions = [];
  const misses = [];
  labels.forEach(label => {
    const dataForDay = dailyData.get(label) || { completions: 0, misses: 0 };
    completions.push(dataForDay.completions);
    misses.push(dataForDay.misses);
  });

  if (history && history.length === 0 && task) {
    const todayKey = format(new Date(), 'yyyy-MM-dd');
    if (!labels.includes(todayKey)) {
      labels.push(todayKey);
      completions.push(0);
      misses.push(0);
    }
  }

  return { labels, completions, misses };
}


// --- Theming Engine Functions ---

function hexToHSL(H) {
  let r = 0, g = 0, b = 0;
  if (H.length == 4) {
    r = '0x' + H[1] + H[1]; g = '0x' + H[2] + H[2]; b = '0x' + H[3] + H[3];
  } else if (H.length == 7) {
    r = '0x' + H[1] + H[2]; g = '0x' + H[3] + H[4]; b = '0x' + H[5] + H[6];
  }
  r /= 255; g /= 255; b /= 255;
  let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0, s = 0, l = 0;
  if (delta == 0) h = 0;
  else if (cmax == r) h = ((g - b) / delta) % 6;
  else if (cmax == g) h = (b - r) / delta + 2;
  else h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0) h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return { h, s, l };
}

function HSLToHex(h, s, l) {
  s /= 100; l /= 100;
  let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c/2, r = 0, g = 0, b = 0;
  if (0 <= h && h < 60) { r = c; g = x; b = 0; }
  else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
  else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
  else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
  else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
  else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
  r = Math.round((r + m) * 255).toString(16);
  g = Math.round((g + m) * 255).toString(16);
  b = Math.round((b + m) * 255).toString(16);
  if (r.length == 1) r = '0' + r;
  if (g.length == 1) g = '0' + g;
  if (b.length == 1) b = '0' + b;
  return '#' + r + g + b;
}

function generateGradientPalette(baseColor, isDarkMode) {
  const baseHSL = hexToHSL(baseColor);

  // Stop reversal is removed. The direction of the gradient will be handled in applyTheme.
  const stops = [
    { l: -45, s: 0 },   // Black
    { l: -30, s: 25 },  // Red
    { l: -15, s: 15 },  // Yellow
    { l: 0, s: 0 },     // Green (base)
    { l: 15, s: 10 }    // Blue
  ];

  const palette = {
    black:  HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + stops[0].s), Math.max(0, Math.min(100, baseHSL.l + stops[0].l))),
    red:    HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + stops[1].s), Math.max(0, Math.min(100, baseHSL.l + stops[1].l))),
    yellow: HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + stops[2].s), Math.max(0, Math.min(100, baseHSL.l + stops[2].l))),
    green:  HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + stops[3].s), Math.max(0, Math.min(100, baseHSL.l + stops[3].l))),
    blue:   HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + stops[4].s), Math.max(0, Math.min(100, baseHSL.l + stops[4].l))),
  };

  return palette;
}

function generateComplementaryPalette(baseColor, isDarkMode) {
  const baseHSL = hexToHSL(baseColor);
  const clamp = (val, min, max) => Math.min(max, Math.max(min, val));

  let mainBgLightness;
  if (isDarkMode) {
    mainBgLightness = baseHSL.l > 50 ? 20 : Math.max(10, baseHSL.l - 10);
  } else {
    mainBgLightness = baseHSL.l < 70 ? 95 : Math.min(100, baseHSL.l + 20);
  }
  const main = HSLToHex(baseHSL.h, clamp(baseHSL.s * 0.8, 0, 100), mainBgLightness);

  const secondaryLightness = isDarkMode ? Math.max(40, baseHSL.l) : Math.min(60, baseHSL.l);
  const secondary = HSLToHex(baseHSL.h, clamp(baseHSL.s, 0, 100), secondaryLightness);

  const tertiaryHue = (baseHSL.h + 150) % 360;
  const tertiaryLightness = isDarkMode ? Math.max(50, baseHSL.l) : Math.min(55, baseHSL.l);
  const tertiary = HSLToHex(tertiaryHue, clamp(baseHSL.s * 1.1, 0, 100), tertiaryLightness);

  const accent1 = HSLToHex((baseHSL.h + 60) % 360, clamp(baseHSL.s - 10, 0, 100), isDarkMode ? 60 : 40);
  const accent2 = HSLToHex((baseHSL.h + 180) % 360, clamp(baseHSL.s - 10, 0, 100), isDarkMode ? 65 : 35);
  const accent3 = HSLToHex((baseHSL.h + 300) % 360, clamp(baseHSL.s, 0, 100), isDarkMode ? 55 : 45);

  const secondarySelectedLightness = isDarkMode ? secondaryLightness + 10 : secondaryLightness - 10;
  const secondary_highlight = HSLToHex(baseHSL.h, clamp(baseHSL.s, 0, 100), clamp(secondarySelectedLightness, 0, 100));
  const secondary_selected = `linear-gradient(to bottom, ${secondary}, ${secondary_highlight})`;

  // A more pronounced gradient for the "Theme Spectrum" option, respecting the light source direction.
  const main_gradient = `linear-gradient(to bottom, ${main}, ${secondary})`;

  return { main, secondary, tertiary, accent1, accent2, accent3, secondary_selected, main_gradient };
}

function applyThemeMode(effectiveMode) {
  document.body.classList.remove('light-mode', 'auto-theme');
  if (effectiveMode === 'light') {
    document.body.classList.add('light-mode');
  }
  // For 'night' mode, no class is needed as it's the default. 'auto-theme' is now handled by JS.
}

function setAppBranding() {
  const { title, subtitle, weeklyGoalLabel } = appSettings;

  // Set document title
  document.title = title || 'Task & Mission Planner';

  // Set header title
  const headerTitle = document.querySelector('#app header h1');
  if (headerTitle) {
    headerTitle.textContent = title || 'Task & Mission Planner';
  }

  // Set header subtitle
  const headerSubtitle = document.querySelector('#app header p');
  if (headerSubtitle) {
    headerSubtitle.textContent = subtitle || 'Organize your tasks, plan your week, and track your progress.';
  }

  // Set weekly goal label on the dashboard
  const goalLabel = document.getElementById('weekly-goal-label');
  if (goalLabel) {
    goalLabel.textContent = weeklyGoalLabel || 'Mission/Goals for this Week';
  }

  saveData();
}

function applyTheme() {
  // Determine the effective mode (light/night) based on user settings
  let effectiveMode = theming.mode;
  if (theming.mode === 'auto') {
    const isSystemDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    effectiveMode = isSystemDark ? 'night' : 'light';
  }
  const isDarkMode = effectiveMode === 'night';
  applyThemeMode(effectiveMode); // Apply .light-mode class if needed

  // First, determine which status colors are active for this render cycle.
  const activeStatusColors = (theming.enabled && theming.useThemeForStatus)
    ? generateGradientPalette(theming.baseColor, isDarkMode)
    : { ...defaultStatusColors };

  // Update the global statusColors object so all other functions use the correct set.
  statusColors = activeStatusColors;

  // Generate a subtle background color from the base theme color
  const baseHSL = hexToHSL(theming.baseColor);
  const mainBgLightness = isDarkMode ? 8 : 97; // Very dark (8%) or very light (97%)
  const mainBgSaturation = isDarkMode ? baseHSL.s * 0.4 : baseHSL.s * 0.6; // Desaturate for subtlety
  const subtleBgColor = HSLToHex(baseHSL.h, Math.min(100, Math.max(0, mainBgSaturation)), mainBgLightness);

  // Generate color palettes
  const palette = generateComplementaryPalette(theming.baseColor, isDarkMode);

  // --- Gradient Logic ---
  const gradientDirection = isDarkMode ? 'to top' : 'to bottom';

  // 1. Status Spectrum Gradient
  // The initial order from the palette function is dark-to-light. We reverse it to get light-to-dark.
  const statusColorsForGradient = [activeStatusColors.black, activeStatusColors.red, activeStatusColors.yellow, activeStatusColors.green, activeStatusColors.blue];
  statusColorsForGradient.reverse(); // Now it's always [blue, green, yellow, red, black] (light to dark)
  const statusGradient = `linear-gradient(${gradientDirection}, ${statusColorsForGradient.join(', ')})`;

  // 2. Theme Gradient
  // The theme gradient also respects the light source direction.
  const themeGradient = `linear-gradient(${gradientDirection}, ${palette.main}, ${palette.secondary})`;

  let activeGradient;
  if (theming.calendarGradientSource === 'theme') {
    activeGradient = themeGradient;
  } else { // 'status' or default
    activeGradient = statusGradient;
  }

  const calendarBorderGradient = theming.enabled ? activeGradient : 'transparent';
  const chartBgColor = theming.enabled ? (isDarkMode ? '#1F2937' : '#FFFFFF') : (isDarkMode ? '#1F2937' : '#FFFFFF'); // gray-800 or white

  // Define theme properties
  const themeProperties = {
    // Use the new subtle theme color for the main background for a more cohesive look.
    '--bg-main': theming.enabled ? subtleBgColor : (isDarkMode ? '#111827' : '#F9FAFB'),
    '--bg-secondary': isDarkMode ? '#1F2937' : '#FFFFFF',   // e.g., gray-800 | white
    '--bg-chart': chartBgColor,
    '--chart-gradient-border': theming.enabled ? activeGradient : 'transparent',

    // Modals and interactive elements can retain the theme color for accent.
    '--bg-modal': theming.enabled ? palette.main : (isDarkMode ? '#2d3748' : '#FFFFFF'),
    '--bg-calendar-border': calendarBorderGradient,
    '--bg-calendar-header': theming.enabled ? adjustColor(palette.secondary, isDarkMode ? -0.2 : -0.2) : (isDarkMode ? '#111827' : '#E5E7EB'),
    '--bg-input': isDarkMode ? '#374151' : '#FFFFFF',
    // Use a slightly lighter/darker shade for journal entries to make them stand out
    '--bg-journal-entry': isDarkMode ? '#2d3748' : '#F9FAFB',

    '--btn-primary-bg': theming.enabled ? palette.secondary : (isDarkMode ? '#4B5563' : '#E5E7EB'),
    '--btn-secondary-bg': theming.enabled ? palette.tertiary : (isDarkMode ? '#374151' : '#D1D5DB'),
    '--btn-tertiary-bg': theming.enabled ? palette.accent1 : (isDarkMode ? '#4A5568' : '#9CA3AF'),
    '--btn-confirm-bg': theming.enabled ? palette.accent2 : '#22C55E', // Green-500
    '--btn-deny-bg': theming.enabled ? palette.accent3 : '#EF4444', // Red-500

    '--text-color-on-primary': getContrastingTextColor(theming.enabled ? palette.secondary : (isDarkMode ? '#4B5563' : '#E5E7EB'))['--text-color-primary'],
    '--text-color-on-secondary': getContrastingTextColor(theming.enabled ? palette.tertiary : (isDarkMode ? '#374151' : '#D1D5DB'))['--text-color-primary'],
    '--text-color-on-tertiary': getContrastingTextColor(theming.enabled ? palette.accent1 : (isDarkMode ? '#4A5568' : '#9CA3AF'))['--text-color-primary'],
    '--text-color-on-confirm': getContrastingTextColor(theming.enabled ? palette.accent2 : '#22C55E')['--text-color-primary'],
    '--text-color-on-deny': getContrastingTextColor(theming.enabled ? palette.accent3 : '#EF4444')['--text-color-primary'],
    '--text-color-on-input': getContrastingTextColor(isDarkMode ? '#374151' : '#FFFFFF')['--text-color-primary'],


    '--border-color-primary': isDarkMode ? '#4A5568' : '#D1D5DB',
    '--border-color-secondary': isDarkMode ? '#374151' : '#E5E7EB',
    '--focus-ring-color': theming.enabled ? palette.tertiary : '#63B3ED',
    '--toggle-peg-color': isDarkMode ? '#FFFFFF' : '#1F2937', // White in dark mode, gray-800 in light
  };

  // Calculate main text styles and add them to the root properties for global availability
  const mainTextStyles = getContrastingTextColor(themeProperties['--bg-main']);
  Object.assign(themeProperties, mainTextStyles);


  // Generate CSS rules string
  let css = ':root {\n';
  for (const [key, value] of Object.entries(themeProperties)) {
    css += `  ${key}: ${value};\n`;
  }
  css += '}\n\n';

  // Add rules for button states
  const buttonTypes = ['primary', 'secondary', 'tertiary', 'confirm', 'deny'];
  buttonTypes.forEach(type => {
    const baseBgVar = `--btn-${type}-bg`;
    const baseBg = themeProperties[baseBgVar];
    if (!baseBg) return;
    const hsl = hexToHSL(baseBg);
    const hoverBg = HSLToHex(hsl.h, hsl.s, Math.max(0, Math.min(100, hsl.l + (isDarkMode ? 5 : -5))));
    const activeBg = HSLToHex(hsl.h, hsl.s, Math.max(0, Math.min(100, hsl.l + (isDarkMode ? 8 : -8))));

    css += `
            .btn-${type} {
                background-color: var(${baseBgVar});
                color: var(--text-color-on-${type});
            }
            .btn-${type}:hover {
                background-color: ${hoverBg};
            }
            .btn-${type}:active, .btn-${type}.active-view-btn {
                background-color: ${activeBg};
            }
        `;
  });

  // Add rules for backgrounds and text
  css += `
        body.bg-main {
            background: var(--bg-main);
            color: var(--text-color-primary);
        }
        .bg-secondary {
            background-color: var(--bg-secondary);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.06);
        }
        .bg-modal {
            background: var(--bg-modal);
        }
        .fc-col-header-cell {
            background-color: var(--bg-calendar-header) !important;
        }
        .journal-entry {
            background-color: var(--bg-journal-entry);
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--border-color-secondary);
        }
        input, textarea, select {
            background-color: var(--bg-input) !important;
            color: var(--text-color-on-input) !important;
            border: 1px solid var(--border-color-primary) !important;
        }
        .collapsible-section {
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .collapsible-header {
            background-color: var(--bg-secondary);
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .collapsible-header i {
            transition: transform 0.3s ease-in-out;
        }
        .collapsible-content {
            background-color: var(--bg-main);
            padding: 0 1rem; /* No padding when collapsed */
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
        }
        .collapsible-section.open .collapsible-header i {
            transform: rotate(180deg);
        }
        .collapsible-section.open .collapsible-content {
            max-height: 1500px; /* A generous height to ensure content is not clipped, avoids vh conflict inside modal */
            padding: 1rem;
        }
        .gradient-bordered-content {
            background: var(--chart-gradient-border);
            padding: 14px;
            border-radius: 0.5rem;
        }
        .gradient-bordered-content > canvas {
            background-color: var(--bg-chart);
            border-radius: 0.25rem; /* Inner radius for the chart itself */
        }

        #advanced-options-content fieldset {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        /* Styles for month view events */
        .month-view-event-item {
            display: flex;
            align-items: center;
            gap: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
            font-size: 0.75rem;
        }
        .month-view-icon {
            /* The icon color is now set by the textColor property of the event */
            flex-shrink: 0;
        }
        .month-view-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

    `;

  // Inject styles into the document head
  const styleSheet = document.getElementById('dynamic-theme-styles');
  if (styleSheet) {
    styleSheet.textContent = css;
  }

  // Re-render components that depend on theme changes
  renderTasks();
  if (calendar) {
    calendar.refetchEvents();
    calendar.updateSize();
  }
}





// =================================================================================
// S-3.0: UI RENDERING FUNCTIONS
// =================================================================================
function stopAllTimers() {
  stopAllCountdownTimers();
  Object.keys(taskTimers).forEach(taskId => stopTaskTimer(taskId));
}
function stopCountdownTimer(taskId) {
  if (countdownIntervals[taskId]) {
    clearTimeout(countdownIntervals[taskId]);
    delete countdownIntervals[taskId];
  }
}
function stopAllCountdownTimers() {
  Object.values(countdownIntervals).forEach(timeoutId => clearTimeout(timeoutId));
  countdownIntervals = {};
}
function stopTaskTimer(taskId) {
  if (taskTimers[taskId]) {
    clearTimeout(taskTimers[taskId]);
    delete taskTimers[taskId];
  }
}

function startAllTaskTimers() {
  tasks.forEach(task => {
    if (task.isTimerRunning) {
      startTimerInterval(task.id);
    }
  });
}

function renderTasks() {
  stopAllTimers();
  taskListDiv.innerHTML = '';
  console.log('--- renderTasks ---');
  console.log('Initial tasks:', JSON.parse(JSON.stringify(tasks)));
  const filteredTasks = tasks.filter(task => {
    if (categoryFilter.length === 0) return true;
    if (!task.categoryId) return categoryFilter.includes(null);
    return categoryFilter.includes(task.categoryId);
  });
  console.log('Filtered tasks:', JSON.parse(JSON.stringify(filteredTasks)));
  if (filteredTasks.length === 0) {
    taskListDiv.innerHTML = '<p class="text-gray-500 text-center italic">No tasks match the current filter.</p>';
    return;
  }
  const statusOrder = { 'black': 0, 'red': 1, 'yellow': 2, 'green': 3, 'blue': 4 };

  const sortedTasks = filteredTasks.sort((a, b) => {
    const completedA = a.repetitionType === 'none' && a.completed;
    const completedB = b.repetitionType === 'none' && b.completed;
    if (completedA && !completedB) return 1;
    if (!completedA && completedB) return -1;
    let comparison = 0;
    if (sortBy === 'status') {
      comparison = (statusOrder[a.status] ?? 5) - (statusOrder[b.status] ?? 5);
    } else if (sortBy === 'dueDate') {
      const getDateValue = (task) => {
        if (!task.dueDate) return Infinity;
        let date = new Date(task.dueDate);
        if (uiSettings.useStartDateForSort) {
          const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
          date = new Date(date.getTime() - durationMs);
        }
        return date.getTime();
      };
      const dateA = getDateValue(a);
      const dateB = getDateValue(b);
      comparison = dateA - dateB;
    } else if (sortBy === 'category') {
      const categoryA = categories.find(c => c.id === a.categoryId)?.name || 'Uncategorized';
      const categoryB = categories.find(c => c.id === b.categoryId)?.name || 'Uncategorized';
      comparison = categoryA.localeCompare(categoryB);
    }
    if (comparison === 0) {
      const dueDateA = a.dueDate ? a.dueDate.getTime() : Infinity;
      const dueDateB = b.dueDate ? b.dueDate.getTime() : Infinity;
      comparison = dueDateA - dueDateB;
    }
    return sortDirection === 'asc' ? comparison : -comparison;
  });

  const renderTaskItem = (task, groupName) => {
    const taskElement = document.createElement('div');
    const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;

    taskElement.className = 'task-item p-2 rounded-lg shadow flex justify-between items-start';
    taskElement.dataset.taskId = task.id;
    taskElement.dataset.action = 'viewTask'; // Make the whole card clickable
    taskElement.dataset.status = task.status;
    if (groupName) {
      taskElement.dataset.group = groupName;
    }
    taskElement.dataset.confirming = !!task.confirmationState;

    const statusColor = statusColors[task.status] || statusColors.green;
    taskElement.style.backgroundColor = statusColor;
    const category = categories.find(c => c.id === task.categoryId);
    const categoryColor = category ? category.color : 'transparent';
    taskElement.style.borderLeft = `5px solid ${categoryColor}`;

    // Apply the full suite of text color variables to the task element
    const textStyles = getContrastingTextColor(statusColor);
    for (const [key, value] of Object.entries(textStyles)) {
      taskElement.style.setProperty(key, value);
    }

    if (isCompletedNonRepeating) taskElement.classList.add('task-completed');
    if (task.confirmationState === 'confirming_delete') taskElement.classList.add('task-confirming-delete');

    // The template will now inherit the CSS variables set on taskElement
    taskElement.innerHTML = taskTemplate(task, { categories, taskDisplaySettings, appSettings });

    taskListDiv.appendChild(taskElement);

    const actionArea = taskElement.querySelector(`#action-area-${task.id}`);
    const commonButtonsArea = taskElement.querySelector(`#common-buttons-${task.id}`);
    if (actionArea) actionArea.innerHTML = actionAreaTemplate(task);
    if (commonButtonsArea) commonButtonsArea.innerHTML = commonButtonsTemplate(task);
    return taskElement;
  };

  if (!uiSettings.taskManagerCollapseState) {
    uiSettings.taskManagerCollapseState = {};
  }

  const renderGroup = (groupName, tasksInGroup, color, styleString) => {
    const isCollapsed = uiSettings.taskManagerCollapseState[groupName] === true;
    taskListDiv.insertAdjacentHTML('beforeend', taskGroupHeaderTemplate(groupName, color, styleString, isCollapsed));
    tasksInGroup.forEach(task => {
      const taskElement = renderTaskItem(task, groupName);
      if (isCollapsed) {
        taskElement.classList.add('hidden');
      }
    });
  };

  if (sortBy === 'dueDate') {
    const groupedByDate = {};
    sortedTasks.forEach(task => {
      let dateForGrouping = task.dueDate ? new Date(task.dueDate) : null;
      if (uiSettings.useStartDateForSort && dateForGrouping) {
        const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
        dateForGrouping = new Date(dateForGrouping.getTime() - durationMs);
      }
      const group = getDueDateGroup(dateForGrouping);
      if (!groupedByDate[group.index]) {
        groupedByDate[group.index] = { name: group.name, tasks: [] };
      }
      groupedByDate[group.index].tasks.push(task);
    });

    const groupOrder = Object.keys(groupedByDate).sort((a, b) => a - b);
    if (sortDirection === 'desc') groupOrder.reverse();

    groupOrder.forEach((groupIndex, i) => {
      const group = groupedByDate[groupIndex];
      const percent = groupOrder.length <= 1 ? 0 : (sortDirection === 'asc' ? i / (groupOrder.length - 1) : (groupOrder.length - 1 - i) / (groupOrder.length - 1));
      const bgColor = interpolateFiveColors(percent);
      const textStyles = getContrastingTextColor(bgColor);
      const styleString = Object.entries(textStyles).map(([key, value]) => `${key}: ${value};`).join(' ');
      renderGroup(group.name, group.tasks, bgColor, styleString);
    });

  } else { // Handles 'status' and 'category' sorting
    const groupedTasks = {};
    sortedTasks.forEach(task => {
      let groupName = '';
      if (sortBy === 'status') {
        groupName = statusNames[task.status] || task.status;
      } else if (sortBy === 'category') {
        const category = categories.find(c => c.id === task.categoryId);
        groupName = category ? category.name : 'Uncategorized';
      }
      if (!groupedTasks[groupName]) {
        groupedTasks[groupName] = [];
      }
      groupedTasks[groupName].push(task);
    });

    const groupNames = Object.keys(groupedTasks);
    // Custom sort for status
    if (sortBy === 'status') {
      const statusOrder = { 'black': 0, 'red': 1, 'yellow': 2, 'green': 3, 'blue': 4 };
      const statusKeyOrder = Object.keys(statusNames).sort((a,b) => statusOrder[a] - statusOrder[b]);
      groupNames.sort((a, b) => {
        const keyA = Object.keys(statusNames).find(key => statusNames[key] === a);
        const keyB = Object.keys(statusNames).find(key => statusNames[key] === b);
        return statusKeyOrder.indexOf(keyA) - statusKeyOrder.indexOf(keyB);
      });

    } else { // Default alphabetical sort for categories
      groupNames.sort((a, b) => a.localeCompare(b));
    }


    if (sortDirection === 'desc') groupNames.reverse();


    groupNames.forEach(groupName => {
      const tasksInGroup = groupedTasks[groupName];
      let groupColor = '#e5e7eb';

      if (sortBy === 'status') {
        const statusKey = Object.keys(statusNames).find(key => statusNames[key] === groupName);
        groupColor = statusColors[statusKey] || '#e5e7eb';
      } else if (sortBy === 'category') {
        const category = categories.find(c => c.name === groupName);
        groupColor = category ? category.color : '#FFFFFF';
      }
      const textStyles = getContrastingTextColor(groupColor);
      const styleString = Object.entries(textStyles).map(([key, value]) => `${key}: ${value};`).join(' ');
      renderGroup(groupName, tasksInGroup, groupColor, styleString);
    });
  }

  startAllCountdownTimers();
  startAllTaskTimers();
}

function formatTimeRemaining(ms) {
  try {
    if (ms <= DUE_THRESHOLD_MS && ms > -DUE_THRESHOLD_MS) return 'Due!';
    const isOverdue = ms < 0;
    const absMs = Math.abs(ms);
    const s = Math.floor(absMs / 1000) % 60;
    const m = Math.floor(absMs / MS_PER_MINUTE) % 60;
    const h = Math.floor(absMs / MS_PER_HOUR) % 24;
    const d = Math.floor(absMs / MS_PER_DAY);
    let parts = [];
    if (d > 0) parts.push(`${d} day${d > 1 ? 's' : ''}`);
    if (h > 0) parts.push(`${h} hr${h > 1 ? 's' : ''}`);
    if ((d === 0 || parts.length < 2) && m > 0) parts.push(`${m} min${m > 1 ? 's' : ''}`);
    if (d === 0 && h === 0 && (parts.length < 2 || m === 0) && s > 0) parts.push(`${s} sec${s > 1 ? 's' : ''}`);
    const timeStr = parts.slice(0, 2).join(' ') || (isOverdue ? 'just now' : 'Less than a minute');
    return isOverdue ? `Overdue by: ${timeStr}` : timeStr;
  } catch (e) {
    console.error('Error formatting time remaining:', ms, e);
    return 'Error';
  }
}


function updateCountdown(taskId) {
  try {
    const task = tasks.find(t => t.id === taskId);
    const countdownElement = document.getElementById(`countdown-${taskId}`);
    if (!task || !countdownElement) { stopCountdownTimer(taskId); return; }
    if (task.repetitionType === 'none' && task.completed) {
      countdownElement.textContent = '';
      stopCountdownTimer(taskId);
      return;
    }
    const nowMs = Date.now();
    let targetDateMs = null;
    let prefix = '';
    if (task.status === 'blue' && task.cycleEndDate && !isNaN(task.cycleEndDate)) {
      targetDateMs = task.cycleEndDate.getTime();
      prefix = 'Unlocks in: ';
      if (targetDateMs - nowMs <= 0) {
        countdownElement.textContent = '';
        stopCountdownTimer(taskId);
        return;
      }
    } else if (task.dueDate && !isNaN(task.dueDate)) {
      targetDateMs = task.dueDate.getTime();
    } else {
      countdownElement.textContent = '';
      stopCountdownTimer(taskId);
      return;
    }
    const timeRemaining = targetDateMs - nowMs;
    if (task.confirmationState && timeRemaining < 0) prefix = '';
    countdownElement.textContent = prefix + formatTimeRemaining(timeRemaining);
  } catch (e) {
    console.error('Error updating countdown for task:', taskId, e);
    stopCountdownTimer(taskId);
  }
}
function startAllCountdownTimers() {
  stopAllCountdownTimers(); // Clears any existing timeouts

  const scheduleCountdownUpdate = (taskId) => {
    // This function will be called recursively by setTimeout.
    // First, perform the UI update.
    updateCountdown(taskId);

    const task = tasks.find(t => t.id === taskId);
    // Stop the loop if the task is gone, or if it's a non-repeating task that's completed.
    if (!task || (task.repetitionType === 'none' && task.completed)) {
      stopCountdownTimer(taskId);
      return;
    }

    // Calculate the delay to align with the *next* second on the system clock.
    const nowMs = Date.now();
    const delay = 1000 - (nowMs % 1000);

    // Schedule the next update.
    countdownIntervals[taskId] = setTimeout(() => scheduleCountdownUpdate(taskId), delay);
  };

  tasks.forEach(task => {
    try {
      if (task.repetitionType === 'none' && task.completed) return;

      let targetDate = null;
      if (task.status === 'blue' && task.cycleEndDate && !isNaN(task.cycleEndDate)) {
        targetDate = task.cycleEndDate;
      } else if (task.dueDate && !isNaN(task.dueDate)) {
        targetDate = task.dueDate;
      }

      if (targetDate) {
        const timeRemaining = targetDate.getTime() - Date.now();
        // Only start the timer loop if the countdown is relevant.
        if (((task.status === 'blue' && timeRemaining > 0) || task.status !== 'blue') && !countdownIntervals[task.id]) {
          scheduleCountdownUpdate(task.id);
        }
      }
    } catch (e) {
      console.error('Error starting countdown timer for task:', task?.id, e);
    }
  });
}
function activateModal(modalElement) {
  if (!modalElement) return;
  modalElement.classList.add('active');
  document.body.classList.add('modal-open');
}

function deactivateModal(modalElement) {
  if (!modalElement) return;
  modalElement.classList.remove('active');
  document.body.classList.remove('modal-open');
}

function openReinstateTaskModal(taskToReinstate) {
  const taskViewModalEl = document.getElementById('task-view-modal');
  if (taskViewModalEl) deactivateModal(taskViewModalEl);

  let nextDueDate;
  // Try to find the full task data in archives to get repetition rules
  const archivedTask = appState.archivedTasks && appState.archivedTasks.find(t => t.id === taskToReinstate.id);
  const taskForRepetition = archivedTask || taskToReinstate;

  if (taskForRepetition.repetitionType && taskForRepetition.repetitionType !== 'none') {
    const occurrences = getOccurrences(taskForRepetition, new Date(), getCalculationHorizonDate());
    if (occurrences.length > 0) {
      nextDueDate = occurrences[0];
    }
  }

  // Fallback: If no future occurrence is found or it's non-repeating, set it for the next day
  if (!nextDueDate) {
    nextDueDate = new Date(Date.now() + MS_PER_DAY);
  }

  // Set the calculated due date on the object we pass to the modal
  const finalTaskObject = { ...taskToReinstate, dueDate: nextDueDate };

  openModal(null, {
    reinstateTask: finalTaskObject,
    title: 'Reinstate Task?',
    submitText: 'Confirm Reinstatement'
  });
}

function openModal(taskId = null, options = {}) {
  console.log('openModal called with taskId:', taskId, 'and options:', options);
  try {
    if (options.source === 'task-view') {
      modalStack.push({ type: 'task-view', taskId: taskId, occurrenceDate: options.occurrenceDate, source: 'task-manager' });
    }
    taskForm.reset();
    editingTaskId = taskId;
    const reinstateTask = options.reinstateTask;

    // Reset all dynamic fields to their default state
    dueDateGroup.classList.remove('hidden');
    startDateGroup.classList.add('hidden');
    relativeDueDateGroup.classList.add('hidden');
    repetitionRelativeGroup.classList.add('hidden');
    repetitionAbsoluteGroup.classList.add('hidden');
    repeatingOptionsGroup.classList.add('hidden');
    completionCountGroup.classList.add('hidden');
    completionTimeGroup.classList.add('hidden');
    estimatedDurationGroup.classList.remove('hidden');
    newCategoryGroup.classList.add('hidden');

    while (taskCategorySelect.options.length > 2) {
      taskCategorySelect.remove(2);
    }
    categories.forEach(cat => {
      const option = document.createElement('option');
      option.value = cat.id;
      option.textContent = cat.name;
      taskCategorySelect.appendChild(option);
    });

    const submitButton = taskForm.querySelector('button[type="submit"]');


    const allTasks = [...tasks, ...(appState.archivedTasks || [])];
    const taskToLoad = reinstateTask || (taskId ? allTasks.find(t => t.id === taskId) : null);

    if (taskToLoad) {
      const task = taskToLoad; // Use a consistent variable name
      // CRITICAL: For reinstating, we use the original ID. For editing, we use the existing ID.
      taskIdInput.value = task.id;
      modalTitle.textContent = reinstateTask ? (options.title || 'Reinstate Task') : 'Update Task';
      submitButton.textContent = reinstateTask ? (options.submitText || 'Confirm Reinstatement') : 'Update Task';
      taskNameInput.value = task.name;
      taskDescriptionInput.value = task.description || '';
      taskIconInput.value = task.icon || '';

      // Set Time Input Type and corresponding date fields
      timeInputTypeSelect.value = task.timeInputType || 'due';
      const dateToUse = (options.occurrenceDate instanceof Date) ? options.occurrenceDate : (task.dueDate ? new Date(task.dueDate) : null);

      // Always populate the main due date input for simplicity
      taskDueDateInput.value = formatDateForInput(dateToUse);

      // Populate start date if applicable, but visibility is handled later
      if (task.timeInputType === 'start') {
        const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
        const startDate = new Date(dateToUse.getTime() - durationMs);
        taskStartDateInput.value = formatDateForInput(startDate);
      }

      // Show/hide based on saved values
      startDateGroup.classList.toggle('hidden', task.timeInputType !== 'start');

      dueDateTypeSelect.value = task.dueDateType || 'absolute';
      relativeDueDateGroup.classList.toggle('hidden', task.dueDateType !== 'relative');
      if (task.dueDateType === 'relative') {
        relativeAmountInput.value = task.relativeAmount || 1;
        relativeUnitSelect.value = task.relativeUnit || 'days';
      }

      taskRepetitionSelect.value = task.repetitionType || 'none';
      repetitionRelativeGroup.classList.toggle('hidden', task.repetitionType !== 'relative');
      repetitionAbsoluteGroup.classList.toggle('hidden', task.repetitionType !== 'absolute');
      repeatingOptionsGroup.classList.toggle('hidden', task.repetitionType === 'none');
      if (task.repetitionType === 'relative') {
        repetitionAmountInput.value = task.repetitionAmount || 1;
        repetitionUnitSelect.value = task.repetitionUnit || 'days';
      } else if (task.repetitionType === 'absolute') {
        absoluteFrequencySelect.value = task.repetitionAbsoluteFrequency || 'weekly';
        toggleAbsoluteRepetitionFields(absoluteFrequencySelect.value);
        if (task.repetitionAbsoluteFrequency === 'weekly') {
          (task.repetitionAbsoluteWeeklyDays || []).forEach(day => {
            const cb = taskForm.querySelector(`input[name="weekday"][value="${day}"]`);
            if (cb) cb.checked = true;
          });
        } else if (task.repetitionAbsoluteFrequency === 'monthly') {
          taskForm.monthlyOption.value = task.repetitionAbsoluteMonthlyMode || 'day_number';
          toggleMonthlyOptions(taskForm.monthlyOption.value);
          if (task.repetitionAbsoluteMonthlyMode === 'day_of_week') {
            (task.repetitionAbsoluteNthWeekdayOccurrence || []).forEach(occ => { const cb = taskForm.querySelector(`input[name="monthlyOccurrence"][value="${occ}"]`); if (cb) cb.checked = true; });
            (task.repetitionAbsoluteNthWeekdayDays || []).forEach(day => { const cb = taskForm.querySelector(`input[name="monthlyWeekday"][value="${day}"]`); if (cb) cb.checked = true; });
          } else {
            (task.repetitionAbsoluteDaysOfMonth || []).forEach(day => { const cb = taskForm.querySelector(`input[name="monthlyDay"][value="${day}"]`); if (cb) cb.checked = true; });
          }
        } else if (task.repetitionAbsoluteFrequency === 'yearly') {
          (task.repetitionAbsoluteYearlyMonths || []).forEach(month => { const cb = taskForm.querySelector(`input[name="yearlyMonth"][value="${month}"]`); if (cb) cb.checked = true; });
          taskForm.yearlyOption.value = task.repetitionAbsoluteYearlyMode || 'day_number';
          toggleYearlyOptions(taskForm.yearlyOption.value);
          if (task.repetitionAbsoluteYearlyMode === 'day_of_week') {
            (task.repetitionAbsoluteNthWeekdayOccurrence || []).forEach(occ => { const cb = taskForm.querySelector(`input[name="yearlyOccurrence"][value="${occ}"]`); if (cb) cb.checked = true; });
            (task.repetitionAbsoluteNthWeekdayDays || []).forEach(day => { const cb = taskForm.querySelector(`input[name="yearlyWeekday"][value="${day}"]`); if (cb) cb.checked = true; });
          } else {
            (task.repetitionAbsoluteYearlyDaysOfMonth || []).forEach(day => { const cb = taskForm.querySelector(`input[name="yearlyDay"][value="${day}"]`); if (cb) cb.checked = true; });
          }
        }
      }
      maxMissesInput.value = task.maxMisses || '';
      trackMissesInput.checked = typeof task.trackMisses === 'boolean' ? task.trackMisses : true;
      requiresFullAttentionInput.checked = typeof task.requiresFullAttention === 'boolean' ? task.requiresFullAttention : true;
      isAppointmentInput.checked = typeof task.isAppointment === 'boolean' ? task.isAppointment : false;
      completionTypeSelect.value = task.completionType || 'simple';
      estimatedDurationAmountInput.value = task.estimatedDurationAmount || '';
      estimatedDurationUnitSelect.value = task.estimatedDurationUnit || 'minutes';
      countTargetInput.value = task.countTarget || '';
      timeTargetAmountInput.value = task.timeTargetAmount || '';
      timeTargetUnitSelect.value = task.timeTargetUnit || 'minutes';
      taskCategorySelect.value = task.categoryId || '';
      document.getElementById('is-kpi').checked = task.isKpi || false;
      document.getElementById('prep-time-amount').value = task.prepTimeAmount || '';
      document.getElementById('prep-time-unit').value = task.prepTimeUnit || 'minutes';

      // New logic for repetition end condition
      const repeatUntilMode = task.repeatUntilMode || 'date';
      taskForm.querySelector(`input[name="repeat-until-mode"][value="${repeatUntilMode}"]`).checked = true;
      if (repeatUntilMode === 'date') {
        document.getElementById('repeat-until-date').value = task.repeatUntil ? formatDateForInput(new Date(task.repeatUntil)) : '';
        document.getElementById('repeat-until-occurrences').value = '';
      } else {
        document.getElementById('repeat-until-occurrences').value = task.repeatUntilOccurrences || '';
        document.getElementById('repeat-until-date').value = '';
      }
      toggleRepeatUntilFields();
    } else {
      modalTitle.textContent = 'Add New Task';
      taskIdInput.value = '';
      // When adding a new task, we respect the user's saved preference for simple/advanced mode,
      // which is already in uiSettings.isSimpleMode.

      modalTitle.textContent = 'Add New Task';
      submitButton.textContent = 'Create Task';
      // Set default values for new tasks
      const now = new Date();
      const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000);
      const formattedDefaultDate = formatDateForInput(oneHourFromNow);
      taskDueDateInput.value = formattedDefaultDate;
      taskStartDateInput.value = formattedDefaultDate;

      if (estimatedDurationAmountInput) estimatedDurationAmountInput.value = 1;
      if (estimatedDurationUnitSelect) estimatedDurationUnitSelect.value = 'hours';

      applySmartDefaults();
    }

    toggleSimpleMode(); // Set the view based on the current uiSettings.isSimpleMode

    // Ensure estimated duration requirement is set based on time input type
    if (estimatedDurationAmountInput) {
      estimatedDurationAmountInput.required = (timeInputTypeSelect.value === 'start');
    }

    toggleCompletionFields(completionTypeSelect.value);
    activateModal(taskModal);
    // Use a short timeout to ensure all fields are populated before serializing
    setTimeout(() => {
      initialFormState = getFormState(taskForm);
    }, 100);
  } catch (e) {
    console.error('Error opening modal:', e);
  }
}

function getFormState(form) {
  const formData = new FormData(form);
  const object = {};
  formData.forEach((value, key) => {
    // This handles multiple checkboxes with the same name
    if (Reflect.has(object, key)) {
      if (!Array.isArray(object[key])) {
        object[key] = [object[key]];
      }
      object[key].push(value);
    } else {
      object[key] = value;
    }
  });
  return JSON.stringify(object);
}

function isFormDirty() {
  if (!taskForm) return false;
  const currentState = getFormState(taskForm);
  return initialFormState !== currentState;
}

function closeModal() {
  if (isFormDirty()) {
    if (!confirm('You have unsaved changes. Are you sure you want to discard them?')) {
      return; // Abort closing if the user cancels
    }
  }
  const taskModalEl = document.getElementById('task-modal');
  if (taskModalEl) {
    deactivateModal(taskModalEl);
  }
  editingTaskId = null;
  initialFormState = ''; // Clear the state

  if (modalStack.length > 0) {
    const lastModal = modalStack.pop();
    if (lastModal.type === 'task-view') {
      // Use a timeout to allow the close animation to finish before opening the next modal
      setTimeout(() => {
        openTaskView(lastModal.taskId, false, lastModal.occurrenceDate, lastModal.source);
      }, 150);
    }
  }
}

function toggleSimpleMode() {
  const advancedFields = document.getElementById('advanced-task-fields');
  const simpleModeToggle = document.getElementById('simple-mode-toggle');

  if (advancedFields && simpleModeToggle) {
    advancedFields.classList.toggle('hidden', uiSettings.isSimpleMode);
    simpleModeToggle.checked = !uiSettings.isSimpleMode;

    const advancedTimePlaceholder = document.getElementById('advanced-time-inputs-placeholder');
    const simpleTimeFieldset = document.getElementById('simple-time-fieldset');

    // Elements to move
    const timeInputContainer = document.getElementById('time-input-container');
    const dueDateGroup = document.getElementById('due-date-group');
    const startDateGroup = document.getElementById('start-date-group');

    if (uiSettings.isSimpleMode) {
      // Move back to simple fieldset
      if (simpleTimeFieldset) {
        if (timeInputContainer) simpleTimeFieldset.appendChild(timeInputContainer);
        if (dueDateGroup) simpleTimeFieldset.appendChild(dueDateGroup);
        if (startDateGroup) simpleTimeFieldset.appendChild(startDateGroup);
      }
    } else {
      // Move to advanced placeholder
      if (advancedTimePlaceholder) {
        if (timeInputContainer) advancedTimePlaceholder.appendChild(timeInputContainer);
        if (dueDateGroup) advancedTimePlaceholder.appendChild(dueDateGroup);
        if (startDateGroup) advancedTimePlaceholder.appendChild(startDateGroup);
      }
    }

    // In simple mode, the main due date input is part of the advanced form now, so it's always hidden.
    // In advanced mode, its visibility is controlled by the new updateDateTimeFieldsVisibility function.
    updateDateTimeFieldsVisibility();
  }
}

function updateDateTimeFieldsVisibility() {
  if (!dueDateGroup || !relativeDueDateGroup || !startDateGroup || !dueDateTypeSelect || !timeInputTypeSelect) {
    return;
  }

  const isRelative = dueDateTypeSelect.value === 'relative';
  const isStartInput = timeInputTypeSelect.value === 'start';
  const relativeLabel = document.getElementById('relative-due-date-label');

  // Show relative group only if due date type is relative
  relativeDueDateGroup.classList.toggle('hidden', !isRelative);

  // Show absolute due date group only if type is absolute AND input is 'due'
  dueDateGroup.classList.toggle('hidden', isRelative || isStartInput);

  // Show start date group only if type is 'start' AND type is 'absolute'
  startDateGroup.classList.toggle('hidden', !isStartInput || isRelative);

  // Update the label for the relative time input
  if (relativeLabel) {
    relativeLabel.textContent = isStartInput ? 'Start In:' : 'Due In:';
  }
}


function toggleCompletionFields(type) {
  completionCountGroup.classList.toggle('hidden', type !== 'count');
  completionTimeGroup.classList.toggle('hidden', type !== 'time');
  const isTimeType = type === 'time';
  estimatedDurationGroup.classList.toggle('hidden', isTimeType);

  // If completion type is 'time', the duration is derived from the time target,
  // so the separate estimated duration input is not needed and should not be required.
  if (isTimeType) {
    if (estimatedDurationAmountInput) {
      estimatedDurationAmountInput.required = false;
    }
  } else {
    // Otherwise, the requirement depends on the time input type (due vs start)
    if (estimatedDurationAmountInput && timeInputTypeSelect) {
      estimatedDurationAmountInput.required = (timeInputTypeSelect.value === 'start');
    }
  }
}

function archiveNonRepeatingTask(task, status, progress = 1) {
  const originalDueDate = new Date(task.originalDueDate || task.dueDate);

  let historicalStatus;
  if (status === 'missed') {
    // For non-repeating tasks, a miss is 'yellow' if partial, 'black' otherwise.
    if (progress > 0 && progress < 1) {
      historicalStatus = 'yellow';
    } else {
      historicalStatus = 'black';
    }
  } else {
    // This case should not happen based on current calls, but as a fallback:
    historicalStatus = status;
  }

  const historicalTask = {
    originalTaskId: task.id,
    name: task.name,
    completionDate: originalDueDate, // The time for calendar placement
    actionDate: new Date(),         // The actual time of action
    status: historicalStatus,
    categoryId: task.categoryId,
    durationAmount: task.estimatedDurationAmount,
    durationUnit: task.estimatedDurationUnit,
    progress: progress,
    thoughts: task.thoughts,
    originalDueDate: originalDueDate // The scheduled due date
  };
  appState.historicalTasks.push(historicalTask);

  // Instead of deleting, move the full task object to the new archived array.
  if (!appState.archivedTasks) { appState.archivedTasks = []; }
  appState.archivedTasks.push(task);
  tasks = tasks.filter(t => t.id !== task.id); // Remove from active tasks
}
function toggleAbsoluteRepetitionFields(frequency) {
  absoluteWeeklyOptions.classList.toggle('hidden', frequency !== 'weekly');
  absoluteMonthlyOptions.classList.toggle('hidden', frequency !== 'monthly');
  absoluteYearlyOptions.classList.toggle('hidden', frequency !== 'yearly');
  if(frequency === 'monthly') toggleMonthlyOptions(taskForm.monthlyOption.value);
  if(frequency === 'yearly') toggleYearlyOptions(taskForm.yearlyOption.value);
}
function toggleMonthlyOptions(mode) {
  monthlyDayNumberOptions.classList.toggle('hidden', mode !== 'day_number');
  monthlyDayOfWeekOptions.classList.toggle('hidden', mode !== 'day_of_week');
}

function toggleRepeatUntilFields() {
  const mode = taskForm.querySelector('input[name="repeat-until-mode"]:checked').value;
  document.getElementById('repeat-until-date-group').classList.toggle('hidden', mode !== 'date');
  document.getElementById('repeat-until-occurrences-group').classList.toggle('hidden', mode !== 'occurrences');
}

function toggleYearlyOptions(mode) {
  yearlyDayNumberOptions.classList.toggle('hidden', mode !== 'day_number');
  yearlyDayOfWeekOptions.classList.toggle('hidden', mode !== 'day_of_week');
}
function renderCategoryManager() {
  const list = document.getElementById('category-manager-list');
  if (!list) return;
  list.innerHTML = categoryManagerTemplate(categories);
}
function renderPlannerSettings() {
  if (!plannerDefaultCategorySelect) return;

  // Handle the new sensitivity controls
  const sensitivityDefaultToggle = document.getElementById('planner-sensitivity-default-toggle');
  const sensitivitySlider = document.getElementById('planner-sensitivity-slider');

  if (sensitivityDefaultToggle && sensitivitySlider) {
    // A value of exactly 0.5 is considered 'default'
    const isDefault = sensitivitySettings.sValue === 0.5;
    sensitivityDefaultToggle.checked = isDefault;
    sensitivitySlider.disabled = isDefault;
    sensitivitySlider.value = sensitivitySettings.sValue;
  }


  const creationOnClickToggle = document.getElementById('allow-creation-on-click-toggle');
  if (creationOnClickToggle) {
    creationOnClickToggle.checked = calendarSettings.allowCreationOnClick;
  }

  const plannerDefaultIconInput = document.getElementById('planner-default-icon');
  if (plannerDefaultIconInput && plannerSettings) {
    plannerDefaultIconInput.value = plannerSettings.defaultIcon || 'fa-solid fa-map-pin';
  }


  plannerDefaultCategorySelect.innerHTML = '';
  const defaultOption = document.createElement('option');
  defaultOption.value = 'Planner';
  defaultOption.textContent = 'Planner (Default)';
  plannerDefaultCategorySelect.appendChild(defaultOption);

  categories.forEach(cat => {
    const option = document.createElement('option');
    option.value = cat.id;
    option.textContent = cat.name;
    plannerDefaultCategorySelect.appendChild(option);
  });

  plannerDefaultCategorySelect.value = plannerSettings.defaultCategoryId || 'Planner';
}

function renderTaskDisplaySettings() {
  const container = document.getElementById('task-card-display-options');
  if (!container) return;
  for (const key in taskDisplaySettings) {
    const checkbox = container.querySelector(`input[name="${key}"]`);
    if (checkbox) {
      checkbox.checked = taskDisplaySettings[key];
    }
  }
}

function renderAppSettings() {
  const titleInput = document.getElementById('app-title-input');
  if (titleInput) {
    titleInput.value = appSettings.title;
  }
  const subtitleInput = document.getElementById('app-subtitle-input');
  if (subtitleInput) {
    subtitleInput.value = appSettings.subtitle;
  }
  const goalLabelInput = document.getElementById('app-goal-label-input');
  if (goalLabelInput) {
    goalLabelInput.value = appSettings.weeklyGoalLabel;
  }
  const timeFormatToggle = document.getElementById('time-format-toggle');
  if (timeFormatToggle) {
    timeFormatToggle.checked = appSettings.use24HourFormat;
  }
}

function renderJournalSettings() {
  const container = document.getElementById('journal-settings-content');
  if (!container) return;
  container.innerHTML = journalSettingsTemplate(journalSettings);
}

function renderPerformanceSettings() {
  const amountInput = document.getElementById('calculation-horizon-amount');
  const unitInput = document.getElementById('calculation-horizon-unit');
  if (amountInput && unitInput) {
    amountInput.value = uiSettings.calculationHorizonAmount;
    unitInput.value = uiSettings.calculationHorizonUnit;
  }

  const gpaSystemSelect = document.getElementById('gpa-system-select');
  if (gpaSystemSelect) {
    gpaSystemSelect.value = appSettings.gpaSystem || 'standard';
  }
}

function renderKpiAutomationSettings() {
  const container = document.getElementById('kpi-automation-settings');
  if (!container) return;
  container.innerHTML = kpiAutomationSettingsTemplate(appSettings);
}

function renderHintManager() {
  const container = document.getElementById('hint-manager-content');
  if (!container) return;
  if (!uiSettings.userInteractions) {
    uiSettings.userInteractions = {};
  }
  container.innerHTML = hintManagerTemplate(hints, uiSettings);
}

function renderOtherFeaturesSettings() {
  const closeModalToggle = document.getElementById('close-modal-after-action-toggle');
  if (closeModalToggle) {
    closeModalToggle.checked = uiSettings.closeModalAfterAction;
  }
  // Any other settings for this section would be rendered here
}

function renderTaskHistorySettings() {
  const syncIconsToggle = document.getElementById('sync-task-icons-toggle');
  if (syncIconsToggle) {
    syncIconsToggle.checked = uiSettings.syncTaskIcons;
  }
}

function updateTaskIcon(taskId, newIcon) {
  const task = tasks.find(t => t.id === taskId);
  if (task) {
    task.icon = newIcon;
  }

  if (uiSettings.syncTaskIcons) {
    appState.historicalTasks.forEach(h => {
      if (h.originalTaskId === taskId) {
        h.icon = newIcon;
      }
    });
    if (appState.archivedTasks) {
      appState.archivedTasks.forEach(a => {
        if (a.id === taskId) {
          a.icon = newIcon;
        }
      });
    }
  }
  saveData();
  renderTasks();
  if (calendar) calendar.refetchEvents();
}

function renderEarlyOnTimeSettings() {
  const settings = uiSettings.earlyOnTimeSettings || { enabled: false, displaceCalendar: false, onlyAppointments: false };
  const masterToggle = document.getElementById('early-on-time-toggle');
  const optionsDiv = document.getElementById('early-on-time-options');
  const appointmentsToggle = document.getElementById('early-on-time-appointments-toggle');

  if (masterToggle) {
    masterToggle.checked = settings.enabled;
  }
  if (optionsDiv) {
    optionsDiv.classList.toggle('hidden', !settings.enabled);
  }
  if (appointmentsToggle) {
    appointmentsToggle.checked = settings.onlyAppointments;
  }
}

function renderBufferSettings() {
  const container = document.getElementById('buffer-management-content');
  if (!container) return;

  container.innerHTML = `
        <div class="space-y-4">
            <div>
                <h4 class="font-bold text-sm mb-2">Prep Time</h4>
                <div class="flex space-x-2 items-center mb-2">
                    <label class="text-xs">Label:</label>
                    <input type="text" id="buffer-prep-label" value="${bufferSettings.prep.label}" class="flex-grow text-xs p-1">
                </div>
                <div class="flex space-x-2 items-center">
                    <label class="text-xs">Icon:</label>
                    <div class="flex items-center space-x-2 flex-grow">
                        <input type="text" id="buffer-prep-icon" value="${bufferSettings.prep.icon}" class="flex-grow text-xs p-1">
                        <button type="button" data-action="openIconPicker" data-context="buffer-prep" class="btn btn-clear text-xs">Choose</button>
                    </div>
                </div>
            </div>
            <div class="border-t border-gray-700 pt-2">
                <h4 class="font-bold text-sm mb-2">Early Buffer (from "Early is on Time")</h4>
                <div class="flex space-x-2 items-center mb-2">
                    <label class="text-xs">Label:</label>
                    <input type="text" id="buffer-early-label" value="${bufferSettings.early.label}" class="flex-grow text-xs p-1">
                </div>
                <div class="flex space-x-2 items-center">
                    <label class="text-xs">Icon:</label>
                    <div class="flex items-center space-x-2 flex-grow">
                        <input type="text" id="buffer-early-icon" value="${bufferSettings.early.icon}" class="flex-grow text-xs p-1">
                        <button type="button" data-action="openIconPicker" data-context="buffer-early" class="btn btn-clear text-xs">Choose</button>
                    </div>
                </div>
            </div>
            <div class="border-t border-gray-700 pt-2">
                <label class="flex items-center justify-between">
                    <span class="text-sm font-medium" title="If enabled, Prep Time and Early Buffer will be combined into a single 'Preparation' slice in the dashboard chart.">Combine in Dashboard Chart</span>
                    <input type="checkbox" id="buffer-combine-dashboard" class="toggle-checkbox" ${bufferSettings.dashboard.combinePrepTime ? 'checked' : ''}>
                </label>
            </div>
        </div>
    `;

  // Add listeners for changes
  const inputs = container.querySelectorAll('input');
  inputs.forEach(input => {
    input.addEventListener('change', (e) => {
      if (e.target.id === 'buffer-prep-label') bufferSettings.prep.label = e.target.value;
      if (e.target.id === 'buffer-prep-icon') bufferSettings.prep.icon = e.target.value;
      if (e.target.id === 'buffer-early-label') bufferSettings.early.label = e.target.value;
      if (e.target.id === 'buffer-early-icon') bufferSettings.early.icon = e.target.value;
      if (e.target.id === 'buffer-combine-dashboard') bufferSettings.dashboard.combinePrepTime = e.target.checked;
      saveData();
      if (calendar) calendar.refetchEvents(); // Refresh calendar to show new labels/icons
    });
  });
}

function renderMonthViewSettings() {
  const container = document.getElementById('month-view-display-options');
  if (!container) return;
  if (!uiSettings.monthView) { // Ensure the object exists
    uiSettings.monthView = { showIcon: true, showTime: false, showName: true, groupTasks: true };
  }
  for (const key in uiSettings.monthView) {
    const checkbox = container.querySelector(`input[name="${key}"]`);
    if (checkbox) {
      checkbox.checked = uiSettings.monthView[key];
    }
  }
}

function renderCalendarViewSettings() {
  // Week View
  const weekContainer = document.getElementById('week-view-display-options');
  if (weekContainer) {
    if (!uiSettings.weekView) {
      uiSettings.weekView = { showIcon: true, showTime: true, showName: true };
    }
    for (const key in uiSettings.weekView) {
      const checkbox = weekContainer.querySelector(`input[name="${key}"]`);
      if (checkbox) checkbox.checked = uiSettings.weekView[key];
    }
  }

  // Day View
  const dayContainer = document.getElementById('day-view-display-options');
  if (dayContainer) {
    if (!uiSettings.dayView) {
      uiSettings.dayView = { showIcon: true, showTime: true, showName: true };
    }
    for (const key in uiSettings.dayView) {
      const checkbox = dayContainer.querySelector(`input[name="${key}"]`);
      if (checkbox) checkbox.checked = uiSettings.dayView[key];
    }
  }
}


function openAdvancedOptionsModal() {
  renderCategoryManager();
  renderCategoryFilters();
  renderNotificationManager();
  renderThemeControls();
  renderStatusManager();
  // Use a small timeout to ensure the DOM is ready before rendering settings that depend on it.
  setTimeout(() => {
    renderPlannerSettings();
  }, 0);
  renderTaskDisplaySettings();
  renderAppSettings();
  renderVacationManager();
  renderJournalSettings();
  renderPerformanceSettings();
  renderKpiAutomationSettings();
  renderHintManager();
  renderOtherFeaturesSettings(); // Render the new settings
  renderTaskHistorySettings();
  renderEarlyOnTimeSettings(); // Render the "Early is on Time" settings
  renderBufferSettings(); // Render buffer management UI
  renderMonthViewSettings(); // Render the new month view settings
  renderCalendarViewSettings();

  // Render the toggle for showing/hiding calendar filters
  const showFiltersToggle = document.getElementById('show-calendar-filters-toggle');
  if (showFiltersToggle) {
    showFiltersToggle.checked = uiSettings.showCalendarFilters;
  }

  const smartFormDefaultsToggle = document.getElementById('smart-form-defaults-toggle');
  if (smartFormDefaultsToggle) {
    smartFormDefaultsToggle.checked = uiSettings.smartFormDefaults ? uiSettings.smartFormDefaults.enabled : false;
  }


  // Apply saved collapse states
  const sections = advancedOptionsModal.querySelectorAll('.collapsible-section');
  sections.forEach(section => {
    const key = section.dataset.sectionKey;
    // A section is open ONLY if its state is explicitly saved as false (i.e., isCollapsed: false).
    // Otherwise (if the state is true or undefined), it remains collapsed.
    const shouldBeOpen = uiSettings.advancedOptionsCollapseState[key] === false;
    section.classList.toggle('open', shouldBeOpen);
  });

  activateModal(advancedOptionsModal);
}

function renderVacationManager() {
  const container = document.getElementById('vacation-manager-content');
  if (!container) return;
  if (!appState.vacations) {
    appState.vacations = [];
  }
  // Sort vacations by start date before rendering
  appState.vacations.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
  container.innerHTML = vacationManagerTemplate(appState.vacations, categories);

  const form = document.getElementById('add-vacation-form');
  if (form) {
    form.addEventListener('submit', handleAddVacation);
  }
}

function openTaskView(eventId, isHistorical, occurrenceDate, source = 'calendar') {
  console.log(`openTaskView called with: eventId=${eventId}, isHistorical=${isHistorical}, source=${source}`);
  let taskOrHistoryItem;
  const getBaseId = (id) => {
    if (!id || !id.includes('_')) return id;
    const lastUnderscoreIndex = id.lastIndexOf('_');
    return id.substring(0, lastUnderscoreIndex);
  };

  if (isHistorical) {
    taskOrHistoryItem = appState.historicalTasks.find(h => 'hist_' + h.originalTaskId + '_' + h.completionDate === eventId);
    if (!taskOrHistoryItem) {
      taskOrHistoryItem = tasks.find(t => t.id === eventId) || (appState.archivedTasks && appState.archivedTasks.find(t => t.id === eventId));
    }
  } else {
    const allTasks = [...tasks, ...(appState.archivedTasks || [])];
    taskOrHistoryItem = allTasks.find(t => t.id === eventId);
    if (!taskOrHistoryItem && eventId && eventId.includes('_')) {
      const baseTaskId = getBaseId(eventId);
      taskOrHistoryItem = tasks.find(t => t.id === baseTaskId);
    }
  }

  if (!taskOrHistoryItem && !isHistorical) {
    const baseTaskId = getBaseId(eventId);
    if (baseTaskId) {
      const matchingHistory = appState.historicalTasks
        .filter(h => h.originalTaskId === baseTaskId)
        .sort((a, b) => new Date(b.actionDate) - new Date(a.actionDate));
      if (matchingHistory.length > 0) {
        if (occurrenceDate) {
          const exactMatch = matchingHistory.find(h => new Date(h.completionDate).getTime() === new Date(occurrenceDate).getTime());
          if (exactMatch) taskOrHistoryItem = exactMatch;
        }
        if (!taskOrHistoryItem) taskOrHistoryItem = matchingHistory[0];
        isHistorical = true;
      }
    }
  }

  if (!taskOrHistoryItem) {
    console.error('Task or history item not found for opening view:', eventId);
    return;
  }

  if (isHistorical && !taskOrHistoryItem.id) {
    taskOrHistoryItem.id = eventId.replace(/[^a-zA-Z0-9_-]/g, '_');
  }

  const taskViewContentEl = document.getElementById('task-view-content');
  const taskStatsContentEl = document.getElementById('task-stats-content');
  const taskViewModalEl = document.getElementById('task-view-modal');
  const borderWrapper = document.getElementById('task-view-modal-border-wrapper');

  if (!taskViewContentEl || !taskStatsContentEl || !taskViewModalEl || !borderWrapper) {
    console.error('Could not find task view modal elements in the DOM.');
    return;
  }

  const updateBorder = (task) => {
    if (!borderWrapper) return;
    let gpaPercent = 0;
    const gpaMap = { blue: 4.0, green: 3.0, yellow: 2.0, red: 1.0, black: 0.0 };
    if (isHistorical) {
      gpaPercent = (gpaMap[task.status] || 0) / 4.0;
    } else {
      const currentTask = tasks.find(t => t.id === task.id);
      if (currentTask) {
        gpaPercent = typeof currentTask.coloringGpa === 'number' ? currentTask.coloringGpa : (gpaMap[currentTask.status] || 0) / 4.0;
      }
    }
    const baseColor = interpolateFiveColors(gpaPercent);
    const isDarkMode = !document.body.classList.contains('light-mode');
    const topColor = adjustColor(baseColor, isDarkMode ? 0.2 : -0.2);
    const bottomColor = adjustColor(baseColor, isDarkMode ? -0.2 : 0.2);
    const gradient = `linear-gradient(to bottom, ${topColor}, ${bottomColor})`;
    borderWrapper.style.background = gradient;
  };

  updateBorder(taskOrHistoryItem);

  if (!isHistorical) {
    taskViewModalEl.dataset.viewingTaskId = taskOrHistoryItem.id;
  } else {
    delete taskViewModalEl.dataset.viewingTaskId;
  }

  try {
    taskViewContentEl.innerHTML = taskViewTemplate(taskOrHistoryItem, { categories, appSettings, isHistorical });
  } catch (e) {
    console.error('Error rendering taskViewTemplate:', e);
    return; // Stop execution if template fails
  }
  taskViewContentEl.classList.remove('hidden');
  taskStatsContentEl.classList.add('hidden');
  taskStatsContentEl.innerHTML = '';

  // Use AbortController to manage listeners, preventing stacking.
  // Abort the previous controller before adding new listeners.
  taskViewListenerController.abort();
  taskViewListenerController = new AbortController();
  const { signal } = taskViewListenerController;


  const afterAction = (andRefreshCalendar = true) => {
    if (uiSettings.closeModalAfterAction) {
      deactivateModal(taskViewModalEl);
      delete taskViewModalEl.dataset.viewingTaskId;
    }
    if (andRefreshCalendar && calendar) calendar.refetchEvents();
  };

  const blurListener = (e) => {
    const thoughtsEl = e.target.closest('[contenteditable="true"]');
    if (thoughtsEl && thoughtsEl.id.startsWith('task-thoughts-content-')) {
      const taskId = isHistorical ? taskOrHistoryItem.originalTaskId : taskOrHistoryItem.id;
      const task = tasks.find(t => t.id === taskId);
      if (task) {
        const newThoughts = thoughtsEl.innerHTML.trim();
        const occurrenceId = isHistorical ? null : eventId; // eventId is the occurrenceId for future tasks

        // Check if the thoughts are different from the base task or a specific override
        const currentThoughts = (task.occurrenceOverrides && task.occurrenceOverrides[occurrenceId] && task.occurrenceOverrides[occurrenceId].thoughts) || task.thoughts;

        if (currentThoughts !== newThoughts) {
          if (task.repetitionType !== 'none' && !isHistorical && occurrenceId) {
            // For a repeating task's future occurrence, save it as an override.
            updateTaskOccurrence(taskId, occurrenceId, { thoughts: newThoughts });
          } else if (!isHistorical) {
            // For a non-repeating task or the master repeating task, save directly.
            task.thoughts = newThoughts;
            saveData();
          }
          // Note: Editing thoughts on historical records is handled by a separate 'saveHistoryThoughts' action, not the blur listener.
        }
      }
    }
  };
  taskViewContentEl.addEventListener('blur', taskViewContentEl.blurListener, { signal, capture: true });

  const clickListener = (e) => {
    const target = e.target.closest('[data-action]');
    if (!target) return;

    const action = target.dataset.action;
    const taskId = target.dataset.taskId || (isHistorical ? taskOrHistoryItem.originalTaskId : taskOrHistoryItem.id);
    const historyEventId = target.dataset.historyEventId;
    let task = tasks.find(t => t.id === taskId);

    if (action === 'editHistoryIcon') {
      editingHistoryEventId = historyEventId;
      editingTaskId = taskId; // Also set this for the icon picker's context
      openIconPicker('history');
      return;
    }

    const refreshModal = () => {
      // Re-find the task in case it was modified by the action
      const currentTask = tasks.find(t => t.id === taskId);
      if (currentTask) {
        openTaskView(taskId, false, occurrenceDate, source);
      } else {
        // If task is no longer in active list, it must have been completed/archived.
        // Close the modal and refresh the calendar.
        afterAction(true);
      }
    };

    const checkCompletionAndRefresh = () => {
      task = tasks.find(t => t.id === taskId); // Re-fetch task state
      if (task && !task.confirmationState) {
        refreshModal();
      } else if (task && task.confirmationState) {
        refreshModal(); // show confirmation
      } else {
        afterAction(true); // closed because task was completed/archived
      }
    };

    switch (action) {
    case 'editTaskFromView':
      deactivateModal(taskViewModalEl);
      if (source === 'task-manager') {
        openModal(taskId, { source: 'task-view' });
      } else { // 'calendar' or default
        const taskToEdit = tasks.find(t => t.id === taskId);
        if (taskToEdit) {
          const occurrence = calendarTimeGridEvents.find(e => e.id === eventId) || calendarMonthEvents.find(e => e.id === eventId);
          openSimpleEditModal(taskToEdit, occurrence ? { id: occurrence.id, occurrenceDueDate: occurrence.start } : null, categories);
        }
      }
      break;
    case 'triggerDeleteFromView':
      triggerDelete(taskId);
      openTaskView(eventId, isHistorical, occurrenceDate);
      break;
    case 'confirmCompletion':
      confirmCompletionAction(taskId, target.dataset.confirmed === 'true');
      // Re-open the view to reflect the new state. This handles both "Yes" and "No" paths.
      openTaskView(eventId, isHistorical, occurrenceDate, source);
      break;
    case 'confirmMiss':
      confirmMissAction(taskId, target.dataset.confirmed === 'true');
      openTaskView(eventId, isHistorical, occurrenceDate, source);
      break;
    case 'confirmUndo':
      confirmUndoAction(taskId, target.dataset.confirmed === 'true');
      openTaskView(eventId, isHistorical, occurrenceDate, source);
      break;
    case 'confirmDeleteFromView':
    case 'confirmDeleteHistoryRecordFromView':
      if (action === 'confirmDeleteFromView') {
        confirmDeleteAction(taskId, true); // This will remove the task
      }
      if (action === 'confirmDeleteHistoryRecordFromView') {
        appState.historicalTasks = appState.historicalTasks.filter(h => 'hist_' + h.originalTaskId + '_' + h.completionDate !== historyEventId);
        saveData();
      }
      afterAction(); // Correct for delete actions, as the view should close or calendar should update
      break;

    case 'triggerCompletion':
      if (task) { triggerCompletion(taskId); refreshModal(); }
      break;
    case 'handleOverdue':
      if (task) { handleOverdueChoice(taskId, target.dataset.choice); refreshModal(); }
      break;
    case 'triggerDeleteFromView':
      if (task) { triggerDelete(taskId); refreshModal(); }
      break;
    case 'triggerUndo':
      if (task) { triggerUndoConfirmation(taskId); refreshModal(); }
      break;
    case 'incrementCount':
      if (task) { incrementCount(taskId); checkCompletionAndRefresh(); }
      break;
    case 'decrementCount':
      if (task) { decrementCount(taskId); refreshModal(); }
      break;
    case 'toggleTimer':
      if (task) { toggleTimer(taskId); checkCompletionAndRefresh(); }
      break;
    case 'editProgress':
      if (task) { editProgress(taskId); }
      break;
    case 'saveProgress':
      if (task) { saveProgressEdit(taskId); checkCompletionAndRefresh(); }
      break;
    case 'cancelProgress':
      if (task) { cancelProgressEdit(taskId); refreshModal(); }
      break;
    case 'cancelDeleteFromView':
      if (task) {
        task.confirmationState = null;
        const taskInList = tasks.find(t => t.id === taskId);
        if(taskInList) taskInList.confirmationState = null;
        saveData();
        refreshModal();
      }
      break;
    case 'cancelDeleteHistoryRecordFromView':
      openTaskView(historyEventId, true);
      break;
    case 'viewTaskStats':
      renderTaskStats(taskId);
      break;
    case 'editHistoryThoughts':
      const thoughtsContent = document.getElementById(`task-thoughts-content-${historyEventId}`);
      if (thoughtsContent) {
        const currentThoughts = taskOrHistoryItem.thoughts || '';
        thoughtsContent.innerHTML = `
                        <textarea id="editing-thoughts-${historyEventId}" class="w-full h-24 p-2 border rounded">${currentThoughts}</textarea>
                        <button data-action="saveHistoryThoughts" data-history-event-id="${historyEventId}" class="btn btn-confirm btn-sm mt-2">Save</button>
                    `;
      }
      break;
    case 'saveHistoryThoughts':
      const textarea = document.getElementById(`editing-thoughts-${historyEventId}`);
      if (textarea) {
        const newThoughts = textarea.value.trim();
        // The historyEventId from the DOM is sanitized, so we must sanitize the comparison ID here as well.
        const historyItem = appState.historicalTasks.find(h => ('hist_' + h.originalTaskId + '_' + h.completionDate).replace(/[^a-zA-Z0-9_-]/g, '_') === historyEventId);
        if (historyItem) {
          historyItem.thoughts = newThoughts;
          const journalEntry = {
            id: generateId(),
            createdAt: new Date(historyItem.completionDate).toISOString(),
            title: `Thought for: ${historyItem.name}`,
            content: newThoughts,
            icon: historyItem.icon, // This uses the icon from the historical item.
          };
          appState.journal.push(journalEntry);
          saveData();
          if (!historyItem.icon) {
            openAddIconPromptModal(historyItem.originalTaskId);
          } else {
            openTaskView(historyEventId, true);
          }
        }
      }
      break;
    case 'triggerDeleteHistoryRecordFromView':
      const confirmationDiv = newContentView.querySelector(`#task-view-confirmation-${taskOrHistoryItem.id}`);
      const actionsDiv = newContentView.querySelector('.responsive-button-grid');
      if (confirmationDiv && actionsDiv) {
        actionsDiv.classList.add('hidden');
        confirmationDiv.innerHTML = taskViewHistoryDeleteConfirmationTemplate(historyEventId, taskId);
      }
      break;
    }
  };
  taskViewContentEl.addEventListener('click', clickListener, { signal });
  activateModal(taskViewModalEl);
}

function renderTaskStats(taskId) {
  const taskViewContentEl = document.getElementById('task-view-content');
  const taskStatsContentEl = document.getElementById('task-stats-content');

  const isActive = tasks.some(t => t.id === taskId);
  // A task is considered "fully completed" or "deleted" if it has history but is NOT in the active task list.
  const isFullyCompleted = !isActive && appState.historicalTasks.some(h => h.originalTaskId === taskId);


  let task = tasks.find(t => t.id === taskId);
  if (!task && appState.archivedTasks) {
    task = appState.archivedTasks.find(t => t.id === taskId);
  }

  const history = appState.historicalTasks
    .map((h, index) => ({ ...h, historyId: `hist-${index}` }))
    .filter(ht => ht.originalTaskId === taskId)
    .sort((a, b) => new Date(b.completionDate) - new Date(a.completionDate));

  // If we can't find an active or archived task, but history exists, create a placeholder.
  // This is the key for reinstating deleted tasks.
  if (!task && history.length > 0) {
    const latestHistory = history[0];
    task = {
      id: taskId,
      name: latestHistory.name,
      icon: latestHistory.icon,
      categoryId: latestHistory.categoryId,
      estimatedDurationAmount: latestHistory.durationAmount,
      estimatedDurationUnit: latestHistory.durationUnit,
      isKpi: false // Default to false, user can re-enable
    };
  }

  if (!task) {
    console.error('Cannot find task or history for stats view:', taskId);
    return;
  }

  if (taskViewContentEl) taskViewContentEl.classList.add('hidden');
  if (taskStatsContentEl) taskStatsContentEl.classList.remove('hidden');

  const gpaMap = { blue: 4.0, green: 3.0, yellow: 2.0, red: 1.0, black: 0.0 };
  const completions = history.filter(h => (gpaMap[h.status] || 0) >= 2.0).length;
  const misses = history.length - completions;
  const total = history.length;
  const stats = {
    completions,
    misses,
    total,
    completionRate: total > 0 ? ((completions / total) * 100).toFixed(1) : 'N/A',
    overallGpa: null
  };

  if (total > 0) {
    const totalGpaPoints = history.reduce((sum, h) => sum + (gpaMap[h.status] || 0), 0);
    const averageGpa = totalGpaPoints / total;
    const gpaPercent = averageGpa / 4.0;
    const gpaColor = interpolateFiveColors(gpaPercent);
    const textStyles = getContrastingTextColor(gpaColor);

    stats.overallGpa = {
      grade: gpaToLetterGrade(averageGpa),
      color: gpaColor,
      textColor: textStyles['--text-color-primary'],
      textShadow: textStyles['--text-shadow']
    };
  }

  const historyHtml = history.length > 0
    ? history.map(h => {
      const formattedDate = new Date(h.completionDate).toLocaleDateString();
      const gpa = gpaMap[h.status] || 0;
      const grade = gpaToLetterGrade(gpa);
      const gpaPercent = gpa / 4.0;
      const gradeColor = interpolateFiveColors(gpaPercent);
      const textColorStyles = getContrastingTextColor(gradeColor);
      const textColor = textColorStyles['--text-color-primary'];
      const textShadow = textColorStyles['--text-shadow'];
      const historyEventId = `hist_${h.originalTaskId}_${h.completionDate}`;

      return `<div id="history-item-${h.historyId}"
                         class="flex justify-between items-center text-sm p-2 rounded-md cursor-pointer hover:bg-secondary"
                         data-action="viewHistoryRecord"
                         data-history-event-id="${historyEventId}">
                        <span>${formattedDate}:
                            <span class="font-bold inline-block text-center w-8 rounded py-1"
                                  style="background-color: ${gradeColor}; color: ${textColor}; text-shadow: ${textShadow};">
                                ${grade}
                            </span>
                        </span>
                        <button data-action="triggerHistoryDelete" data-history-id="${h.historyId}" data-task-id="${taskId}" class="btn btn-clear text-lg font-bold" title="Delete this record">&times;</button>
                    </div>`;
    }).join('')
    : '<div class="italic p-2">No history yet.</div>';

  const chartData = processTaskHistoryForChart(task, history);
  const hasChartData = chartData.labels.length > 0;

  taskStatsContentEl.innerHTML = taskStatsTemplate(task, stats, historyHtml, hasChartData, isFullyCompleted);

  if (hasChartData) {
    const ctx = document.getElementById('task-history-chart').getContext('2d');
    const showLines = chartData.labels.length > 1;
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: chartData.labels,
        datasets: [
          {
            label: 'Completions',
            data: chartData.completions,
            backgroundColor: 'rgba(34, 197, 94, 0.2)',
            borderColor: 'rgba(22, 163, 74, 1)',
            borderWidth: 2,
            fill: true,
            tension: 0.1,
            showLine: showLines
          },
          {
            label: 'Misses',
            data: chartData.misses,
            backgroundColor: 'rgba(220, 38, 38, 0.2)',
            borderColor: 'rgba(185, 28, 28, 1)',
            borderWidth: 2,
            fill: true,
            tension: 0.1,
            showLine: showLines
          }
        ]
      },
      options: {
        scales: {
          x: { title: { display: true, text: 'Date' } },
          y: { beginAtZero: true, title: { display: true, text: 'Count' }, ticks: { stepSize: 1 } }
        },
        plugins: { tooltip: { mode: 'index', intersect: false } },
        responsive: true,
        maintainAspectRatio: false
      }
    });
  }

  const backBtn = taskStatsContentEl.querySelector('[data-action="backToTaskView"]');
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      if (taskStatsContentEl) taskStatsContentEl.innerHTML = '';
      if (taskStatsContentEl) taskStatsContentEl.classList.add('hidden');
      if (taskViewContentEl) taskViewContentEl.classList.remove('hidden');
    }, { once: true });
  }

  const bulkUpdateIconButton = taskStatsContentEl.querySelector('[data-action="bulkUpdateIcon"]');
  if (bulkUpdateIconButton) {
    bulkUpdateIconButton.addEventListener('click', () => {
      editingTaskId = taskId;
      openIconPicker('bulk-history');
    });
  }

  const reinstateBtn = taskStatsContentEl.querySelector('[data-action="reinstateTask"]');
  if (reinstateBtn) {
    reinstateBtn.addEventListener('click', () => {
      // The 'task' object at this point is either the archived task or a placeholder
      // built from history. Both contain the necessary data.
      openReinstateTaskModal(task);
    });
  }

  const historyList = document.getElementById('detailed-history-list');
  if (historyList) {
    historyList.addEventListener('click', (e) => {
      const target = e.target.closest('[data-action]');
      if (!target) return;

      const action = target.dataset.action;
      const historyId = target.dataset.historyId;
      const historyEventId = target.dataset.historyEventId;
      const historyItemEl = document.getElementById(`history-item-${historyId}`);

      if (action === 'viewHistoryRecord') {
        openTaskView(historyEventId, true, null, 'calendar');
      } else if (action === 'triggerHistoryDelete') {
        e.stopPropagation();
        if (historyItemEl) {
          historyItemEl.innerHTML = historyDeleteConfirmationTemplate(historyId, taskId);
        }
      } else if (action === 'cancelHistoryDelete') {
        renderTaskStats(taskId);
      } else if (action === 'confirmHistoryDelete') {
        confirmHistoryDelete(historyId, taskId, target.dataset.deleteType);
      }
    });
  }
}

function renderCalendarCategoryFilters() {
  const container = document.getElementById('calendar-category-filters');
  if (!container) return;

  if (!uiSettings.showCalendarFilters) {
    container.innerHTML = '';
    return;
  }

  // Ensure all categories have a default setting
  if (!uiSettings.calendarCategoryFilters) {
    uiSettings.calendarCategoryFilters = {};
  }
  categories.forEach(cat => {
    if (!uiSettings.calendarCategoryFilters[cat.id]) {
      uiSettings.calendarCategoryFilters[cat.id] = { show: true, schedule: true };
    }
  });
  // Ensure 'uncategorized' has a default setting
  if (!uiSettings.calendarCategoryFilters['null']) {
    uiSettings.calendarCategoryFilters['null'] = { show: true, schedule: true };
  }

  container.innerHTML = calendarCategoryFilterTemplate(categories, uiSettings.calendarCategoryFilters, calendarSettings.filterTargetView);
}

function renderHistoricalOverview(sortBy = 'lastCompleted', sortDir = 'desc') {
  const listContainer = document.getElementById('historical-overview-list');
  if (!listContainer) return;

  // 1. Group history by original task ID
  const historyByTask = {};
  appState.historicalTasks.forEach(h => {
    if (!historyByTask[h.originalTaskId]) {
      historyByTask[h.originalTaskId] = [];
    }
    historyByTask[h.originalTaskId].push(h);
  });

  // 2. Process each group to get stats
  const gpaMap = { blue: 4.0, green: 3.0, yellow: 2.0, red: 1.0, black: 0.0 };
  let processedTasks = Object.keys(historyByTask).map(taskId => {
    const history = historyByTask[taskId];
    const lastEntry = history.sort((a, b) => new Date(b.completionDate) - new Date(a.completionDate))[0];

    const totalGpa = history.reduce((sum, h) => sum + (gpaMap[h.status] || 0), 0);
    const averageGpa = history.length > 0 ? totalGpa / history.length : 0;
    const gpaPercent = averageGpa / 4.0; // Scale 0-4 GPA to 0-1 for color interpolation

    const category = categories.find(c => c.id === lastEntry.categoryId);

    return {
      id: taskId,
      name: lastEntry.name,
      lastCompleted: lastEntry.completionDate,
      gpa: averageGpa,
      gpaColor: interpolateFiveColors(gpaPercent),
      categoryColor: category ? category.color : '#374151'
    };
  });

  // 3. Sort the processed tasks
  processedTasks.sort((a, b) => {
    let comparison = 0;
    if (sortBy === 'name') {
      comparison = a.name.localeCompare(b.name);
    } else if (sortBy === 'lastCompleted') {
      comparison = new Date(b.lastCompleted) - new Date(a.lastCompleted);
    } else if (sortBy === 'gpa') {
      comparison = b.gpa - a.gpa;
    }
    return sortDir === 'asc' ? -comparison : comparison;
  });

  // 4. Render the cards
  if (processedTasks.length === 0) {
    listContainer.innerHTML = '<p class="italic text-center col-span-full">No historical tasks found.</p>';
    return;
  }
  listContainer.innerHTML = processedTasks.map(historicalTaskCardTemplate).join('');
}


function openHistoricalOverviewModal() {
  const modal = document.getElementById('historical-overview-modal');
  if (!modal) return;

  renderHistoricalOverview(); // Initial render with default sort

  const sortBySelect = modal.querySelector('#historical-sort-by');
  const sortDirSelect = modal.querySelector('#historical-sort-direction');

  const sortHandler = () => {
    renderHistoricalOverview(sortBySelect.value, sortDirSelect.value);
  };

  sortBySelect.removeEventListener('change', sortHandler); // Remove old listener
  sortDirSelect.removeEventListener('change', sortHandler); // Remove old listener
  sortBySelect.addEventListener('change', sortHandler);
  sortDirSelect.addEventListener('change', sortHandler);

  const listContainer = modal.querySelector('#historical-overview-list');
  const clickHandler = (e) => {
    const card = e.target.closest('.historical-task-card');
    if (card) {
      const taskId = card.dataset.taskId;
      deactivateModal(modal); // Close this modal before opening the next one
      openTaskView(taskId, true); // Open in historical mode
    }
  };
  listContainer.removeEventListener('click', clickHandler); // Remove old listener
  listContainer.addEventListener('click', clickHandler);

  const closeButton = modal.querySelector('.close-button');
  const closeHandler = () => deactivateModal(modal);
  closeButton.removeEventListener('click', closeHandler); // Remove old listener
  closeButton.addEventListener('click', closeHandler);

  activateModal(modal);
}

function openConfirmOverrideModal(task, field, value, occurrenceId) {
  const modalHtml = confirmOverrideModalTemplate(occurrenceId);
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  const modal = document.getElementById('confirm-override-modal');

  const handleOverride = (e) => {
    const target = e.target.closest('[data-action="apply-override"]');
    if (target) {
      applyOverride(task, field, value, occurrenceId, target.dataset.scope);
    }
    modal.removeEventListener('click', handleOverride);
    deactivateModal(modal);
    modal.remove();
  };

  modal.addEventListener('click', handleOverride);
  activateModal(modal);
}

function openOrphanedOverrideModal(orphans, task, newOccurrences, onComplete) {
  // 1. Create and inject the modal HTML
  const modalHtml = orphanedOverrideModalTemplate(orphans, task, newOccurrences);
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  const modalElement = document.getElementById('orphaned-override-modal');

  // 2. Setup event listeners
  const handleAction = (e) => {
    const target = e.target.closest('button[data-action]');
    if (!target) return;

    const action = target.dataset.action;
    const orphanId = target.dataset.orphanId;
    const orphan = orphans.find(o => o.occurrenceId === orphanId);
    if (!orphan) return;

    switch (action) {
    case 'relink-override':
      // In a real scenario, this would open another UI to select a new date.
      // For now, we'll just log it and remove the item.
      console.log('Relinking (not implemented):', orphan);
      removeOrphanFromList(orphanId);
      break;
    case 'journal-override':
      const newJournalEntry = {
        id: generateId(),
        createdAt: new Date().toISOString(),
        title: `Orphaned thought from: ${orphan.taskName}`,
        content: `On ${new Date(orphan.originalDate).toLocaleDateString()}, this thought was recorded:\n\n"${orphan.override.thoughts}"`,
        icon: orphan.taskIcon || 'fa-solid fa-note-sticky',
      };
      appState.journal.push(newJournalEntry);
      saveData(); // Save the new journal entry
      removeOrphanFromList(orphanId);
      break;
    case 'delete-override':
      // This just requires removing it from the UI. The actual deletion
      // happens when `onComplete` is called with the remaining orphans.
      removeOrphanFromList(orphanId);
      break;
    }

    // Check if all orphans have been handled
    if (modalElement.querySelectorAll('.orphan-item').length === 0) {
      finishResolution();
    }
  };

  const removeOrphanFromList = (orphanId) => {
    const item = modalElement.querySelector(`.orphan-item[data-orphan-id="${orphanId}"]`);
    if (item) {
      item.remove();
    }
  };

  const finishResolution = () => {
    const remainingOrphanIds = Array.from(modalElement.querySelectorAll('.orphan-item'))
      .map(item => item.dataset.orphanId);

    onComplete(remainingOrphanIds);
    deactivateModal(modalElement);
    modalElement.remove();
  };

  modalElement.addEventListener('click', handleAction);
  const finishBtn = modalElement.querySelector('#finish-orphan-resolution-btn');
  if(finishBtn) finishBtn.addEventListener('click', finishResolution);


  // 3. Activate the modal
  activateModal(modalElement);
}


function applyOverride(task, field, value, occurrenceId, scope) {
  if (scope === 'single') {
    if (!task.occurrenceOverrides) {
      task.occurrenceOverrides = {};
    }
    if (!task.occurrenceOverrides[occurrenceId]) {
      task.occurrenceOverrides[occurrenceId] = {};
    }
    task.occurrenceOverrides[occurrenceId][field] = value;
  } else { // 'future'
    task[field] = value;
    // Optionally, clear out any specific overrides for this field that are now superseded
    for (const key in task.occurrenceOverrides) {
      if (task.occurrenceOverrides.hasOwnProperty(key)) {
        delete task.occurrenceOverrides[key][field];
        if (Object.keys(task.occurrenceOverrides[key]).length === 0) {
          delete task.occurrenceOverrides[key];
        }
      }
    }
  }
  saveData();
  updateAllTaskStatuses(true);
}

/**
 * Centralized function to create or update an override for a specific task occurrence.
 * @param {string} taskId - The ID of the parent task.
 * @param {string} occurrenceId - The unique ID of the future occurrence.
 * @param {object} updates - An object containing the fields to update (e.g., { thoughts: 'New thought', dueDate: new Date(...) }).
 */
function updateTaskOccurrence(taskId, occurrenceId, updates) {
  const task = tasks.find(t => t.id === taskId);
  if (!task) {
    console.error(`updateTaskOccurrence: Task with ID ${taskId} not found.`);
    return;
  }

  // Ensure the overrides object exists.
  if (!task.occurrenceOverrides) {
    task.occurrenceOverrides = {};
  }

  // Ensure the specific occurrence object exists.
  if (!task.occurrenceOverrides[occurrenceId]) {
    task.occurrenceOverrides[occurrenceId] = {};
  }

  // Merge the new updates into the existing override.
  Object.assign(task.occurrenceOverrides[occurrenceId], updates);

  console.log(`Updated occurrence ${occurrenceId} for task ${taskId} with:`, updates);

  // Save data and refresh the UI to reflect the changes immediately.
  saveData();
  updateAllTaskStatuses(true); // This will re-run the pipeline and update the calendar
}


function confirmHistoryDelete(historyId, taskId, deleteType) {
  if (deleteType === 'single') {
    // The historyId is in the format `hist-${index}`
    const indexToDelete = parseInt(historyId.split('-')[1], 10);
    if (!isNaN(indexToDelete)) {
      appState.historicalTasks.splice(indexToDelete, 1);
    }
  } else if (deleteType === 'all') {
    appState.historicalTasks = appState.historicalTasks.filter(h => h.originalTaskId !== taskId);
  }

  saveData();
  if (calendar) calendar.refetchEvents();
  renderTaskStats(taskId); // Re-render the stats view to show the change
}
function renderCategoryFilters() {
  if (!categoryFilterList) return;
  categoryFilterList.innerHTML = categoryFilterTemplate(categories, categoryFilter);
}

function renderStatusManager() {
  const manager = document.getElementById('status-color-manager');
  if (!manager) return;
  manager.innerHTML = statusManagerTemplate(statusNames, statusColors, defaultStatusNames, theming);
}

function renderNotificationManager() {
  const container = document.getElementById('notification-manager-content');
  if (!container) return;

  // Ensure all categories have a setting. Default to true.
  categories.forEach(cat => {
    if (notificationSettings.categories[cat.id] === undefined) {
      notificationSettings.categories[cat.id] = true;
    }
  });

  container.innerHTML = notificationManagerTemplate(notificationSettings, categories);
}

function renderThemeControls() {
  const themeModeSelector = document.getElementById('theme-mode-selector');
  if (themeModeSelector) {
    themeModeSelector.querySelectorAll('.theme-mode-btn').forEach(btn => {
      // The 'active-view-btn' class provides the "lit up" effect.
      btn.classList.remove('active-view-btn');
      if (btn.dataset.mode === theming.mode) {
        btn.classList.add('active-view-btn');
      }
    });
  }

  const calendarGradientSelector = document.getElementById('calendar-gradient-selector');
  if (calendarGradientSelector) {
    calendarGradientSelector.querySelectorAll('.calendar-gradient-btn').forEach(btn => {
      btn.classList.remove('active-view-btn');
      if (btn.dataset.source === theming.calendarGradientSource) {
        btn.classList.add('active-view-btn');
      }
    });
  }


  const themeToggle = document.getElementById('theme-enabled-toggle');
  const themeControls = document.getElementById('theme-controls');
  const themeColorPicker = document.getElementById('theme-base-color');

  if (themeToggle) themeToggle.checked = theming.enabled;
  if (themeColorPicker) themeColorPicker.value = theming.baseColor;
  if (themeControls) themeControls.classList.toggle('hidden', !theming.enabled);
}

function renderKpiTaskSelect() {
  if (!kpiTaskSelect) return;

  const kpiCount = tasks.filter(t => t.isKpi).length;
  const limitReached = kpiCount >= 49;

  // Disable buttons and set tooltip if limit is reached
  if (addNewKpiBtn) {
    addNewKpiBtn.disabled = limitReached;
    addNewKpiBtn.title = limitReached ? 'Delete one of your KPIs before adding another' : 'Add a new task and set it as a KPI';
  }
  if (setKpiBtn) {
    setKpiBtn.disabled = limitReached;
    setKpiBtn.title = limitReached ? 'Delete one of your KPIs before adding another' : 'Set the selected task as a KPI';
  }


  kpiTaskSelect.innerHTML = '';
  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = '-- Select a task --';
  kpiTaskSelect.appendChild(defaultOption);

  const nonKpiTasks = tasks.filter(task => !task.isKpi);

  const groupedTasks = nonKpiTasks.reduce((acc, task) => {
    const category = categories.find(c => c.id === task.categoryId);
    const categoryName = category ? category.name : 'Uncategorized';
    if (!acc[categoryName]) {
      acc[categoryName] = [];
    }
    acc[categoryName].push(task);
    return acc;
  }, {});

  Object.keys(groupedTasks).sort().forEach(categoryName => {
    const optgroup = document.createElement('optgroup');
    optgroup.label = categoryName;
    groupedTasks[categoryName].sort((a, b) => a.name.localeCompare(b.name)).forEach(task => {
      const option = document.createElement('option');
      option.value = task.id;
      option.textContent = task.name;
      optgroup.appendChild(option);
    });
    kpiTaskSelect.appendChild(optgroup);
  });
}

function renderKpiList(weekOffset = 0) {
  const kpiControls = document.getElementById('kpi-controls');
  const kpiChartContainer = document.getElementById('kpi-chart-container');

  if (!kpiControls || !kpiChartContainer) return;

  // 1. Clear previous content and destroy old charts
  kpiControls.innerHTML = '';
  kpiChartContainer.innerHTML = '';
  kpiChartContainer.className = 'relative';

  if (kpiChart) {
    kpiChart.destroy();
    kpiChart = null;
  }
  if (kpiCharts.length > 0) {
    kpiCharts.forEach(chart => chart.destroy());
    kpiCharts = [];
  }

  // 2. Render Controls
  const controlsHtml = `
        <div class="flex items-center space-x-2">
            <label for="kpi-range-select" class="form-label mb-0">Range:</label>
            <select id="kpi-range-select">
                <option value="8d" ${uiSettings.kpiChartDateRange === '8d' ? 'selected' : ''}>Last 8 Days</option>
                <option value="30d" ${uiSettings.kpiChartDateRange === '30d' ? 'selected' : ''}>Last 30 Days</option>
                <option value="90d" ${uiSettings.kpiChartDateRange === '90d' ? 'selected' : ''}>Last 90 Days</option>
            </select>
        </div>
        <div class="flex items-center space-x-2">
            <label class="form-label mb-0">View:</label>
            <div class="flex space-x-1 rounded-md p-1 bg-secondary">
                <button data-mode="single" class="btn btn-secondary btn-sm kpi-view-toggle-btn ${uiSettings.kpiChartMode === 'single' ? 'active-view-btn' : ''}">Combined</button>
                <button data-mode="stacked" class="btn btn-secondary btn-sm kpi-view-toggle-btn ${uiSettings.kpiChartMode === 'stacked' ? 'active-view-btn' : ''}">Stacked</button>
            </div>
        </div>
    `;
  kpiControls.innerHTML = controlsHtml;

  // 3. Add Event Listeners to Controls
  document.getElementById('kpi-range-select').addEventListener('change', (e) => {
    uiSettings.kpiChartDateRange = e.target.value;
    saveData();
    renderDashboardContent();
  });

  kpiControls.querySelectorAll('.kpi-view-toggle-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      uiSettings.kpiChartMode = e.target.dataset.mode;
      saveData();
      renderDashboardContent();
    });
  });

  // 4. Data Fetching and Processing
  const allPossibleKpiTasks = [...tasks, ...(appState.archivedTasks || [])];
  const kpiTasks = allPossibleKpiTasks.filter(task => task.isKpi);
  if (kpiTasks.length === 0) {
    kpiChartContainer.innerHTML = '<p class="text-gray-500 italic text-center mt-4">No KPIs set. Add a task and mark it as a KPI to see progress here.</p>';
    kpiControls.classList.add('hidden');
    return;
  }
  kpiControls.classList.remove('hidden');

  const now = new Date();
  if (weekOffset !== 0) {
    now.setDate(now.getDate() + (weekOffset * 7));
  }
  now.setHours(23, 59, 59, 999);

  const days = parseInt(uiSettings.kpiChartDateRange.replace('d', ''));
  const startDate = new Date(now.getTime() - (days - 1) * MS_PER_DAY);
  startDate.setHours(0, 0, 0, 0);

  const dateLabels = Array.from({ length: days }, (_, i) => {
    const date = new Date(startDate.getTime() + i * MS_PER_DAY);
    return date.toLocaleDateString('en-CA');
  });

  const datasets = kpiTasks.map(task => {
    const history = appState.historicalTasks.filter(h =>
      h.originalTaskId === task.id &&
            new Date(h.completionDate) >= startDate &&
            new Date(h.completionDate) <= now
    );

    const dailyData = new Map();
    history.forEach(h => {
      const dateKey = new Date(h.completionDate).toLocaleDateString('en-CA');
      if (!dailyData.has(dateKey)) {
        dailyData.set(dateKey, { completions: 0, misses: 0 });
      }
      const stats = dailyData.get(dateKey);
      const completionStatuses = ['blue', 'green', 'yellow'];
      if (completionStatuses.includes(h.status)) {
        stats.completions++;
      } else {
        stats.misses++;
      }
    });

    const accuracyData = dateLabels.map(label => {
      const dayData = dailyData.get(label);
      if (dayData) {
        const total = dayData.completions + dayData.misses;
        return total > 0 ? (dayData.completions / total) * 100 : 0;
      }
      return 0;
    });

    const category = categories.find(c => c.id === task.categoryId);
    const color = category ? category.color : '#808080';

    return {
      label: task.name,
      data: accuracyData,
      borderColor: color,
      backgroundColor: `${color}33`,
      fill: false,
      tension: 0.1,
      taskId: task.id // Associate task ID with dataset
    };
  });

  // 5. Chart Rendering
  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
      y: {
        beginAtZero: true, max: 100,
        ticks: { callback: value => `${value}%`, color: '#9ca3af' },
        grid: { color: 'rgba(255, 255, 255, 0.1)' },
        title: { display: true, text: 'Completion Accuracy', color: '#d1d5db' }
      },
      x: {
        ticks: { color: '#9ca3af', maxRotation: 45, minRotation: 45 },
        grid: { color: 'rgba(255, 255, 255, 0.1)' }
      }
    },
    plugins: {
      legend: { labels: { color: '#d1d5db' } },
      tooltip: {
        mode: 'index', intersect: false,
        callbacks: {
          label: context => `${context.dataset.label || ''}: ${context.parsed.y !== null ? context.parsed.y.toFixed(1) + '%' : ''}`
        }
      }
    },
    onClick: (event, elements, chart) => {
      console.log('KPI chart clicked. Elements:', elements);
      const canvas = chart.canvas;
      let taskId;

      if (uiSettings.kpiChartMode === 'single') {
        if (elements.length > 0) {
          const datasetIndex = elements[0].datasetIndex;
          taskId = chart.data.datasets[datasetIndex].taskId;
        } else if (chart.data.datasets.length === 1) {
          // Fallback for single-KPI view: if the click is anywhere on the chart, open the one task.
          taskId = chart.data.datasets[0].taskId;
        }
      } else {
        // In stacked mode, the taskId is on the wrapper div, which is the canvas's parent.
        if (canvas.parentElement) {
          taskId = canvas.parentElement.dataset.taskId;
        }
      }
      console.log('Determined taskId:', taskId);
      if (taskId) {
        openTaskView(taskId, false);
      }
    }
  };

  if (uiSettings.kpiChartMode === 'single') {
    kpiChartContainer.classList.add('gradient-bordered-content', 'cursor-pointer');
    kpiChartContainer.style.height = '400px';

    // Create canvas element programmatically to avoid race conditions
    const canvas = document.createElement('canvas');
    kpiChartContainer.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    kpiChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: dateLabels.map(d => new Date(d).toLocaleDateString(undefined, { month: 'short', day: 'numeric' })),
        datasets: datasets
      },
      options: chartOptions
    });
  } else { // stacked
    kpiChartContainer.classList.add('kpi-chart-stack-wrapper');
    kpiChartContainer.style.height = '';

    kpiTasks.forEach((task, index) => {
      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'gradient-bordered-content cursor-pointer';
      chartWrapper.style.height = '250px';
      chartWrapper.dataset.taskId = task.id; // Store task ID on the wrapper for the click event

      const canvas = document.createElement('canvas');
      canvas.id = `kpi-chart-${index}`;
      // The canvas itself doesn't need the taskId, the wrapper handles the click.
      chartWrapper.appendChild(canvas);
      kpiChartContainer.appendChild(chartWrapper);

      const ctx = canvas.getContext('2d');
      const singleChartOptions = JSON.parse(JSON.stringify(chartOptions));
      singleChartOptions.plugins.legend.display = false;
      singleChartOptions.plugins.title = {
        display: true, text: task.name, color: '#d1d5db', font: { size: 16 }
      };
      // Restore onClick handler which was lost during stringify
      singleChartOptions.onClick = chartOptions.onClick;

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dateLabels.map(d => new Date(d).toLocaleDateString(undefined, { month: 'short', day: 'numeric' })),
          datasets: [datasets[index]]
        },
        options: singleChartOptions
      });
      kpiCharts.push(chart);
    });
  }
}

function renderDashboardWeek(weekOffset) {
  const weeklyGoalsEl = document.getElementById('weeklyGoals');
  const weekDisplayEl = document.getElementById('dashboard-week-display');
  if (!weeklyGoalsEl || !weekDisplayEl) return;

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate() + (weekOffset * 7));
  const weekStart = startOfWeek(today, { weekStartsOn: 0 });
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekEnd.getDate() + 6);

  const weekStartDateStr = weekStart.toISOString().split('T')[0];

  const goalEntry = appState.journal.find(entry => entry.isWeeklyGoal && entry.weekStartDate === weekStartDateStr);

  weeklyGoalsEl.innerHTML = goalEntry ? goalEntry.content : '';
  weekDisplayEl.textContent = `Week of ${weekStart.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}`;
}

function renderDashboardContent() {
  renderDashboardWeek(uiSettings.dashboardWeekOffset);
  renderCategoryPieChart(uiSettings.dashboardWeekOffset);
  renderKpiList(uiSettings.dashboardWeekOffset);
}

function renderCategoryPieChart(weekOffset = 0) {
  const pieChartContainer = document.getElementById('category-pie-chart-container');
  const pieChartCanvas = document.getElementById('category-pie-chart');
  const pieChartLegend = document.getElementById('category-pie-chart-legend');

  if (!pieChartCanvas || !pieChartLegend || !pieChartContainer) {
    return;
  }

  // 1. Determine the date range for the current week.
  const now = new Date();
  if (weekOffset !== 0) {
    now.setDate(now.getDate() + (weekOffset * 7));
  }
  const weekStart = startOfWeek(now, { weekStartsOn: 0 });
  weekStart.setHours(0, 0, 0, 0);
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekEnd.getDate() + 7);

  // Define a calculation horizon that looks a bit into the future to catch spanning tasks.
  const calculationHorizon = new Date(weekEnd.getTime() + (7 * MS_PER_DAY));

  // 2. Aggregate data
  const categoryTime = {};

  // --- Helper to process any timed event (live or historical) ---
  const processEventDuration = (eventStart, eventEnd, categoryId) => {
    // Clamp the occurrence to the week's boundaries
    const effectiveStart = Math.max(new Date(eventStart).getTime(), weekStart.getTime());
    const effectiveEnd = Math.min(new Date(eventEnd).getTime(), weekEnd.getTime());

    const durationInWeekMs = Math.max(0, effectiveEnd - effectiveStart);

    if (durationInWeekMs > 0) {
      const durationInWeekMinutes = durationInWeekMs / MS_PER_MINUTE;
      const catId = categoryId || 'uncategorized';
      if (!categoryTime[catId]) {
        let categoryName = 'Uncategorized';
        let categoryColor = '#808080';

        if (catId === 'buffer_prep_combined') {
          categoryName = 'Preparation';
          categoryColor = '#A0AEC0'; // gray-500
        } else {
          const category = categories.find(c => c.id === catId);
          if (category) {
            categoryName = category.name;
            categoryColor = category.color;
          }
        }

        categoryTime[catId] = {
          name: categoryName,
          color: categoryColor,
          totalMinutes: 0
        };
      }
      categoryTime[catId].totalMinutes += durationInWeekMinutes;
    }
  };


  // --- Use runCalculationPipeline for active/future tasks ---
  const settings = {
    sensitivity: sensitivitySettings,
    vacations: appState.vacations,
    categories: categories,
    calendarCategoryFilters: {}, // Pass empty object to disable filtering
    earlyOnTimeSettings: uiSettings.earlyOnTimeSettings,
  };

  const allOccurrences = runCalculationPipeline([...tasks], calculationHorizon, settings);
  allOccurrences.forEach(occurrence => {
    if (!occurrence.scheduledStartTime || !occurrence.scheduledEndTime) return;

    // Handle Buffer Types for Dashboard
    if (occurrence.type === 'buffer') {
        if (bufferSettings.dashboard.combinePrepTime) {
            // If combined, use a special 'prep' category ID
            processEventDuration(occurrence.scheduledStartTime, occurrence.scheduledEndTime, 'buffer_prep_combined');
        } else {
            // Otherwise, count towards the parent task's category
            processEventDuration(occurrence.scheduledStartTime, occurrence.scheduledEndTime, occurrence.categoryId);
        }
    } else {
        // Standard tasks
        processEventDuration(occurrence.scheduledStartTime, occurrence.scheduledEndTime, occurrence.categoryId);
    }
  });

  // --- Process historical tasks separately ---
  appState.historicalTasks.forEach(historicalTask => {
    const durationMs = getDurationMs(historicalTask.durationAmount, historicalTask.durationUnit);
    if (durationMs > 0) {
      const occurrenceEnd = new Date(historicalTask.completionDate);
      const occurrenceStart = new Date(occurrenceEnd.getTime() - durationMs);
      processEventDuration(occurrenceStart, occurrenceEnd, historicalTask.categoryId);
    }
  });


  const totalMinutesInWeek = 7 * 24 * 60;
  const totalPlannedMinutes = Object.values(categoryTime).reduce((sum, cat) => sum + cat.totalMinutes, 0);
  const unplannedMinutes = Math.max(0, totalMinutesInWeek - totalPlannedMinutes);

  if (unplannedMinutes > 0) {
    const unplannedRatio = unplannedMinutes / totalMinutesInWeek;
    const unplannedLabel = unplannedRatio >= 0.3 ? 'Unplanned' : 'Free Time';
    const unplannedColor = '#4a5568'; // A neutral gray color

    categoryTime['unplanned'] = {
      name: unplannedLabel,
      color: unplannedColor,
      totalMinutes: unplannedMinutes
    };
  }

  const labels = Object.values(categoryTime).map(c => c.name);
  const data = Object.values(categoryTime).map(c => c.totalMinutes);
  const backgroundColors = Object.values(categoryTime).map(c => c.color);
  const totalMinutes = data.reduce((sum, value) => sum + value, 0);

  if (totalMinutes === 0) {
    pieChartContainer.innerHTML = '<p class="text-gray-500 italic text-center p-4">No task time recorded for this week.</p>';
    return;
  }

  if (!document.getElementById('category-pie-chart')) {
    pieChartContainer.innerHTML = `
            <h2 class="text-lg font-semibold mb-3 border-b pb-2 text-center">Weekly Time by Category</h2>
            <div class="relative" style="min-height: 400px;">
                <canvas id="category-pie-chart"></canvas>
            </div>
            <div id="category-pie-chart-legend" class="flex flex-wrap justify-center gap-4 mt-4"></div>
        `;
  }

  const existingChart = Chart.getChart(pieChartCanvas);
  if (existingChart) {
    existingChart.destroy();
  }

  new Chart(pieChartCanvas, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: backgroundColors,
        borderWidth: 1,
        borderColor: document.body.classList.contains('light-mode') ? '#fff' : '#111827',
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false // We are creating a custom legend
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              let label = context.label || '';
              if (label) {
                label += ': ';
              }
              const value = context.parsed;
              const hours = Math.floor(value / 60);
              const minutes = Math.round(value % 60);
              label += `${hours}h ${minutes}m`;
              const percentage = ((value / totalMinutes) * 100).toFixed(1);
              label += ` (${percentage}%)`;
              return label;
            }
          }
        }
      }
    }
  });

  pieChartLegend.innerHTML = '';
  labels.forEach((label, index) => {
    const minutes = data[index];
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = Math.round(minutes % 60);
    const percentage = totalMinutes > 0 ? ((minutes / totalMinutes) * 100).toFixed(1) : 0;
    const timeString = `${hours}h ${remainingMinutes}m`;

    const legendItem = `
            <div class="flex items-center text-sm">
                <span class="w-4 h-4 mr-2 rounded-full" style="background-color: ${backgroundColors[index]}"></span>
                <span>${label}: ${timeString} (${percentage}%)</span>
            </div>
        `;
    pieChartLegend.insertAdjacentHTML('beforeend', legendItem);
  });
}

function renderIconPicker() {
  const content = document.getElementById('icon-picker-content');
  if (!content) return;
  content.innerHTML = iconPickerTemplate(iconCategories);
}

function openIconPicker(context = 'task') {
  renderIconPicker();
  iconPickerModal.dataset.context = context; // Store the context
  activateModal(iconPickerModal);
}

function renderJournalEntry(entry) {
  // For weekly goals, the title shows the date range. For others, it's the entry title.
  // By appending T00:00:00, we ensure the date string is parsed as local time, not UTC.
  const goalDate = entry.isWeeklyGoal ? new Date(entry.weekStartDate + 'T00:00:00') : null;
  const title = entry.isWeeklyGoal ? `Week of ${goalDate.toLocaleDateString()}` : entry.title;
  const timestamp = entry.isWeeklyGoal ? goalDate : new Date(entry.createdAt);

  const rawIcon = entry.isWeeklyGoal ? (journalSettings.weeklyGoalIcon || 'fa-solid fa-bullseye') : (entry.icon || null);
  const parsedIcon = parseIconString(rawIcon);

  let iconHtml;
  if (!parsedIcon.icon) {
    iconHtml = '';
  } else if (parsedIcon.isTextIcon) {
    iconHtml = `<span class="mr-2">${parsedIcon.icon}</span>`;
  } else {
    iconHtml = `<i class="${parsedIcon.icon} mr-2"></i>`;
  }


  const buttonsHtml = `
        <div class="flex justify-end space-x-2 mt-2">
            <button data-action="editJournal" data-id="${entry.id}" class="btn btn-clear text-xs">Edit</button>
            <button data-action="deleteJournal" data-id="${entry.id}" class="btn btn-clear text-xs">Delete</button>
        </div>
    `;

  const contentLength = entry.content.length;
  const truncateLength = 500;
  let contentHtml;
  let toggleButtonHtml = '';

  const contentDisplayId = `journal-content-${entry.id}`;

  if (contentLength > truncateLength) {
    const truncatedContent = entry.content.substring(0, truncateLength);
    contentHtml = `<div id="${contentDisplayId}" class="prose mt-2 max-w-none journal-content-display">${truncatedContent}...</div>`;
    toggleButtonHtml = `<button data-action="toggleJournalContent" data-entry-id="${entry.id}" data-content-id="${contentDisplayId}" class="btn btn-clear text-xs mt-2">Show More</button>`;
  } else {
    contentHtml = `<div id="${contentDisplayId}" class="prose mt-2 max-w-none journal-content-display">${entry.content}</div>`;
  }

  return `
        <div class="journal-entry p-4 rounded-lg shadow ${entry.isWeeklyGoal ? 'bg-secondary' : ''}" data-id="${entry.id}" data-full-content="${encodeURIComponent(entry.content)}">
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-semibold">${iconHtml}${title}</h3>
                <span class="text-xs text-gray-400">${timestamp.toLocaleString()}</span>
            </div>
            ${contentHtml}
            ${toggleButtonHtml}
            <div class="text-xs text-gray-500 mt-2 text-right">${entry.editedAt ? `(Edited: ${new Date(entry.editedAt).toLocaleString()})` : ''}</div>
            ${buttonsHtml}
        </div>
    `;
}

function renderJournal() {
  console.log('renderJournal called');
  const list = document.getElementById('journal-list');
  if (!list) return;

  list.innerHTML = '';

  const searchInput = document.getElementById('journal-search-input');
  const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

  const filteredJournal = (!appState.journal || appState.journal.length === 0) ? [] : appState.journal.filter(entry => {
    if (!searchTerm) return true;
    const titleMatch = entry.title && entry.title.toLowerCase().includes(searchTerm);
    const contentMatch = entry.content && entry.content.toLowerCase().includes(searchTerm);
    return titleMatch || contentMatch;
  });

  if (filteredJournal.length === 0) {
    if (searchTerm) {
      list.innerHTML = `<p class="text-gray-500 text-center italic">No journal entries match your search for "${searchTerm}".</p>`;
    } else {
      list.innerHTML = '<p class="text-gray-500 text-center italic">No journal entries yet.</p>';
    }
    return;
  }

  const sortBy = document.getElementById('journal-sort-by').value;
  const sortDir = document.getElementById('journal-sort-direction').value;

  if (sortBy === 'date') {
    const entriesByWeek = {};
    // Group all entries by their week start date
    filteredJournal.forEach(entry => {
      const entryDateSource = entry.isWeeklyGoal ? entry.weekStartDate : entry.createdAt;
      let entryDate;
      if (entry.isWeeklyGoal && typeof entryDateSource === 'string' && entryDateSource.includes('-')) {
        const parts = entryDateSource.split('-');
        entryDate = new Date(parts[0], parts[1] - 1, parts[2]);
        entryDate.setHours(0, 0, 0, 0);
      } else {
        entryDate = new Date(entryDateSource);
      }

      let weekStartKey;
      if (entryDateSource && !isNaN(entryDate)) {
        weekStartKey = startOfWeek(entryDate, { weekStartsOn: 0 }).toISOString();
      } else {
        weekStartKey = 'undated';
      }

      if (!entriesByWeek[weekStartKey]) {
        entriesByWeek[weekStartKey] = [];
      }
      entriesByWeek[weekStartKey].push(entry);
    });

    const sortedWeeks = Object.keys(entriesByWeek).sort((a, b) => {
      if (a === 'undated') return 1;
      if (b === 'undated') return -1;
      const dateA = new Date(a);
      const dateB = new Date(b);
      return sortDir === 'asc' ? dateA - dateB : dateB - dateA;
    });

    sortedWeeks.forEach(weekStartKey => {
      const entriesForWeek = entriesByWeek[weekStartKey];
      if (entriesForWeek.length === 0) return;

      let headerText;
      if (weekStartKey === 'undated') {
        headerText = 'Undated Entries';
      } else {
        const weekStartDate = new Date(weekStartKey);
        const weekEndDate = new Date(weekStartDate);
        weekEndDate.setDate(weekEndDate.getDate() + 6);
        headerText = `Week of ${weekStartDate.toLocaleDateString()} - ${weekEndDate.toLocaleDateString()}`;
      }

      // Sort entries within the week
      entriesForWeek.sort((a, b) => {
        // Always prioritize weekly goals at the top
        if (a.isWeeklyGoal && !b.isWeeklyGoal) return -1;
        if (!a.isWeeklyGoal && b.isWeeklyGoal) return 1;

        const dateA = new Date(a.isWeeklyGoal ? a.weekStartDate : a.createdAt);
        const dateB = new Date(b.isWeeklyGoal ? b.weekStartDate : b.createdAt);
        return sortDir === 'asc' ? dateA - dateB : dateB - dateA;
      });

      const isCollapsed = uiSettings.journalWeekCollapseState && uiSettings.journalWeekCollapseState[weekStartKey] === true;
      const entriesHtml = entriesForWeek.map(entry => renderJournalEntry(entry)).join('');

      const weekGroupHtml = `
                <div class="journal-week-group my-4">
                    <div class="journal-week-header" data-action="toggleJournalWeekGroup" data-week-group="${weekStartKey}">
                        <h3 class="text-lg font-bold">${headerText}</h3>
                        <i class="fa-solid ${isCollapsed ? 'fa-chevron-right' : 'fa-chevron-down'}"></i>
                    </div>
                    <div class="journal-entries-container ${isCollapsed ? 'hidden' : ''}" data-week-entries="${weekStartKey}">
                        ${entriesHtml}
                    </div>
                </div>
            `;
      list.insertAdjacentHTML('beforeend', weekGroupHtml);
    });

  } else if (sortBy === 'icon') {
    const entriesByIcon = {};
    filteredJournal.forEach(entry => {
      const rawIcon = entry.isWeeklyGoal ? (journalSettings.weeklyGoalIcon || 'fa-solid fa-bullseye') : (entry.icon || 'No Icon');
      // Use the new parser here
      const parsed = parseIconString(rawIcon);
      const groupKey = parsed.name; // Group by the parsed name

      if (!entriesByIcon[groupKey]) {
        entriesByIcon[groupKey] = {
          icon: parsed.icon,
          isTextIcon: parsed.isTextIcon,
          originalStrings: new Set([rawIcon]), // Store the original strings that map to this group
          entries: []
        };
      }
      entriesByIcon[groupKey].entries.push(entry);
      entriesByIcon[groupKey].originalStrings.add(rawIcon);
    });

    const sortedGroupKeys = Object.keys(entriesByIcon).sort((a, b) => a.localeCompare(b));
    if (sortDir === 'desc') sortedGroupKeys.reverse();

    sortedGroupKeys.forEach(groupKey => {
      const group = entriesByIcon[groupKey];
      const { icon, isTextIcon, entries, originalStrings } = group;
      // Use the groupKey (the parsed name) as the display name
      const displayName = groupKey;
      // The unique key for collapse state should be stable, the display name is good.
      const collapseKey = displayName;
      const isOpen = uiSettings.journalIconCollapseState[collapseKey] === false;

      const entriesHtml = entries
        .sort((a, b) => {
          const dateA = new Date(a.isWeeklyGoal ? a.weekStartDate : a.createdAt);
          const dateB = new Date(b.isWeeklyGoal ? b.weekStartDate : b.createdAt);
          return dateB - dateA; // Always newest first within a group
        })
        .map(entry => renderJournalEntry(entry))
        .join('');

      let iconHtml;
      if (!icon || icon === 'No Icon') {
        iconHtml = '<span class="w-5 mr-2"></span>';
      } else if (isTextIcon) {
        // Render text-based icons (emojis, letters) directly as text
        iconHtml = `<span class="mr-2 w-5 text-center font-bold">${icon}</span>`;
      } else {
        // Render Font Awesome icons using <i> tag
        iconHtml = `<i class="${icon} mr-2 w-5 text-center"></i>`;
      }

      try {
        list.insertAdjacentHTML('beforeend', `
                <div class="collapsible-section journal-icon-group ${isOpen ? 'open' : ''}" data-section-key="${collapseKey}">
                    <div class="collapsible-header journal-icon-header" data-action="toggleJournalIconGroup" data-icon-group="${collapseKey}">
                         <div class="flex items-center">
                            ${iconHtml}
                            <span class="font-bold">${displayName}</span>
                        </div>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="collapsible-content journal-entries-container" data-icon-entries="${collapseKey}">
                        ${entriesHtml}
                    </div>
                </div>
            `);
      } catch (e) {
        console.error('Error rendering icon group:', displayName, e);
      }
    });
  }
}

function openAddIconPromptModal(taskId) {
  const existingModal = document.getElementById('add-icon-prompt-modal');
  if (existingModal) {
    existingModal.remove();
  }

  const modalHtml = addIconPromptModalTemplate(taskId);
  document.body.insertAdjacentHTML('beforeend', modalHtml);

  const modal = document.getElementById('add-icon-prompt-modal');
  const noThanksBtn = document.getElementById('prompt-no-thanks');
  const chooseIconBtn = document.getElementById('prompt-choose-icon');

  const closeModal = () => {
    if (modal) {
      deactivateModal(modal);
      modal.remove();
    }
    // After closing the prompt, always re-open the task view to show the saved thought
    const task = tasks.find(t => t.id === taskId) || (appState.archivedTasks && appState.archivedTasks.find(t => t.id === taskId));
    if (task) {
      const latestHistory = appState.historicalTasks
        .filter(h => h.originalTaskId === taskId)
        .sort((a, b) => new Date(b.actionDate) - new Date(a.actionDate))[0];
      if (latestHistory) {
        const historyEventId = `hist_${latestHistory.originalTaskId}_${latestHistory.completionDate}`;
        openTaskView(historyEventId, true);
      }
    }
  };

  noThanksBtn.addEventListener('click', closeModal);

  chooseIconBtn.addEventListener('click', () => {
    const taskIdToEdit = chooseIconBtn.dataset.taskId;
    // Close the prompt modal BEFORE opening the icon picker
    if (modal) {
      deactivateModal(modal);
      modal.remove();
    }
    // The task view will be re-opened by the icon picker's logic after an icon is selected or by the closeModal function if not.
    editingTaskId = taskIdToEdit; // Set the global editingTaskId for the icon picker to use
    openIconPicker('task');
  });

  activateModal(modal);
}


function openJournalModal(entryId = null) {
  // JIT lookup of DOM elements to prevent null reference errors.
  const journalModalEl = document.getElementById('journal-modal');
  const journalFormEl = document.getElementById('journal-form');
  const journalModalTitleEl = document.getElementById('journal-modal-title');
  const journalEntryIdInputEl = document.getElementById('journal-entry-id');
  const journalEntryTitleInputEl = document.getElementById('journal-entry-title');
  const journalEntryIconInputEl = document.getElementById('journal-entry-icon');
  const journalEntryContentInputEl = document.getElementById('journal-entry-content');

  if (!journalModalEl || !journalFormEl || !journalModalTitleEl || !journalEntryIdInputEl || !journalEntryTitleInputEl || !journalEntryIconInputEl || !journalEntryContentInputEl) {
    console.error('Could not find all required journal modal elements in the DOM.');
    return;
  }

  journalFormEl.reset();
  if (entryId) {
    const entry = appState.journal.find(e => e.id === entryId);
    if (!entry) return;
    journalModalTitleEl.textContent = 'Edit Journal Entry';
    journalEntryIdInputEl.value = entry.id;
    journalEntryTitleInputEl.value = entry.title;
    journalEntryIconInputEl.value = entry.icon || '';
    journalEntryContentInputEl.value = entry.content;
  } else {
    journalModalTitleEl.textContent = 'New Journal Entry';
    journalEntryIdInputEl.value = '';
  }
  activateModal(journalModalEl);
}

function closeJournalModal() {
  const journalModalEl = document.getElementById('journal-modal');
  if (journalModalEl) {
    deactivateModal(journalModalEl);
  }
}

function handleJournalFormSubmit(event) {
  event.preventDefault();
  const id = journalEntryIdInput.value;
  const now = new Date().toISOString();
  const entryData = {
    title: journalEntryTitleInput.value.trim(),
    icon: journalEntryIconInput.value.trim(),
    content: journalEntryContentInput.value,
  };

  if (id) { // Editing
    const entryIndex = appState.journal.findIndex(e => e.id === id);
    if (entryIndex > -1) {
      appState.journal[entryIndex] = {
        ...appState.journal[entryIndex],
        ...entryData,
        editedAt: now
      };
    }
  } else { // Creating
    entryData.id = generateId();
    entryData.createdAt = now;
    entryData.editedAt = null;
    appState.journal.push(entryData);
    if (uiSettings.userInteractions) {
      uiSettings.userInteractions.addedJournalEntry = true;
    }
  }

  savePlannerData();
  renderJournal();
  closeJournalModal();
}

function openVacationChangeModal(changedTasks, onConfirm, onCancel) {
  // Remove any existing modal first
  const existingModal = document.getElementById('vacation-change-confirm-modal');
  if (existingModal) {
    existingModal.remove();
  }

  // Create and append the new modal
  const modalHtml = vacationChangeConfirmationModalTemplate(changedTasks);
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  const modalElement = document.getElementById('vacation-change-confirm-modal');

  const confirmBtn = document.getElementById('confirm-vacation-change-btn');
  const cancelBtn = document.getElementById('cancel-vacation-change-btn');
  const closeBtn = document.getElementById('vacation-change-close-btn');

  const closeModal = () => {
    deactivateModal(modalElement);
    setTimeout(() => modalElement.remove(), 300); // Remove after transition
  };

  confirmBtn.addEventListener('click', () => {
    onConfirm();
    initialFormState = getFormState(taskForm);
    closeModal();
  });

  cancelBtn.addEventListener('click', () => {
    onCancel();
    initialFormState = getFormState(taskForm);
    closeModal();
  });

  closeBtn.addEventListener('click', () => {
    onCancel(); // Closing also cancels the change
    initialFormState = getFormState(taskForm);
    closeModal();
  });

  activateModal(modalElement);
}


function openAppointmentConflictModal(conflictedTasks) {
  // Remove any existing modal first to prevent duplicates
  const existingModal = document.getElementById('appointment-conflict-modal');
  if (existingModal) {
    existingModal.remove();
  }

  // Create a new div for the modal
  const modalDiv = document.createElement('div');
  modalDiv.id = 'appointment-conflict-modal';
  modalDiv.className = 'modal';
  modalDiv.innerHTML = appointmentConflictModalTemplate(conflictedTasks);
  document.body.appendChild(modalDiv);

  const closeModal = () => {
    deactivateModal(modalDiv);
    setTimeout(() => modalDiv.remove(), 300);
  };

  const keepBtn = document.getElementById('keep-appointments-btn');
  const rescheduleBtn = document.getElementById('reschedule-appointments-btn');
  const closeBtn = document.getElementById('appointment-conflict-close-btn');

  keepBtn.addEventListener('click', closeModal);
  closeBtn.addEventListener('click', closeModal);

  rescheduleBtn.addEventListener('click', () => {
    conflictedTasks.forEach(taskToFix => {
      const task = tasks.find(t => t.id === taskToFix.id);
      if (task && task.dueDate) {
        task.dueDate = adjustDateForVacation(new Date(task.dueDate), appState.vacations, task.categoryId, categories);
      }
    });
    saveData();
    updateAllTaskStatuses(true);
    if (calendar) calendar.refetchEvents();
    initialFormState = getFormState(taskForm);
    closeModal();
  });

  activateModal(modalDiv);
}

function checkForAppointmentConflicts() {
  const conflictedTasks = [];
  const appointments = tasks.filter(t => t.isAppointment && t.dueDate);

  for (const appt of appointments) {
    const category = categories.find(c => c.id === appt.categoryId);
    const bypassesVacation = category ? category.bypassVacation : false;
    if (bypassesVacation) {
      continue;
    }

    if (isDateInVacation(new Date(appt.dueDate), appState.vacations)) {
      conflictedTasks.push(appt);
    }
  }

  if (conflictedTasks.length > 0) {
    openAppointmentConflictModal(conflictedTasks);
  }
}

function handleVacationChange(changeAction) {
  // 1. Snapshot the current state
  const originalTasksState = JSON.parse(JSON.stringify(tasks));
  const originalVacationsState = JSON.parse(JSON.stringify(appState.vacations));
  const originalCategoriesState = JSON.parse(JSON.stringify(categories));

  // 2. Perform the action that changes the vacation state
  changeAction();

  // 3. Recalculate all due dates based on the new state
  const changedTasks = [];
  originalTasksState.forEach(originalTask => {
    const task = tasks.find(t => t.id === originalTask.id);
    const originalDueDate = originalTask.dueDate ? new Date(originalTask.dueDate) : null;
    if (!task || !originalDueDate) return;

    // Calculate the new due date based on the *potentially modified* vacation/category state
    const newDueDate = adjustDateForVacation(new Date(originalDueDate), appState.vacations, task.categoryId, categories);

    // Compare time values to see if the date actually changed
    if (newDueDate.getTime() !== originalDueDate.getTime()) {
      changedTasks.push({
        id: task.id,
        name: task.name,
        oldDueDate: originalDueDate,
        newDueDate: newDueDate
      });
    }
  });

  const onConfirm = () => {
    // Apply the new due dates to the actual tasks array
    changedTasks.forEach(change => {
      const taskToUpdate = tasks.find(t => t.id === change.id);
      if (taskToUpdate) {
        taskToUpdate.dueDate = change.newDueDate;
      }
    });
    // Save data and update UI
    saveData();
    updateAllTaskStatuses(true);
    if (calendar) calendar.refetchEvents();
    console.log('Vacation changes confirmed and applied.');
    checkForAppointmentConflicts();
  };

  const onCancel = () => {
    // Restore the original state of tasks, vacations, and categories from the deep copies
    tasks = JSON.parse(JSON.stringify(originalTasksState)).map(t => {
      t.dueDate = t.dueDate ? new Date(t.dueDate) : null;
      return t;
    });
    appState.vacations = JSON.parse(JSON.stringify(originalVacationsState));
    categories = JSON.parse(JSON.stringify(originalCategoriesState));

    // Re-render the UI to reflect the cancelled state
    renderVacationManager();
    updateAllTaskStatuses(true);
    if (calendar) calendar.refetchEvents();
    console.log('Vacation changes cancelled.');
  };

  // 4. If there are changes, open the confirmation modal
  if (changedTasks.length > 0) {
    openVacationChangeModal(changedTasks, onConfirm, onCancel);
  } else {
    // If no tasks were affected, just save the data (e.g., an empty vacation was deleted)
    saveData();
    if (calendar) calendar.refetchEvents();
    checkForAppointmentConflicts();
  }
}

function handleAddVacation(event) {
  event.preventDefault();
  const nameInput = document.getElementById('vacation-name');
  const startDateInput = document.getElementById('vacation-start-date');
  const endDateInput = document.getElementById('vacation-end-date');

  if (!nameInput || !startDateInput || !endDateInput) return;

  const name = nameInput.value.trim();
  const startDate = startDateInput.value;
  const endDate = endDateInput.value;

  if (name && startDate && endDate) {
    if (new Date(endDate) < new Date(startDate)) {
      alert('End date cannot be before the start date.');
      return;
    }

    const newVacation = {
      id: generateId(),
      name,
      startDate,
      endDate,
    };

    if (uiSettings.userInteractions) {
      uiSettings.userInteractions.addedVacation = true;
    }

    handleVacationChange(() => {
      appState.vacations.push(newVacation);
      renderVacationManager();
    });

    // Clear the form
    nameInput.value = '';
    startDateInput.value = '';
    endDateInput.value = '';
  } else {
    alert('Please fill out all fields for the vacation.');
  }
}


// =================================================================================
// S-4.0: USER ACTION HANDLERS
// =================================================================================

function getSmartDefault(field, defaultValue) {
  const history = uiSettings.smartFormHistory[field];
  if (!history || history.length === 0) {
    return defaultValue;
  }

  const counts = history.reduce((acc, value) => {
    acc[value] = (acc[value] || 0) + 1;
    return acc;
  }, {});

  let maxCount = 0;
  let mostFrequent = [];
  for (const value in counts) {
    if (counts[value] > maxCount) {
      maxCount = counts[value];
      mostFrequent = [value];
    } else if (counts[value] === maxCount) {
      mostFrequent.push(value);
    }
  }

  if (mostFrequent.length === 1) {
    return mostFrequent[0];
  } else {
    // Tie-breaker: return the one that appeared most recently
    for (let i = history.length - 1; i >= 0; i--) {
      if (mostFrequent.includes(history[i])) {
        return history[i];
      }
    }
  }
  return defaultValue;
}

function applySmartDefaults() {
  if (!uiSettings.smartFormDefaults || !uiSettings.smartFormDefaults.enabled) {
    return;
  }

  timeInputTypeSelect.value = getSmartDefault('dateType', 'due');
  completionTypeSelect.value = getSmartDefault('completionType', 'simple');
  if (repetitionUnitSelect) {
    repetitionUnitSelect.value = getSmartDefault('repetitionUnit', 'days');
  }
  if (estimatedDurationUnitSelect) {
    estimatedDurationUnitSelect.value = getSmartDefault('estimatedDurationUnit', 'minutes');
  }
  const prepTimeUnitSelect = document.getElementById('prep-time-unit');
  if (prepTimeUnitSelect) {
    prepTimeUnitSelect.value = getSmartDefault('prepTimeUnit', 'minutes');
  }
}

function updateSmartFormHistory(taskData) {
  if (!uiSettings.smartFormHistory) {
    uiSettings.smartFormHistory = {
      dateType: [],
      completionType: [],
      repetitionUnit: [],
      estimatedDurationUnit: [],
      prepTimeUnit: [],
    };
  }

  const history = uiSettings.smartFormHistory;
  const MAX_HISTORY = 5;

  const updateFieldHistory = (field, value) => {
    if (value) {
      // Defensive check: Ensure the history array for this field exists
      if (!history[field]) {
        history[field] = [];
      }
      history[field].push(value);
      if (history[field].length > MAX_HISTORY) {
        history[field].shift();
      }
    }
  };

  updateFieldHistory('dateType', taskData.timeInputType);
  updateFieldHistory('completionType', taskData.completionType);
  if (taskData.repetitionType === 'relative') {
    updateFieldHistory('repetitionUnit', taskData.repetitionUnit);
  }
  updateFieldHistory('estimatedDurationUnit', taskData.estimatedDurationUnit);
  updateFieldHistory('prepTimeUnit', taskData.prepTimeUnit);
}


function startTimerInterval(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (!task || !task.isTimerRunning || task.completionType !== 'time') return;

  stopTaskTimer(taskId);

  const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
  const progressBeforeStart = task.currentProgress || 0;
  const timerLastStartedTimestamp = task.timerLastStarted ? new Date(task.timerLastStarted).getTime() : Date.now();

  const scheduleUpdate = () => {
    const currentTask = tasks.find(t => t.id === taskId);
    if (!currentTask || !currentTask.isTimerRunning) {
      stopTaskTimer(taskId);
      return;
    }

    const elapsedSinceStart = Date.now() - timerLastStartedTimestamp;
    const totalCurrentProgress = progressBeforeStart + elapsedSinceStart;

    const progressElement = document.getElementById(`progress-${taskId}`);
    if (progressElement) {
      progressElement.textContent = `${formatMsToTime(Math.min(totalCurrentProgress, targetMs))} / ${formatMsToTime(targetMs)}`;
    }

    if (totalCurrentProgress >= targetMs) {
      // Timer is complete, stop and trigger completion logic.
      toggleTimer(taskId);
    } else {
      // Schedule the next update aligned to the next second.
      const delay = 1000 - (Date.now() % 1000);
      taskTimers[taskId] = setTimeout(scheduleUpdate, delay);
    }
  };

  // Kick off the first update.
  scheduleUpdate();
}

function saveDataAndRefreshUI() {
  saveData();
  updateAllTaskStatuses(true);
  if (calendar) calendar.refetchEvents();
  renderKpiTaskSelect();
  renderKpiList();
  checkForAppointmentConflicts();
}

function handleFormSubmit(event) {
  event.preventDefault();
  try {
    const id = document.getElementById('task-id').value; // Get ID directly from the form
    const now = new Date();

    const taskData = {
      name: taskNameInput.value.trim(),
      description: taskDescriptionInput.value.trim(),
      timeInputType: timeInputTypeSelect.value,
      dueDateType: dueDateTypeSelect.value,
      dueDate: null,
      repetitionType: taskRepetitionSelect.value,
      maxMisses: null,
      trackMisses: true,
      requiresFullAttention: requiresFullAttentionInput.checked,
      isAppointment: isAppointmentInput.checked,
      completionType: completionTypeSelect.value,
      currentProgress: 0,
      isTimerRunning: false,
      confirmationState: null,
      overdueStartDate: null,
      pendingCycles: null,
      categoryId: null,
      isKpi: document.getElementById('is-kpi').checked,
      prepTimeAmount: document.getElementById('prep-time-amount').value ? parseInt(document.getElementById('prep-time-amount').value, 10) : null,
      prepTimeUnit: document.getElementById('prep-time-unit').value,
      repeatUntil: null,
      repeatUntilMode: taskForm.querySelector('input[name="repeat-until-mode"]:checked').value,
      repeatUntilOccurrences: null,
    };

    if (taskData.repeatUntilMode === 'date') {
      const repeatUntilDateValue = document.getElementById('repeat-until-date').value;
      if (repeatUntilDateValue) {
        taskData.repeatUntil = new Date(repeatUntilDateValue);
      }
    } else {
      const occurrencesValue = document.getElementById('repeat-until-occurrences').value;
      if (occurrencesValue) {
        taskData.repeatUntilOccurrences = parseInt(occurrencesValue, 10);
      }
    }


    if (uiSettings.userInteractions && taskData.prepTimeAmount > 0) {
      uiSettings.userInteractions.usedPrepTime = true;
    }

    if (taskData.dueDateType === 'absolute') {
      if (taskData.timeInputType === 'start') {
        const startDate = taskStartDateInput.value ? new Date(taskStartDateInput.value) : null;
        if (startDate) {
          const durationMs = getDurationMs(estimatedDurationAmountInput.value, estimatedDurationUnitSelect.value);
          taskData.dueDate = new Date(startDate.getTime() + durationMs);
        }
      } else {
        taskData.dueDate = taskDueDateInput.value ? new Date(taskDueDateInput.value) : null;
      }
    } else if (taskData.dueDateType === 'relative') {
      const amount = parseInt(relativeAmountInput.value, 10);
      const unit = relativeUnitSelect.value;
      taskData.dueDate = calculateFutureDate(amount, unit, now);
      taskData.relativeAmount = amount;
      taskData.relativeUnit = unit;
    }

    if (taskData.repetitionType === 'relative') {
      taskData.repetitionAmount = parseInt(repetitionAmountInput.value, 10);
      taskData.repetitionUnit = repetitionUnitSelect.value;
      taskData.maxMisses = maxMissesInput.value ? parseInt(maxMissesInput.value, 10) : null;
      taskData.trackMisses = trackMissesInput.checked;
    } else if (taskData.repetitionType === 'absolute') {
      taskData.repetitionAbsoluteFrequency = absoluteFrequencySelect.value;
      if (taskData.repetitionAbsoluteFrequency === 'weekly') {
        taskData.repetitionAbsoluteWeeklyDays = Array.from(weekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
      } else if (taskData.repetitionAbsoluteFrequency === 'monthly') {
        taskData.repetitionAbsoluteMonthlyMode = taskForm.monthlyOption.value;
        if (taskData.repetitionAbsoluteMonthlyMode === 'day_of_week') {
          taskData.repetitionAbsoluteNthWeekdayOccurrence = Array.from(monthlyOccurrenceCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
          taskData.repetitionAbsoluteNthWeekdayDays = Array.from(monthlyWeekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
        } else {
          taskData.repetitionAbsoluteDaysOfMonth = Array.from(monthlyDayCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
        }
      } else if (taskData.repetitionAbsoluteFrequency === 'yearly') {
        taskData.repetitionAbsoluteYearlyMonths = Array.from(yearlyMonthCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
        taskData.repetitionAbsoluteYearlyMode = taskForm.yearlyOption.value;
        if (taskData.repetitionAbsoluteYearlyMode === 'day_of_week') {
          taskData.repetitionAbsoluteNthWeekdayOccurrence = Array.from(yearlyOccurrenceCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
          taskData.repetitionAbsoluteNthWeekdayDays = Array.from(yearlyWeekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
        } else {
          taskData.repetitionAbsoluteYearlyDaysOfMonth = Array.from(yearlyDayCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
        }
      }
      taskData.trackMisses = trackMissesInput.checked;
      const maxMissesValue = maxMissesInput.value;
      if (taskData.trackMisses && (maxMissesValue === '' || maxMissesValue === null)) {
        taskData.maxMisses = 1;
      } else if (maxMissesValue !== '' && maxMissesValue !== null) {
        taskData.maxMisses = parseInt(maxMissesValue, 10);
      } else {
        taskData.maxMisses = null;
      }
    }
    const categoryValue = taskCategorySelect.value;
    if (categoryValue === 'new_category') {
      const newCategoryName = newCategoryNameInput.value.trim();
      if (newCategoryName && !categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
        const newCategory = {
          id: newCategoryName,
          name: newCategoryName,
          color: getRandomColor(),
          icon: null,
          applyIconToNewTasks: false,
          bypassVacation: false
        };
        categories.push(newCategory);
        categories.sort((a, b) => a.name.localeCompare(b.name));
        taskData.categoryId = newCategory.id;
      } else if (newCategoryName) {
        taskData.categoryId = categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase()).id;
      }
    } else if (categoryValue) {
      taskData.categoryId = categoryValue;
    }

    // Adjust due date for vacations after category is determined
    taskData.dueDate = adjustDateForVacation(taskData.dueDate, appState.vacations, taskData.categoryId, categories);

    // CRITICAL VALIDATION: Ensure the calculated due date is valid.
    if (!taskData.dueDate || isNaN(taskData.dueDate.getTime())) {
        alert('Please enter a valid Date and Time.');
        return;
    }

    // New logic to calculate repeatUntil date from occurrences
    if (taskData.repetitionType !== 'none' && taskData.repeatUntilMode === 'occurrences' && taskData.repeatUntilOccurrences > 0) {
      // We need to build a temporary task object with all the repetition rules from the form
      // to accurately calculate the occurrences.
      const tempTaskForCalc = { ...taskData };
      const occurrences = getOccurrences(tempTaskForCalc, new Date(), new Date(new Date().setFullYear(new Date().getFullYear() + 5)));
      if (occurrences.length >= taskData.repeatUntilOccurrences) {
        taskData.repeatUntil = occurrences[taskData.repeatUntilOccurrences - 1];
      }
    }


    if (taskData.completionType === 'count') {
      taskData.countTarget = countTargetInput.value ? parseInt(countTargetInput.value, 10) : null;
      taskData.estimatedDurationAmount = estimatedDurationAmountInput.value ? parseInt(estimatedDurationAmountInput.value, 10) : null;
      taskData.estimatedDurationUnit = estimatedDurationUnitSelect.value;
    } else if (taskData.completionType === 'time') {
      taskData.timeTargetAmount = timeTargetAmountInput.value ? parseInt(timeTargetAmountInput.value, 10) : null;
      taskData.timeTargetUnit = timeTargetUnitSelect.value;
      taskData.estimatedDurationAmount = taskData.timeTargetAmount;
      taskData.estimatedDurationUnit = taskData.timeTargetUnit;
    } else {
      taskData.estimatedDurationAmount = estimatedDurationAmountInput.value ? parseInt(estimatedDurationAmountInput.value, 10) : null;
      taskData.estimatedDurationUnit = estimatedDurationUnitSelect.value;
    }
    // If an ID is present, we're either editing or reinstating.
    if (id) {
      const taskIndex = tasks.findIndex(t => t.id === id);
      // If it's in the active tasks list, we're editing.
      if (taskIndex > -1) {
        const originalTask = tasks[taskIndex];
        const mergedTask = { ...originalTask, ...taskData, id: id };
        let updatedTask = sanitizeAndUpgradeTask(mergedTask);

        if (originalTask.repetitionType !== 'none' && updatedTask.repetitionType !== 'none') {
          updatedTask.misses = originalTask.misses;
        } else {
          updatedTask.misses = 0;
        }
        if (originalTask.completionType === updatedTask.completionType) {
          updatedTask.currentProgress = originalTask.currentProgress;
        } else {
          updatedTask.currentProgress = 0;
        }
        tasks[taskIndex] = updatedTask;
        if (originalTask.icon !== taskIconInput.value.trim()) {
          updateTaskIcon(id, taskIconInput.value.trim());
        }

        // --- Orphaned Override Handling ---
        const originalOccurrences = getOccurrences(originalTask, new Date(), getCalculationHorizonDate()).map(d => `${id}_${d.toISOString()}`);
        const newOccurrences = new Set(getOccurrences(updatedTask, new Date(), getCalculationHorizonDate()).map(d => `${id}_${d.toISOString()}`));
        const orphanedOverrides = [];

        if (originalTask.occurrenceOverrides) {
          for (const occurrenceId of originalOccurrences) {
            if (!newOccurrences.has(occurrenceId) && originalTask.occurrenceOverrides[occurrenceId]) {
              orphanedOverrides.push({
                occurrenceId: occurrenceId,
                taskName: originalTask.name,
                taskIcon: originalTask.icon,
                originalDate: new Date(occurrenceId.split('_')[1]),
                override: originalTask.occurrenceOverrides[occurrenceId]
              });
            }
          }
        }

        if (orphanedOverrides.length > 0) {
          const newOccurrencesForModal = getOccurrences(updatedTask, new Date(), getCalculationHorizonDate()).map(d => ({ id: `${updatedTask.id}_${d.toISOString()}`, occurrenceDueDate: d }));
          openOrphanedOverrideModal(orphanedOverrides, updatedTask, newOccurrencesForModal, (remainingOrphanIds) => {
            // Filter the overrides object to only keep the ones the user didn't resolve
            const remainingOverrides = {};
            for (const orphanId of remainingOrphanIds) {
              remainingOverrides[orphanId] = originalTask.occurrenceOverrides[orphanId];
            }
            updatedTask.occurrenceOverrides = remainingOverrides;
            // Finalize the process
            initialFormState = getFormState(taskForm);
    closeModal();
            saveDataAndRefreshUI();
          });
          return; // Stop further execution until modal is resolved
        }


      } else {
        // If it's NOT in the active list, we are reinstating it.
        taskData.id = id; // Use the original ID
        taskData.createdAt = now; // Give it a new creation date for tracking
        taskData.misses = 0; // Reset misses
        taskData.completed = false;
        taskData.status = 'green';
        taskData.icon = taskIconInput.value.trim();
        const newTask = sanitizeAndUpgradeTask(taskData);
        tasks.push(newTask);
        // Also remove it from the archived list if it exists there
        if (appState.archivedTasks) {
          appState.archivedTasks = appState.archivedTasks.filter(t => t.id !== id);
        }
      }
    } else {
      // No ID means it's a brand new task.
      taskData.id = generateId();
      taskData.createdAt = now;
      taskData.misses = 0;
      taskData.completed = false;
      taskData.status = 'green';
      taskData.icon = taskIconInput.value.trim();
      const newTask = sanitizeAndUpgradeTask(taskData);
      tasks.push(newTask);
    }

    initialFormState = getFormState(taskForm);
    closeModal();

    // Restore modal title and submit button text to defaults
    modalTitle.textContent = 'Add New Task';
    const submitButton = taskForm.querySelector('button[type="submit"]');
    if (submitButton) submitButton.textContent = 'Create Task';

    // After adding or updating, immediately run the pipeline to get the correct status
    // and save before rendering.
    updateSmartFormHistory(taskData);
    saveDataAndRefreshUI();
  } catch (e) {
    console.error('Error handling form submit:', e);
  }
}
function editTask(taskId) { openModal(taskId); }
function triggerDelete(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (task) {
    task.confirmationState = 'confirming_delete';
    saveData();
    const taskElement = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
    if (taskElement) {
      taskElement.classList.add('task-confirming-delete');
      taskElement.dataset.confirming = 'true';
      const actionArea = taskElement.querySelector(`#action-area-${taskId}`);
      if (actionArea) {
        actionArea.innerHTML = actionAreaTemplate(task);
      }
    }
  }
}
function triggerUndoConfirmation(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (task && task.status === 'blue' && task.repetitionType !== 'none') {
    task.confirmationState = 'confirming_undo';
    saveData();
    const taskElement = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
    if (taskElement) {
      taskElement.dataset.confirming = 'true';
      const commonButtonsArea = taskElement.querySelector(`#common-buttons-${taskId}`);
      if (commonButtonsArea) {
        commonButtonsArea.innerHTML = commonButtonsTemplate(task);
      }
    }
  }
}
function confirmDeleteAction(taskId, confirmed) {
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;

  if (confirmed) {
    stopAllTimers();
    tasks = tasks.filter(t => t.id !== taskId);
    saveData();
    renderTasks();
    renderKpiTaskSelect();
    renderKpiList();
    if (calendar) calendar.refetchEvents();
  } else {
    task.confirmationState = null;
    saveData();
    renderTasks();
  }
}
function triggerCompletion(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;
  if (task.isTimerRunning) toggleTimer(taskId);
  task.confirmationState = 'confirming_complete';
  const nowMs = Date.now();
  if (task.dueDate && nowMs >= task.dueDate.getTime()) {
    if (!task.overdueStartDate && task.dueDate instanceof Date && !isNaN(task.dueDate)) {
        task.overdueStartDate = task.dueDate.toISOString();
    }
    task.pendingCycles = calculatePendingCycles(task, nowMs);
  } else {
    task.pendingCycles = 1;
    delete task.overdueStartDate;
  }
  saveData();
  const taskElement = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
  if (taskElement) {
    taskElement.dataset.confirming = 'true';
    const actionArea = taskElement.querySelector(`#action-area-${taskId}`);
    if (actionArea) {
      actionArea.innerHTML = actionAreaTemplate(task);
    }
  }
}


function confirmCompletionAction(taskId, confirmed) {
  const taskIndex = tasks.findIndex(t => t.id === taskId);
  if (taskIndex === -1) return;
  let task = tasks[taskIndex];
  const now = new Date();

  if (confirmed) {
    const totalCycles = task.pendingCycles || 1;
    let progressRatio = 0;
    if (task.completionType === 'count' && task.countTarget > 0) {
      progressRatio = (task.currentProgress || 0) / task.countTarget;
    } else if (task.completionType === 'time') {
      const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
      if (targetMs > 0) progressRatio = (task.currentProgress || 0) / targetMs;
    }
    progressRatio = Math.min(1, Math.max(0, progressRatio));

    const baseDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate || now);
    // For non-repeating tasks, ensure there's a date to loop over to create the historical record.
    const allPastDueDates = (task.repetitionType === 'none')
      ? [baseDate]
      : getOccurrences(task, baseDate, now).slice(0, totalCycles);


    allPastDueDates.forEach((dueDate, index) => {
      const isFinalRecord = index === allPastDueDates.length - 1;
      const completionProgress = isFinalRecord ? progressRatio : 1;
      const occurrenceId = `${task.id}_${dueDate.toISOString()}`;
      const override = task.occurrenceOverrides && task.occurrenceOverrides[occurrenceId] ? task.occurrenceOverrides[occurrenceId] : {};

      let historicalStatus;
      const dueDateMs = dueDate.getTime();
      const originalDueDateMs = new Date(task.originalDueDate || dueDate).getTime();
      const actionDateMs = now.getTime();

      if (completionProgress < 1) {
        historicalStatus = 'yellow'; // Partial Completion
      } else if (actionDateMs < originalDueDateMs) {
        historicalStatus = 'blue'; // Early Completion
      } else {
        historicalStatus = 'green'; // On-time or Late Completion
      }

      appState.historicalTasks.push({
        originalTaskId: task.id,
        name: override.name || task.name,
        completionDate: new Date(dueDate),
        actionDate: now,
        status: historicalStatus,
        categoryId: override.categoryId || task.categoryId,
        durationAmount: override.estimatedDurationAmount || task.estimatedDurationAmount,
        durationUnit: override.estimatedDurationUnit || task.estimatedDurationUnit,
        progress: completionProgress,
        thoughts: override.thoughts || task.thoughts,
        icon: override.icon || task.icon,
        originalDueDate: new Date(dueDate),
        occurrenceId: occurrenceId
      });
    });

    if (task.trackMisses && task.maxMisses > 0 && totalCycles > 0) {
      task.misses = Math.max(0, (task.misses || 0) - totalCycles);
      task.completionReducedMisses = true;
    }
    task.currentProgress = 0;

    if (task.repetitionType !== 'none') {
      const lastDueDate = allPastDueDates.length > 0 ? allPastDueDates[allPastDueDates.length - 1] : baseDate;
      let nextDueDate = null;
      const futureOccurrences = getOccurrences(task, new Date(lastDueDate.getTime() + 1), getCalculationHorizonDate());
      if (futureOccurrences.length > 0) {
        nextDueDate = futureOccurrences[0];
      }
      task.dueDate = adjustDateForVacation(nextDueDate, appState.vacations, task.categoryId, categories);
      task.cycleEndDate = new Date(lastDueDate);

      // Check if the completion was early, and if so, lock the task by setting status to 'blue'.
      const actionDateMs = now.getTime();
      const originalDueDateMs = new Date(lastDueDate).getTime();
      if (actionDateMs < originalDueDateMs) {
        task.status = 'blue';
      } else {
        // If completed on time or late, it should just reset to green for the next cycle.
        task.status = 'green';
      }

    } else {
      task.completed = true;
      task.status = 'blue';
      task.cycleEndDate = new Date(now.getTime() + 5000); // 5-second grace period for undo
    }
  }

  task.confirmationState = null;
  delete task.pendingCycles;
  delete task.overdueStartDate;

  saveData();
  updateAllTaskStatuses(true);
}

function confirmUndoAction(taskId, confirmed) {
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;

  if (confirmed) {
    if (task.status !== 'blue') return; // Only blue (locked) tasks can be undone.

    // Find the most recent 'completed' (blue or green) history item for this task.
    let lastCompletedIndex = -1;
    for (let i = appState.historicalTasks.length - 1; i >= 0; i--) {
      const h = appState.historicalTasks[i];
      if (h.originalTaskId === taskId && (h.status === 'blue' || h.status === 'green')) {
        lastCompletedIndex = i;
        break;
      }
    }

    if (lastCompletedIndex > -1) {
      const historyItem = appState.historicalTasks[lastCompletedIndex];
      const savedProgressRatio = historyItem.progress || 0;

      // Restore progress from the historical record
      if (task.completionType === 'count' && task.countTarget > 0) {
        task.currentProgress = Math.round(savedProgressRatio * task.countTarget);
      } else if (task.completionType === 'time') {
        const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
        if (targetMs > 0) {
          task.currentProgress = Math.round(savedProgressRatio * targetMs);
        }
      }

      // Restore all override details from the historical record.
      if (historyItem.occurrenceId && task.repetitionType !== 'none') {
        if (!task.occurrenceOverrides) task.occurrenceOverrides = {};
        if (!task.occurrenceOverrides[historyItem.occurrenceId]) task.occurrenceOverrides[historyItem.occurrenceId] = {};

        // Restore all relevant fields that might have been overridden.
        const override = task.occurrenceOverrides[historyItem.occurrenceId];
        if (typeof historyItem.thoughts === 'string') override.thoughts = historyItem.thoughts;
        if (historyItem.name && historyItem.name !== task.name) override.name = historyItem.name;
        if (historyItem.icon && historyItem.icon !== task.icon) override.icon = historyItem.icon;
        if (historyItem.categoryId && historyItem.categoryId !== task.categoryId) override.categoryId = historyItem.categoryId;
        if (historyItem.durationAmount && historyItem.durationAmount !== task.estimatedDurationAmount) override.estimatedDurationAmount = historyItem.durationAmount;
        if (historyItem.durationUnit && historyItem.durationUnit !== task.estimatedDurationUnit) override.estimatedDurationUnit = historyItem.durationUnit;

      } else {
        // For non-repeating tasks or if the override was on the master, restore to the main task.
        if (typeof historyItem.thoughts === 'string') task.thoughts = historyItem.thoughts;
      }

      // Remove the historical record
      appState.historicalTasks.splice(lastCompletedIndex, 1);
    }

    // Restore task state
    task.dueDate = task.cycleEndDate ? new Date(task.cycleEndDate) : new Date();
    task.cycleEndDate = null;
    if (task.repetitionType === 'none') {
      task.completed = false; // Make non-repeating task active again
    }

    if (task.completionReducedMisses && task.trackMisses && task.maxMisses > 0) {
      task.misses = Math.min(task.maxMisses, (task.misses || 0) + 1);
    }
    delete task.completionReducedMisses;
  }

  task.confirmationState = null;
  saveData();
  updateAllTaskStatuses(true);
}
function confirmMissAction(taskId, confirmed) {
  const taskIndex = tasks.findIndex(t => t.id === taskId);
  if (taskIndex === -1) return;
  let task = tasks[taskIndex];
  const now = new Date();

  if (confirmed) {
    const totalCycles = task.pendingCycles || 1;
    const inputEl = document.getElementById(`miss-count-input-${taskId}`);
    const missesToApply = (inputEl && totalCycles > 1) ? parseInt(inputEl.value, 10) : totalCycles;
    const completionsToApply = totalCycles - missesToApply;
    const baseDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate || now);

    let progressRatio = 0;
    if (task.completionType === 'count' && task.countTarget > 0) {
      progressRatio = (task.currentProgress || 0) / task.countTarget;
    } else if (task.completionType === 'time') {
      const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
      if (targetMs > 0) progressRatio = (task.currentProgress || 0) / targetMs;
    }
    progressRatio = Math.min(1, Math.max(0, progressRatio));

    if (task.repetitionType !== 'none') {
      const allPastDueDates = getOccurrences(task, baseDate, now).slice(0, totalCycles);
      const completionDates = allPastDueDates.slice(0, completionsToApply);
      const missDates = allPastDueDates.slice(completionsToApply);
      let runningMissesCount = task.misses || 0;

      // GPA 3.0: Handle the "catch-up" completions. These are considered on-time/late.
      completionDates.forEach((dueDate, index) => {
        const isFinalRecord = (index === completionDates.length - 1) && (missDates.length === 0);
        const occurrenceId = `${task.id}_${dueDate.toISOString()}`;
        const override = task.occurrenceOverrides[occurrenceId] || {};
        appState.historicalTasks.push({
          originalTaskId: task.id, name: override.name || task.name, completionDate: new Date(dueDate), actionDate: new Date(),
          status: 'green', // GPA 3.0
          categoryId: override.categoryId || task.categoryId,
          durationAmount: override.estimatedDurationAmount || task.estimatedDurationAmount,
          durationUnit: override.estimatedDurationUnit || task.estimatedDurationUnit,
          progress: isFinalRecord ? progressRatio : 1,
          icon: override.icon || task.icon,
          thoughts: override.thoughts || task.thoughts,
          originalDueDate: new Date(dueDate),
          occurrenceId: occurrenceId
        });
      });

      // GPA 2.0-0.0: Handle the misses.
      missDates.forEach((dueDate, index) => {
        const isFinalRecordWithProgress = (index === missDates.length - 1) && progressRatio > 0;
        const occurrenceId = `${task.id}_${dueDate.toISOString()}`;
        const override = task.occurrenceOverrides[occurrenceId] || {};
        let historicalStatus;

        if (isFinalRecordWithProgress) {
          historicalStatus = 'yellow';
        } else {
          if (runningMissesCount === 0 && task.trackMisses) {
            historicalStatus = 'red';
          } else {
            historicalStatus = 'black';
          }
          runningMissesCount++;
        }

        appState.historicalTasks.push({
          originalTaskId: task.id, name: override.name || task.name, completionDate: new Date(dueDate), actionDate: new Date(),
          status: historicalStatus,
          categoryId: override.categoryId || task.categoryId,
          durationAmount: override.estimatedDurationAmount || task.estimatedDurationAmount,
          durationUnit: override.estimatedDurationUnit || task.estimatedDurationUnit,
          progress: isFinalRecordWithProgress ? progressRatio : 0,
          icon: override.icon || task.icon,
          thoughts: override.thoughts || task.thoughts,
          originalDueDate: new Date(dueDate),
          occurrenceId: occurrenceId
        });
      });

      if (completionsToApply > 0) task.misses = Math.max(0, (task.misses || 0) - completionsToApply);
      if (missesToApply > 0 && task.trackMisses) {
        const newMisses = missDates.filter((_, index) => !((index === missDates.length - 1) && progressRatio > 0)).length;
        task.misses = Math.min(task.maxMisses || Infinity, (task.misses || 0) + newMisses);
        if (appSettings.autoKpiEnabled && task.maxMisses && task.misses >= task.maxMisses && !task.isKpi) {
          task.isKpi = true;
          task.isAutoKpi = true;
        }
      }

      const lastDueDate = allPastDueDates.length > 0 ? allPastDueDates[allPastDueDates.length - 1] : baseDate;
      let nextDueDate = null;
      const futureOccurrences = getOccurrences(task, new Date(lastDueDate.getTime() + 1), getCalculationHorizonDate());
      if (futureOccurrences.length > 0) nextDueDate = futureOccurrences[0];
      task.dueDate = adjustDateForVacation(nextDueDate, appState.vacations, task.categoryId, categories);

    } else { // NON-REPEATING TASK
      let historicalStatus;
      if (progressRatio > 0 && progressRatio < 1) {
        historicalStatus = 'yellow'; // GPA 2.0-2.99: Partial miss
      } else if (progressRatio >= 1) {
        historicalStatus = 'green'; // GPA 3.0: Full completion (but late)
      } else {
        historicalStatus = 'red'; // GPA 1.0: Full miss (since it's the first)
      }

      appState.historicalTasks.push({
        originalTaskId: task.id, name: task.name, completionDate: new Date(baseDate), actionDate: now,
        status: historicalStatus, categoryId: task.categoryId,
        durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
        progress: progressRatio, originalDueDate: new Date(baseDate),
        thoughts: task.thoughts,
        icon: task.icon,
      });
      task.completed = true;
      task.status = 'blue';
      task.cycleEndDate = new Date(now.getTime() + 5000);
    }

    task.currentProgress = 0;
    task.confirmationState = null;
    delete task.pendingCycles;
    delete task.overdueStartDate;

  } else {
    task.confirmationState = 'awaiting_overdue_input';
    delete task.pendingCycles;
    delete task.overdueStartDate;
  }

  if (task.confirmationState !== 'awaiting_overdue_input') {
    task.confirmationState = null;
  }
  saveData();
  updateAllTaskStatuses(true);
}
function handleOverdueChoice(taskId, choice) {
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;
  if (!task.overdueStartDate) task.overdueStartDate = task.dueDate ? task.dueDate.toISOString() : null;
  task.pendingCycles = calculatePendingCycles(task, Date.now());
  if (choice === 'partial') {
    task.confirmationState = 'confirming_complete';
  } else {
    task.confirmationState = (choice === 'completed') ? 'confirming_complete' : 'confirming_miss';
  }
  saveData();
  const taskElement = document.querySelector(`.task-item[data-task-id="${taskId}"]`);
  if (taskElement) {
    taskElement.dataset.confirming = 'true';
    const actionArea = taskElement.querySelector(`#action-area-${taskId}`);
    if (actionArea) {
      actionArea.innerHTML = actionAreaTemplate(task);
    }
  }
}

function openSimpleEditModal(task, occurrence) {
  // Remove any existing modal first
  const existingModal = document.getElementById('simple-edit-modal');
  if (existingModal) {
    existingModal.remove();
  }

  // 1. Create and inject the modal HTML, passing categories to the template
  const modalHtml = simpleEditFormTemplate(task, occurrence, categories);
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  const modalElement = document.getElementById('simple-edit-modal');
  const form = document.getElementById('simple-edit-form');

  // 2. Setup event listeners
  const close = () => {
    deactivateModal(modalElement);
    modalElement.remove();
  };

  modalElement.addEventListener('click', (e) => {
    const actionTarget = e.target.closest('[data-action]');
    if (!actionTarget) return;

    switch (actionTarget.dataset.action) {
    case 'close-simple-edit-modal':
      close();
      break;
    case 'edit-base-task':
      close();
      openModal(task.id);
      break;
    case 'open-icon-picker-simple':
      // We need a way to link the icon picker back to this form's input
      editingTaskId = task.id; // Use the main task ID for context
      openIconPicker('simple-edit'); // A new context
      break;
    }
  });

  form.addEventListener('submit', (e) => {
    e.preventDefault();

    const taskId = document.getElementById('simple-edit-task-id').value;
    const occurrenceId = document.getElementById('simple-edit-occurrence-id').value;
    const masterTask = tasks.find(t => t.id === taskId);
    if (!masterTask) return;

    // Gather all new values from the form
    const newName = document.getElementById('simple-edit-task-name').value;
    const newDueDate = new Date(document.getElementById('simple-edit-due-date').value);
    const newIcon = document.getElementById('simple-edit-icon').value;
    const newCategoryId = document.getElementById('simple-edit-category').value;
    const newDurationAmount = document.getElementById('simple-edit-duration-amount').value;
    const newDurationUnit = document.getElementById('simple-edit-duration-unit').value;

    const updates = {
      name: newName,
      dueDate: newDueDate,
      icon: newIcon,
      categoryId: newCategoryId,
      estimatedDurationAmount: newDurationAmount ? parseInt(newDurationAmount, 10) : null,
      estimatedDurationUnit: newDurationUnit,
    };

    // Use the centralized function to apply the override for a single occurrence
    updateTaskOccurrence(taskId, occurrenceId, updates);

    saveDataAndRefreshUI();
    close();
  });


  // 3. Activate the modal
  activateModal(modalElement);
}
function incrementCount(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (!task || task.completionType !== 'count' || !task.countTarget) return;
  task.currentProgress = (task.currentProgress || 0) + 1;
  if (task.currentProgress >= task.countTarget) {
    task.currentProgress = task.countTarget;
    triggerCompletion(taskId);
  } else {
    saveData();
    renderTasks();
  }
}
function decrementCount(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (!task || task.completionType !== 'count') return;
  task.currentProgress = Math.max(0, (task.currentProgress || 0) - 1);
  saveData();
  renderTasks();
}
function toggleTimer(taskId) {
  const task = tasks.find(t => t.id === taskId);
  if (!task || task.completionType !== 'time') return;
  const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);

  if (task.isTimerRunning) {
    const elapsed = Date.now() - (new Date(task.timerLastStarted).getTime() || Date.now());
    stopTaskTimer(taskId);

    task.currentProgress = (task.currentProgress || 0) + elapsed;
    if (task.currentProgress >= targetMs) {
      task.currentProgress = targetMs;
    }
    task.isTimerRunning = false;
    task.timerLastStarted = null;

    saveData();
    renderTasks();

    if (task.currentProgress >= targetMs) {
      triggerCompletion(taskId);
    }

  } else {
    if (task.currentProgress >= targetMs) {
      triggerCompletion(taskId);
      return;
    }
    task.isTimerRunning = true;
    task.timerLastStarted = new Date().toISOString();

    startTimerInterval(taskId);

    const timerButton = document.getElementById(`timer-btn-${taskId}`);
    if (timerButton) {
      timerButton.textContent = 'Pause';
      timerButton.classList.remove('control-button-green');
      timerButton.classList.add('control-button-yellow');
    }
    saveData();
  }
}
function editProgress(taskId) {
  const task = tasks.find(t => t.id === taskId);
  const container = document.getElementById(`progress-container-${taskId}`);
  if (!task || !container) return;

  if (task.isTimerRunning) {
    toggleTimer(taskId);
  }

  container.classList.remove('h-5');

  let currentValue, max;
  if (task.completionType === 'count') {
    currentValue = task.currentProgress || 0;
    max = task.countTarget || Infinity;
  } else if (task.completionType === 'time') {
    currentValue = Math.round((task.currentProgress || 0) / MS_PER_MINUTE);
    max = Math.round(getDurationMs(task.timeTargetAmount, task.timeTargetUnit) / MS_PER_MINUTE);
  } else return;

  container.innerHTML = editProgressTemplate(taskId, currentValue, max);
  document.getElementById(`edit-progress-input-${taskId}`).focus();
}
function saveProgressEdit(taskId) {
  const task = tasks.find(t => t.id === taskId);
  const input = document.getElementById(`edit-progress-input-${taskId}`);
  if (!task || !input) return;
  let newValue = parseInt(input.value, 10);
  if (isNaN(newValue)) {
    renderTasks();
    return;
  }
  if (task.completionType === 'count') {
    const target = task.countTarget || Infinity;
    task.currentProgress = Math.max(0, Math.min(newValue, target));
    if (task.currentProgress >= target) {
      triggerCompletion(taskId);
    }
  } else if (task.completionType === 'time') {
    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
    task.currentProgress = Math.max(0, Math.min(parseMinutesToMs(newValue), targetMs));
    if (task.currentProgress >= targetMs) {
      triggerCompletion(taskId);
    }
  }
  const container = document.getElementById(`progress-container-${taskId}`);
  if (container) {
    container.classList.add('h-5');
  }
  saveData();
  renderTasks();
}
function cancelProgressEdit(taskId) {
  const container = document.getElementById(`progress-container-${taskId}`);
  if (container) {
    container.classList.add('h-5');
  }
  renderTasks();
}
function deleteCategory(categoryId) {
  // Filter out tasks that belong to the category being deleted
  tasks = tasks.filter(task => task.categoryId !== categoryId);
  // Filter out the category itself
  categories = categories.filter(cat => cat.id !== categoryId);
  saveData();
  renderCategoryManager();
  renderTasks();
  if (calendar) calendar.refetchEvents();
}
function renderAddCategoryForm() {
  const container = document.getElementById('add-category-form-container');
  if (!container) return;

  container.innerHTML = `
        <div class="flex items-center space-x-2">
            <input type="text" id="new-category-inline-name" placeholder="New Category Name" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 bg-white text-black">
            <button data-action="addCategoryFromInline" class="control-button control-button-green themed-button-secondary">Add</button>
        </div>
    `;
  document.getElementById('new-category-inline-name').focus();
}

function addCategoryFromInline() {
  const input = document.getElementById('new-category-inline-name');
  if (!input) return;

  const newCategoryName = input.value.trim();
  if (newCategoryName && !categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
    const newCategory = {
      id: newCategoryName,
      name: newCategoryName,
      color: getRandomColor(),
      icon: null,
      applyIconToNewTasks: false
    };
    categories.push(newCategory);
    categories.sort((a, b) => a.name.localeCompare(b.name));
    saveData();
    renderCategoryManager();
    renderCategoryFilters();
    // Clear the form after adding
    const container = document.getElementById('add-category-form-container');
    if (container) {
      container.innerHTML = '';
    }
  } else if (newCategoryName) {
    alert('A category with that name already exists.');
  }
}

function triggerCategoryEdit(categoryId) {
  const category = categories.find(c => c.id === categoryId);
  if (!category) return;

  renderCategoryManager();

  const displayDiv = document.getElementById(`category-display-${categoryId}`);
  if (!displayDiv) return;

  displayDiv.innerHTML = editCategoryTemplate(categoryId, category.name);
  document.getElementById(`edit-category-input-${categoryId}`).focus();
}

function saveCategoryEdit(categoryId) {
  const category = categories.find(c => c.id === categoryId);
  const input = document.getElementById(`edit-category-input-${categoryId}`);
  if (!category || !input) return;

  const newName = input.value.trim();
  if (newName && newName !== '' && !categories.find(c => c.name.toLowerCase() === newName.toLowerCase() && c.id !== categoryId)) {
    const oldId = category.id;
    category.name = newName;
    category.id = newName;
    tasks.forEach(task => {
      if (task.categoryId === oldId) {
        task.categoryId = category.id;
      }
    });
    saveData();
    renderCategoryManager();
    renderTasks();
    renderCategoryFilters();
  } else if (newName) {
    alert('A category with that name already exists or the name is invalid.');
    renderCategoryManager();
  }
}

function deleteCategoryTasks(categoryId) {
  const category = categories.find(c => c.id === categoryId);
  if (!category) return;

  const tasksToDelete = tasks.filter(task => task.categoryId === categoryId);

  if (tasksToDelete.length === 0) {
    alert(`There are no tasks in the "${category.name}" category to delete.`);
    return;
  }

  if (confirm(`Are you sure you want to delete all ${tasksToDelete.length} task(s) in the "${category.name}" category? This action cannot be undone.`)) {
    const idsToDelete = tasksToDelete.map(t => t.id);
    tasks = tasks.filter(task => !idsToDelete.includes(task.id));
    saveData();
    renderTasks();
    if (calendar) calendar.refetchEvents();
    alert('All tasks in the category have been deleted.');
  }
}

function cancelCategoryEdit(categoryId) {
  renderCategoryManager();
}

function triggerStatusNameEdit(statusKey) {
  const status = statusNames[statusKey];
  if (status === undefined) return;
  renderStatusManager();
  const displayDiv = document.getElementById(`status-display-${statusKey}`);
  if (!displayDiv) return;
  displayDiv.innerHTML = editStatusNameTemplate(statusKey, status);
  document.getElementById(`edit-status-input-${statusKey}`).focus();
}

function saveStatusNameEdit(statusKey) {
  const input = document.getElementById(`edit-status-input-${statusKey}`);
  if (!input) return;
  const newName = input.value.trim();
  if (newName && newName !== '') {
    statusNames[statusKey] = newName;
    saveData();
    renderStatusManager();
    renderTasks();
  } else {
    alert('Status name cannot be empty.');
    renderStatusManager();
  }
}

function cancelStatusNameEdit(statusKey) {
  renderStatusManager();
}

function handleBulkEditSubmit(categoryId, form) {
  const formData = new FormData(form);
  const updates = {};
  const durationAmount = formData.get('durationAmount');
  if (durationAmount) {
    updates.estimatedDurationAmount = parseInt(durationAmount, 10);
    updates.estimatedDurationUnit = formData.get('durationUnit');
  }
  const completionType = formData.get('completionType');
  if (completionType) {
    updates.completionType = completionType;
  }

  if (Object.keys(updates).length === 0) {
    alert('No changes specified. Please fill out at least one field to apply changes.');
    return;
  }

  let updatedCount = 0;
  tasks.forEach(task => {
    if (task.categoryId === categoryId) {
      Object.assign(task, updates);
      updatedCount++;
    }
  });

  // Save the settings for next time
  lastBulkEditSettings = {
    durationAmount: formData.get('durationAmount'),
    durationUnit: formData.get('durationUnit'),
    completionType: formData.get('completionType'),
  };

  if (uiSettings.userInteractions) {
    uiSettings.userInteractions.usedBulkEdit = true;
  }

  saveData();
  updateAllTaskStatuses(true);
  if (calendar) calendar.refetchEvents();

  alert(`${updatedCount} task(s) in the category have been updated.`);
  const container = document.getElementById(`bulk-edit-container-${categoryId}`);
  if(container) {
    container.innerHTML = '';
    container.classList.add('hidden');
  }
}


function triggerRestoreDefaults() {
  const container = document.getElementById('restore-defaults-container');
  if (container) {
    container.innerHTML = restoreDefaultsConfirmationTemplate();
  }
}

function confirmRestoreDefaultsAction(confirmed) {
  const container = document.getElementById('restore-defaults-container');
  if (confirmed) {
    statusColors = { ...defaultStatusColors };
    statusNames = { ...defaultStatusNames };
    sortBy = 'status';
    sortDirection = 'asc';
    theming.enabled = false;

    saveData();

    // Re-render all necessary components
    applyTheme(); // This will apply the new non-themed state
    renderStatusManager(); // This will update the status manager UI
    renderTasks(); // This will re-render tasks with default colors

    // Also update the sort dropdowns in the UI
    if(sortBySelect) sortBySelect.value = sortBy;
    if(sortDirectionSelect) sortDirectionSelect.value = sortDirection;
  }

  // Always restore the button, whether confirmed or cancelled.
  if (container) {
    container.innerHTML = '<button data-action="restoreDefaults" class="btn btn-tertiary w-full">Restore Status Colors & Names to Default</button>';
  }
}

// --- Data Migration Tool Functions ---

// Refactored to accept the modal element directly, preventing race conditions.
function analyzeAndPrepareMigrationModal(modalElement) {
  const orphanCleanupSection = modalElement.querySelector('#orphan-cleanup-section');
  const orphanSummary = modalElement.querySelector('#orphan-summary');
  const orphanListContainer = modalElement.querySelector('#orphan-list-container');
  if (!orphanCleanupSection || !orphanSummary || !orphanListContainer) {
    return;
  }

  const taskIds = new Set(tasks.map(t => t.id).concat((appState.archivedTasks || []).map(t => t.id)));
  const orphanedHistory = appState.historicalTasks
    .map((h, index) => ({ ...h, historyId: index })) // Assign a temporary unique ID
    .filter(h => h.originalTaskId && !taskIds.has(h.originalTaskId));

  if (orphanedHistory.length > 0) {
    orphanSummary.textContent = `Found ${orphanedHistory.length} orphaned history record(s).`;

    orphanListContainer.innerHTML = orphanedHistory.map(orphan => {
      const completionDate = new Date(orphan.completionDate).toLocaleString();
      return `
                <div class="flex items-center justify-between text-sm text-gray-800">
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" class="orphan-checkbox" data-history-id="${orphan.historyId}">
                        <span><strong>${orphan.name || 'Unnamed Task'}</strong> (${orphan.status})</span>
                    </label>
                    <span class="text-xs text-gray-500">${completionDate}</span>
                </div>
            `;
    }).join('');

    orphanCleanupSection.classList.remove('hidden');
  } else {
    orphanListContainer.innerHTML = '';
    orphanCleanupSection.classList.add('hidden');
  }
}

function deleteSelectedOrphansAction(modalElement) {
  if (!modalElement) return;
  const selectedIds = new Set();
  modalElement.querySelectorAll('.orphan-checkbox:checked').forEach(checkbox => {
    selectedIds.add(parseInt(checkbox.dataset.historyId, 10));
  });

  if (selectedIds.size === 0) {
    alert('No records selected for deletion.');
    return;
  }

  if (confirm(`Are you sure you want to delete ${selectedIds.size} selected history record(s)? This cannot be undone.`)) {
    const originalCount = appState.historicalTasks.length;
    appState.historicalTasks = appState.historicalTasks.filter((_, index) => !selectedIds.has(index));
    const removedCount = originalCount - appState.historicalTasks.length;

    saveData();
    analyzeAndPrepareMigrationModal(modalElement); // Re-run analysis to update the UI
    if (calendar) calendar.refetchEvents();
    alert(`${removedCount} orphaned history record(s) have been deleted.`);
  }
}


function deleteAllHistory() {
  if (confirm('Are you absolutely sure you want to delete ALL task history? This will permanently erase all completion and miss records for all tasks. This action cannot be undone.')) {
    appState.historicalTasks = [];
    saveData();
    if (calendar) {
      calendar.refetchEvents();
    }
    alert('All task history has been deleted.');
  }
}

function openDataMigrationModal(options = {}) {
  const dataMigrationModalEl = document.getElementById('data-migration-modal');
  if (!dataMigrationModalEl) return;

  dataMigrationModalEl.innerHTML = dataMigrationModalTemplate();

  // --- Weekly Goal Timezone Fix ---
  const goalFixSection = dataMigrationModalEl.querySelector('[data-section="goal-fix"]');
  const goalSummary = dataMigrationModalEl.querySelector('#goal-fix-summary');
  const goalListContainer = dataMigrationModalEl.querySelector('#goal-fix-list-container');
  const fixGoalsBtn = dataMigrationModalEl.querySelector('#fix-all-goals-btn');

  const affectedGoals = appState.journal.filter(entry => {
    if (!entry.isWeeklyGoal || !entry.weekStartDate) return false;
    // Create a date object treating the string as local time.
    // The issue arises because 'YYYY-MM-DD' is parsed as UTC midnight,
    // which can be the previous day in local time.
    const entryDate = new Date(entry.weekStartDate + 'T00:00:00');
    // A goal is affected if its local day is not Sunday (0).
    return entryDate.getDay() !== 0;
  });

  if (affectedGoals.length > 0 && goalFixSection) {
    goalSummary.textContent = `Found ${affectedGoals.length} weekly goal(s) that appear to be affected by a timezone issue (not starting on Sunday).`;
    goalListContainer.innerHTML = affectedGoals.map(goal => {
      const originalDate = new Date(goal.weekStartDate + 'T00:00:00');
      // Find the correct start of the week (Sunday) for that local date.
      const correctedDate = startOfWeek(originalDate, { weekStartsOn: 0 });
      return `
                <div class="p-2 border-b">
                    <p class="font-semibold">Goal for week of: ${originalDate.toLocaleDateString()}</p>
                    <p class="text-sm text-gray-500">This will be corrected to start on: <strong class="text-green-600">${correctedDate.toLocaleDateString()}</strong></p>
                </div>
            `;
    }).join('');
    fixGoalsBtn.addEventListener('click', () => {
      affectedGoals.forEach(goal => {
        const originalDate = new Date(goal.weekStartDate + 'T00:00:00');
        const correctedDate = startOfWeek(originalDate, { weekStartsOn: 0 });
        goal.weekStartDate = correctedDate.toISOString().split('T')[0];
      });
      // Set a flag in localStorage so this doesn't run again automatically
      const currentData = JSON.parse(localStorage.getItem('pilotPlannerDataV8')) || {};
      currentData.goalTimezoneFixV2Applied = true;
      localStorage.setItem('pilotPlannerDataV8', JSON.stringify(currentData));

      saveData(); // Save the corrected journal entries
      alert(`${affectedGoals.length} weekly goals have been corrected.`);
      deactivateModal(dataMigrationModalEl);
      renderJournal();
    });
    goalFixSection.classList.remove('hidden');
  }

  // --- Orphan Cleanup & Other Listeners ---
  analyzeAndPrepareMigrationModal(dataMigrationModalEl); // Run analysis for orphans

  // --- Modal View Logic ---
  if (options.show) {
    const allSections = dataMigrationModalEl.querySelectorAll('[data-section]');
    allSections.forEach(section => {
      if (section.dataset.section !== options.show) {
        section.classList.add('hidden');
      } else {
        section.classList.remove('hidden');
      }
    });
  }

  // --- Event Listeners ---
  const closeButton = dataMigrationModalEl.querySelector('.close-button');
  if (closeButton) {
    closeButton.addEventListener('click', () => deactivateModal(dataMigrationModalEl));
  }
  const deleteSelectedBtn = document.getElementById('delete-selected-orphans-btn');
  if (deleteSelectedBtn) {
    deleteSelectedBtn.addEventListener('click', () => {
      deleteSelectedOrphansAction(dataMigrationModalEl);
    });
  }

  const selectAllCheckbox = document.getElementById('select-all-orphans-checkbox');
  if (selectAllCheckbox) {
    selectAllCheckbox.addEventListener('change', (e) => {
      dataMigrationModalEl.querySelectorAll('.orphan-checkbox').forEach(checkbox => {
        checkbox.checked = e.target.checked;
      });
    });
  }

  const deleteAllHistoryBtn = document.getElementById('delete-all-history-btn');
  if (deleteAllHistoryBtn) {
    deleteAllHistoryBtn.addEventListener('click', deleteAllHistory);
  }

  activateModal(dataMigrationModalEl);
}

function prepareMigrationUI(data) {
  try {
    if (!Array.isArray(data) || data.length === 0) {
      alert('Error: The provided data is not a valid array of tasks.');
      return;
    }
    oldTasksData = data; // Store the raw data
    const oldTaskFields = new Set(Object.keys(data[0] || {}));
    const newTaskFields = Object.keys(sanitizeAndUpgradeTask({ id: 'test' }));
    const newTaskFieldsLower = new Set(newTaskFields.map(f => f.toLowerCase()));

    const differences = [];
    const identicals = [];

    // Find identical fields and old fields that don't match
    oldTaskFields.forEach(oldField => {
      const oldFieldLower = oldField.toLowerCase();
      if (newTaskFieldsLower.has(oldFieldLower)) {
        const newField = newTaskFields.find(f => f.toLowerCase() === oldFieldLower);
        identicals.push({ oldField, newField });
      } else {
        differences.push({ oldField, newField: null, type: 'unmapped' });
      }
    });

    // Find new fields that weren't in the old data
    const mappedOldFieldsLower = new Set(identicals.map(i => i.oldField.toLowerCase()));
    newTaskFields.forEach(newField => {
      if (!mappedOldFieldsLower.has(newField.toLowerCase())) {
        const isPresentInOld = Array.from(oldTaskFields).some(oldField => oldField.toLowerCase() === newField.toLowerCase());
        if (!isPresentInOld) {
          // Special check for prep time fields, which might be critical for the new update
          if (newField === 'prepTimeAmount' || newField === 'prepTimeUnit') {
             // We treat these as 'new' fields that should be populated with defaults if missing
             differences.push({ oldField: null, newField, type: 'new' });
          } else {
             differences.push({ oldField: null, newField, type: 'new' });
          }
        }
      }
    });

    if (differences.length === 0) {
      document.getElementById('migration-step-1').classList.add('hidden');
      document.getElementById('migration-step-2').classList.add('hidden');
      const confirmStep = document.getElementById('migration-step-confirm');
      confirmStep.classList.remove('hidden');
      const confirmMessage = document.getElementById('migration-confirm-message');
      confirmMessage.textContent = 'All task fields match perfectly. Confirm to proceed with migration.';
    } else {
      const summaryEl = document.getElementById('migration-summary');
      summaryEl.textContent = `Found ${identicals.length} identical fields (auto-mapped) and ${differences.length} differences that need your attention.`;

      const differencesArea = document.getElementById('migration-differences-area');
      differencesArea.innerHTML = '';
      const identicalArea = document.getElementById('migration-identical-area');
      identicalArea.innerHTML = '';

      differences.forEach(({ oldField, newField, type }) => {
        const row = document.createElement('div');
        row.className = 'grid grid-cols-2 gap-4 items-center';
        let label = '';
        if (type === 'unmapped') {
          label = `<label class="text-right font-medium text-yellow-800">Old Field: ${oldField}</label>`;
        } else { // 'new'
          label = `<label class="text-right font-medium text-green-800">New Field: ${newField}</label>`;
        }

        const select = document.createElement('select');
        select.className = 'w-full p-1 border rounded';
        select.dataset.oldField = oldField || '';
        select.dataset.newField = newField || '';

        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '-- Ignore this field --';
        select.appendChild(defaultOption);

        newTaskFields.forEach(nf => {
          const option = document.createElement('option');
          option.value = nf;
          option.textContent = nf;
          // Pre-select if it's a new field
          if (type === 'new' && nf === newField) {
            option.selected = true;
          }
          select.appendChild(option);
        });
        row.innerHTML = label;
        row.appendChild(select);
        differencesArea.appendChild(row);
      });

      identicals.forEach(({ oldField, newField }) => {
        const row = document.createElement('div');
        row.className = 'grid grid-cols-2 gap-4 items-center';
        row.innerHTML = `
                    <label class="text-right font-medium">${oldField}:</label>
                    <input type="text" value="${newField}" disabled class="w-full p-1 border rounded bg-gray-200">
                `;
        row.dataset.oldField = oldField;
        row.dataset.newField = newField;
        identicalArea.appendChild(row);
      });

      document.getElementById('migration-step-1').classList.add('hidden');
      document.getElementById('migration-step-2').classList.remove('hidden');
      document.getElementById('migration-step-confirm').classList.add('hidden');
    }
  } catch (error) {
    alert('An error occurred while preparing the migration interface.');
    console.error('Migration UI preparation error:', error);
  }
}

function handleMigrationFileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      prepareMigrationUI(data);
    } catch (error) {
      alert('Error parsing JSON file. Please ensure it is a valid JSON file.');
      console.error('Migration file parse error:', error);
    }
  };
  reader.readAsText(file);
}

function runMigration() {
  if (oldTasksData.length === 0) {
    alert('No data to migrate.');
    return;
  }

  if (uiSettings.userInteractions) {
    uiSettings.userInteractions.usedDataMigration = true;
  }

  const fieldMapping = {};

  // Get mappings from the differences area (user-selected)
  const differenceSelectors = document.querySelectorAll('#migration-differences-area select');
  differenceSelectors.forEach(select => {
    const oldField = select.dataset.oldField;
    const newField = select.value;
    if (oldField && newField) { // Only map if there was an old field and a new one is selected
      fieldMapping[oldField] = newField;
    }
  });

  // Get mappings from the identicals area (pre-approved)
  const identicalRows = document.querySelectorAll('#migration-identical-area > div');
  identicalRows.forEach(row => {
    if (row.dataset.oldField && row.dataset.newField) {
      fieldMapping[row.dataset.oldField] = row.dataset.newField;
    }
  });

  const newTasks = oldTasksData.map(oldTask => {
    let newTask = { id: generateId(), createdAt: new Date() };
    for (const oldField in fieldMapping) {
      const newField = fieldMapping[oldField];
      if (oldTask.hasOwnProperty(oldField)) {
        // Basic type coercion for dates
        if (newField.toLowerCase().includes('date') && typeof oldTask[oldField] === 'string') {
          const parsedDate = new Date(oldTask[oldField]);
          if (!isNaN(parsedDate)) {
            newTask[newField] = parsedDate;
          }
        } else {
          newTask[newField] = oldTask[oldField];
        }
      }
    }
    return sanitizeAndUpgradeTask(newTask);
  });

  // Merge with existing tasks, avoiding duplicates by checking a property like 'name'
  const existingTaskNames = new Set(tasks.map(t => t.name));
  const tasksToAdd = newTasks.filter(nt => !existingTaskNames.has(nt.name));

  tasks.push(...tasksToAdd);
  saveData();
  updateAllTaskStatuses(true);
  if (calendar) calendar.refetchEvents();

  alert(`Migration complete! ${tasksToAdd.length} new tasks were added. The page will now reload.`);
  deactivateModal(dataMigrationModal);
  location.reload();
}


// --- Data Portability Functions ---

function runPostImportChecks() {
  // Check for orphaned history records by comparing history with active and archived tasks.
  const taskIds = new Set(tasks.map(t => t.id).concat((appState.archivedTasks || []).map(t => t.id)));
  const orphanedHistory = appState.historicalTasks.filter(h => h.originalTaskId && !taskIds.has(h.originalTaskId));

  if (orphanedHistory.length > 0) {
    alert(`Import complete, but found ${orphanedHistory.length} orphaned history record(s). The data migration tool will now open to help you clean this up.`);
    openDataMigrationModal();
  } else {
    alert('Transfer complete!  The application will now reload.');
    location.reload();
  }
}

function exportData(exportType) {
  if (uiSettings.userInteractions) {
    uiSettings.userInteractions.exportedData = true;
  }
  const dataToExport = {
    exportFormatVersion: '1.0',
    exportDate: new Date().toISOString(),
    dataType: exportType,
    data: {}
  };

  const allSettings = {
    statusColors, statusNames, sortBy, sortDirection, notificationSettings, theming,
    calendarSettings, categoryFilter, plannerSettings, taskDisplaySettings, appSettings,
    uiSettings, sensitivitySettings
  };

  switch (exportType) {
  case 'all':
    dataToExport.data = {
      tasks,
      categories,
      appState,
      settings: allSettings
    };
    break;
  case 'tasks':
    const taskCategoryIds = new Set(tasks.map(t => t.categoryId).filter(id => id));
    const relevantCategories = categories.filter(c => taskCategoryIds.has(c.id));
    dataToExport.data = { tasks, categories: relevantCategories };
    break;
  case 'categories':
    dataToExport.data = { categories };
    break;
  case 'history':
    dataToExport.data = { appState: { historicalTasks: appState.historicalTasks } };
    break;
  case 'settings':
    dataToExport.data = { settings: allSettings };
    break;
  default:
    console.error('Unknown export type:', exportType);
    return;
  }

  const dataStr = JSON.stringify(dataToExport, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
  link.download = `task-planner-backup-${exportType}-${timestamp}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}


function importData() {
  const fileInput = document.getElementById('import-file-input');
  if (fileInput) {
    fileInput.click();
  }
}

function openImportModal(file) {
  // Ensure no other import modal is open
  const existingModal = document.getElementById('import-modal');
  if (existingModal) {
    existingModal.remove();
  }

  document.body.insertAdjacentHTML('beforeend', importModalTemplate());
  const importModal = document.getElementById('import-modal');
  const replaceBtn = document.getElementById('import-replace-btn');
  const mergeBtn = document.getElementById('import-merge-btn');
  const closeBtn = document.getElementById('import-modal-close-btn');

  const handleImport = (importMode) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        if (!importedData.exportFormatVersion || !importedData.dataType || !importedData.data) {
          alert('Error: Invalid or corrupted backup file.');
          return;
        }

        const finalizeImport = () => {
          saveData();
          loadData();
          runPostImportChecks();
        };

        if (importMode === 'replace') {
          if (!confirm('This will overwrite all existing data. Are you sure you want to continue?')) {
            return;
          }

          const data = importedData.data;
          tasks = data.tasks || [];
          categories = data.categories || [];
          if (data.appState) {
            Object.assign(appState, data.appState);
          }
          if (data.settings) {
            Object.assign(statusColors, data.settings.statusColors);
            Object.assign(statusNames, data.settings.statusNames);
            sortBy = data.settings.sortBy;
            sortDirection = data.settings.sortDirection;
            Object.assign(notificationSettings, data.settings.notificationSettings);
            Object.assign(theming, data.settings.theming);
            Object.assign(calendarSettings, data.settings.calendarSettings);
            categoryFilter = data.settings.categoryFilter;
            Object.assign(plannerSettings, data.settings.plannerSettings);
            Object.assign(taskDisplaySettings, data.settings.taskDisplaySettings);
            Object.assign(appSettings, data.settings.appSettings);
            Object.assign(sensitivitySettings, data.settings.sensitivitySettings);
            Object.assign(uiSettings, data.settings.uiSettings);
            Object.assign(journalSettings, data.settings.journalSettings);
          }

          finalizeImport();

        } else if (importMode === 'merge') {
          const conflicts = [];
          const importContent = importedData.data;

          // Detect conflicts in tasks
          if (importContent.tasks) {
            const existingTaskIds = new Set(tasks.map(t => t.id));
            importContent.tasks.forEach(importedTask => {
              if (existingTaskIds.has(importedTask.id)) {
                const existingTask = tasks.find(t => t.id === importedTask.id);
                if (JSON.stringify(existingTask) !== JSON.stringify(importedTask)) {
                  conflicts.push({ type: 'task', id: importedTask.id, existing: existingTask, imported: importedTask });
                }
              }
            });
          }

          // Detect conflicts in categories
          if (importContent.categories) {
            const existingCategoryIds = new Set(categories.map(c => c.id));
            importContent.categories.forEach(importedCategory => {
              if (existingCategoryIds.has(importedCategory.id)) {
                const existingCategory = categories.find(c => c.id === importedCategory.id);
                if (JSON.stringify(existingCategory) !== JSON.stringify(importedCategory)) {
                  conflicts.push({ type: 'category', id: importedCategory.id, existing: existingCategory, imported: importedCategory });
                }
              }
            });
          }

          if (conflicts.length > 0) {
            openConflictResolutionModal(conflicts, (resolvedData) => {
              // Apply resolutions
              resolvedData.tasks.forEach(resolvedTask => {
                const index = tasks.findIndex(t => t.id === resolvedTask.id);
                if (index > -1) tasks[index] = resolvedTask;
              });
              resolvedData.categories.forEach(resolvedCategory => {
                const index = categories.findIndex(c => c.id === resolvedCategory.id);
                if (index > -1) categories[index] = resolvedCategory;
              });

              // Add new items
              const existingTaskIds = new Set(tasks.map(t => t.id));
              importContent.tasks.forEach(importedTask => {
                if (!existingTaskIds.has(importedTask.id)) {
                  tasks.push(importedTask);
                }
              });
              const existingCategoryIds = new Set(categories.map(c => c.id));
              importContent.categories.forEach(importedCategory => {
                if (!existingCategoryIds.has(importedCategory.id)) {
                  categories.push(importedCategory);
                }
              });

              finalizeImport();
            });
          } else {
            // No conflicts, perform a simple merge
            const existingTaskIds = new Set(tasks.map(t => t.id));
            (importContent.tasks || []).forEach(importedTask => {
              if (!existingTaskIds.has(importedTask.id)) {
                tasks.push(importedTask);
              }
            });
            const existingCategoryIds = new Set(categories.map(c => c.id));
            (importContent.categories || []).forEach(importedCategory => {
              if (!existingCategoryIds.has(importedCategory.id)) {
                categories.push(importedCategory);
              }
            });
            // Also merge history if it exists
            if (importContent.appState && importContent.appState.historicalTasks) {
              const existingHistoryIds = new Set(appState.historicalTasks.map(h => h.originalTaskId + h.completionDate));
              importContent.appState.historicalTasks.forEach(h => {
                if (!existingHistoryIds.has(h.originalTaskId + h.completionDate)) {
                  appState.historicalTasks.push(h);
                }
              });
            }
            finalizeImport();
          }
        }

        deactivateModal(importModal);
        importModal.remove();

      } catch (error) {
        console.error('Error processing import file:', error);
        alert('Error: Could not parse the file. Please ensure it is a valid JSON backup file.');
      }
    };
    reader.readAsText(file);
  };

  replaceBtn.addEventListener('click', () => handleImport('replace'));
  mergeBtn.addEventListener('click', () => handleImport('merge'));
  closeBtn.addEventListener('click', () => {
    deactivateModal(importModal);
    importModal.remove();
  });

  activateModal(importModal);
}

function openConflictResolutionModal(conflicts, onComplete) {
  const existingModal = document.getElementById('conflict-resolution-modal');
  if (existingModal) {
    existingModal.remove();
  }

  document.body.insertAdjacentHTML('beforeend', conflictResolutionModalTemplate(conflicts));
  const modal = document.getElementById('conflict-resolution-modal');
  const conflictList = document.getElementById('conflict-list');
  const finishBtn = document.getElementById('finish-merge-btn');

  let resolutions = {};

  conflictList.addEventListener('click', (e) => {
    const target = e.target.closest('[data-action="resolve-conflict"]');
    if (!target) return;

    const index = target.dataset.index;
    const choice = target.dataset.choice;
    resolutions[index] = choice;

    // Visually update the UI
    const conflictItem = target.closest('.conflict-item');
    conflictItem.querySelector('button[data-choice="existing"]').classList.remove('btn-confirm');
    conflictItem.querySelector('button[data-choice="imported"]').classList.remove('btn-confirm');
    target.classList.add('btn-confirm');
    conflictItem.style.borderColor = '#22c55e'; // Green border to show it's resolved
  });

  finishBtn.addEventListener('click', () => {
    if (Object.keys(resolutions).length !== conflicts.length) {
      alert('Please resolve all conflicts before finishing the merge.');
      return;
    }

    const finalData = {
      tasks: [],
      categories: [],
      settings: {}
    };

    conflicts.forEach((conflict, index) => {
      const choice = resolutions[index];
      const chosenData = choice === 'existing' ? conflict.existing : conflict.imported;
      finalData[conflict.type + 's'].push(chosenData);
    });

    deactivateModal(modal);
    modal.remove();
    onComplete(finalData);
  });

  activateModal(modal);
}


function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) {
    // Reset the file input so the same file can be selected again
    event.target.value = '';
    return;
  }

  openImportModal(file);

  // Reset the file input so the same file can be selected again
  event.target.value = '';
}

// --- Notification Handlers ---

function handleMasterNotificationToggle(event) {
  const isEnabled = event.target.checked;

  const updateState = (enabled) => {
    notificationSettings.enabled = enabled;
    event.target.checked = enabled;
    event.target.classList.toggle('bg-green-500', enabled);
    document.getElementById('notification-details').classList.toggle('hidden', !enabled);
    saveData();
  };

  if (isEnabled) {
    if (Notification.permission === 'granted') {
      updateState(true);
    } else if (Notification.permission === 'denied') {
      alert('Notifications are blocked by your browser. Please update your site settings to allow them.');
      updateState(false);
    } else {
      Notification.requestPermission().then(permission => {
        if (permission === 'granted') {
          updateState(true);
          new Notification('Task Manager', { body: 'Notifications have been enabled!' });
        } else {
          alert('You have denied permission for notifications.');
          updateState(false);
        }
      });
    }
  } else {
    updateState(false);
  }
}

function toggleCategoryNotification(categoryId, isEnabled) {
  if (notificationSettings.categories.hasOwnProperty(categoryId)) {
    notificationSettings.categories[categoryId] = isEnabled;
    saveData();
  }
}

function updateNotificationRateLimit() {
  const amountInput = document.getElementById('notification-rate-amount');
  const unitInput = document.getElementById('notification-rate-unit');
  if (amountInput && unitInput) {
    notificationSettings.rateLimit.amount = parseInt(amountInput.value, 10) || 5;
    notificationSettings.rateLimit.unit = unitInput.value;
    saveData();
  }
}







// =================================================================================
// S-5.0: DATA MANAGEMENT & PERSISTENCE
// =================================================================================

// --- Notification Engine ---

/**
 * Schedules a single notification to be sent in the future.
 * @param {object} task - The task object for the notification.
 * @param {string} futureStatus - The status the task is changing to (e.g., 'yellow', 'red').
 * @param {number} triggerTimestamp - The future timestamp (in ms) when the notification should be sent.
 */
function scheduleNotification(task, futureStatus, triggerTimestamp) {
  const now = Date.now();
  const delay = triggerTimestamp - now;

  if (delay <= 0) return; // Don't schedule notifications for the past.

  // 1. Check if notifications are globally enabled.
  if (!notificationSettings.enabled) return;

  // 2. Check if the task's category is enabled for notifications.
  const categoryId = task.categoryId || 'null'; // Use 'null' for uncategorized
  if (notificationSettings.categories[categoryId] === false) return;

  // 3. Check the rate limit.
  const rateLimitMs = getDurationMs(notificationSettings.rateLimit.amount, notificationSettings.rateLimit.unit);
  const lastNotified = notificationEngine.lastNotificationTimestamps[task.id] || 0;
  if (now - lastNotified < rateLimitMs) {
    return;
  }

  const timeoutId = setTimeout(() => {
    const notificationBody = `Task "${task.name}" is now ${futureStatus}.`;
    new Notification('Task Status Change', {
      body: notificationBody,
      tag: task.id // Using a tag prevents multiple notifications for the same task.
    });
    // Update the timestamp after sending the notification.
    notificationEngine.lastNotificationTimestamps[task.id] = Date.now();
    saveData(); // Save the updated timestamps.
  }, delay);

  // Store the timeout ID so we can cancel it if the user returns to the page.
  notificationEngine.timeouts.push(timeoutId);
}

/**
 * Calculates all future status changes for active tasks and schedules notifications.
 */
function calculateAndScheduleAllNotifications() {
  const now = Date.now();

  tasks.forEach(task => {
    // Skip completed, locked, or tasks with pending user actions.
    if (task.completed || task.status === 'blue' || task.confirmationState) return;
    if (!task.dueDate || isNaN(task.dueDate)) return;

    const dueDateMs = task.dueDate.getTime();
    const estimateMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit) || (30 * MS_PER_MINUTE);

    // Define potential trigger points for status changes.
    const triggerPoints = [
      { status: 'yellow', timestamp: dueDateMs - (estimateMs * 2) },
      { status: 'red', timestamp: dueDateMs - estimateMs },
      { status: 'red', timestamp: dueDateMs } // Becomes overdue
    ];

    triggerPoints.forEach(point => {
      if (point.timestamp > now) {
        scheduleNotification(task, point.status, point.timestamp);
      }
    });
  });

}

/**
 * Starts the notification engine when the page becomes hidden.
 */
function startNotificationEngine() {
  // Ensure the engine is clean before starting.
  stopNotificationEngine();
  calculateAndScheduleAllNotifications();
}

/**
 * Stops the notification engine and clears all scheduled notifications.
 */
function stopNotificationEngine() {
  notificationEngine.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
  notificationEngine.timeouts = [];
}


// --- Initialization ---

function initializeDOMElements() {
  // Task Manager
  taskModal = document.getElementById('task-modal'); taskForm = document.getElementById('task-form'); taskListDiv = document.getElementById('task-list'); modalTitle = document.getElementById('modal-title'); taskIdInput = document.getElementById('task-id'); taskNameInput = document.getElementById('task-name');
  taskDescriptionInput = document.getElementById('task-description');
  taskThoughtsInput = document.getElementById('task-thoughts');
  taskIconInput = document.getElementById('task-icon');
  iconPickerModal = document.getElementById('icon-picker-modal');
  dataMigrationModal = document.getElementById('data-migration-modal');
  timeInputTypeSelect = document.getElementById('time-input-type');
  dueDateGroup = document.getElementById('due-date-group');
  taskDueDateInput = document.getElementById('task-due-date');
  startDateGroup = document.getElementById('start-date-group');
  taskStartDateInput = document.getElementById('task-start-date');
  dueDateTypeSelect = document.getElementById('due-date-type');
  relativeDueDateGroup = document.getElementById('relative-due-date-group');
  relativeAmountInput = document.getElementById('relative-amount');
  relativeUnitSelect = document.getElementById('relative-unit');
  taskRepetitionSelect = document.getElementById('task-repetition');
  repetitionRelativeGroup = document.getElementById('repetition-relative-group');
  repetitionAmountInput = document.getElementById('repetition-amount');
  repetitionUnitSelect = document.getElementById('repetition-unit');
  repeatingOptionsGroup = document.getElementById('repeating-options-group');
  maxMissesGroup = document.getElementById('max-misses-group'); maxMissesInput = document.getElementById('max-misses');
  trackMissesInput = document.getElementById('track-misses');
  completionTypeSelect = document.getElementById('completion-type'); estimatedDurationGroup = document.getElementById('estimated-duration-group'); estimatedDurationAmountInput = document.getElementById('estimated-duration-amount'); estimatedDurationUnitSelect = document.getElementById('estimated-duration-unit'); completionCountGroup = document.getElementById('completion-count-group'); countTargetInput = document.getElementById('count-target'); completionTimeGroup = document.getElementById('completion-time-group'); timeTargetAmountInput = document.getElementById('time-target-amount'); timeTargetUnitSelect = document.getElementById('time-target-unit');
  repetitionAbsoluteGroup = document.getElementById('repetition-absolute-group');
  absoluteFrequencySelect = document.getElementById('absolute-frequency');
  absoluteWeeklyOptions = document.getElementById('absolute-weekly-options');
  absoluteMonthlyOptions = document.getElementById('absolute-monthly-options');
  absoluteYearlyOptions = document.getElementById('absolute-yearly-options');
  weekdayCheckboxes = document.querySelectorAll('input[name="weekday"]');
  monthlyDayNumberOptions = document.getElementById('monthly-day-number-options');
  monthlyDayOfWeekOptions = document.getElementById('monthly-day-of-week-options');
  yearlyDayNumberOptions = document.getElementById('yearly-day-number-options');
  yearlyDayOfWeekOptions = document.getElementById('yearly-day-of-week-options');
  monthlyOccurrenceCheckboxes = document.querySelectorAll('input[name="monthlyOccurrence"]');
  monthlyWeekdayCheckboxes = document.querySelectorAll('input[name="monthlyWeekday"]');
  monthlyDayCheckboxes = document.querySelectorAll('input[name="monthlyDay"]');
  yearlyOccurrenceCheckboxes = document.querySelectorAll('input[name="yearlyOccurrence"]');
  yearlyMonthCheckboxes = document.querySelectorAll('input[name="yearlyMonth"]');
  yearlyWeekdayCheckboxes = document.querySelectorAll('input[name="yearlyWeekday"]');
  yearlyDayCheckboxes = document.querySelectorAll('input[name="yearlyDay"]');
  requiresFullAttentionInput = document.getElementById('requires-full-attention');
  isAppointmentInput = document.getElementById('is-appointment');
  taskCategorySelect = document.getElementById('task-category');
  newCategoryGroup = document.getElementById('new-category-group');
  newCategoryNameInput = document.getElementById('new-category-name');
  advancedOptionsModal = document.getElementById('advanced-options-modal');
  sortBySelect = document.getElementById('sort-by');
  sortDirectionSelect = document.getElementById('sort-direction');
  categoryFilterList = document.getElementById('category-filter-list');
  plannerDefaultCategorySelect = document.getElementById('planner-default-category');
  taskViewModal = document.getElementById('task-view-modal');
  taskViewContent = document.getElementById('task-view-content');
  taskStatsContent = document.getElementById('task-stats-content');

  // Journal
  journalModal = document.getElementById('journal-modal');
  journalForm = document.getElementById('journal-form');
  journalModalTitle = document.getElementById('journal-modal-title');
  journalEntryIdInput = document.getElementById('journal-entry-id');
  journalEntryTitleInput = document.getElementById('journal-entry-title');
  journalEntryIconInput = document.getElementById('journal-entry-icon');
  journalEntryContentInput = document.getElementById('journal-entry-content');

  // Pilot Planner
  app = document.getElementById('app');
  weeklyGoalsEl = document.getElementById('weeklyGoals');
  addNewKpiBtn = document.getElementById('add-new-kpi-btn');
  setKpiBtn = document.getElementById('set-kpi-btn');
  kpiTaskSelect = document.getElementById('kpi-task-select');
  calendarEl = document.getElementById('calendar');
  progressTrackerContainer = document.getElementById('progressTrackerContainer');
  viewBtns = document.querySelectorAll('.view-btn');
  startNewWeekBtn = document.getElementById('startNewWeekBtn');
  confirmModal = document.getElementById('confirmModal');
  cancelNewWeekBtn = document.getElementById('cancelNewWeek');
  confirmNewWeekBtn = document.getElementById('confirmNewWeek');
  prevWeekBtn = document.getElementById('prevWeekBtn');
  nextWeekBtn = document.getElementById('nextWeekBtn');
  todayBtn = document.getElementById('todayBtn');
  weekStatusEl = document.getElementById('weekStatus');
  weekDateRangeEl = document.getElementById('weekDateRange');

  // View-switching elements
  showTaskManagerBtn = document.getElementById('show-task-manager-btn');
  showCalendarBtn = document.getElementById('show-calendar-btn');
  showDashboardBtn = document.getElementById('show-dashboard-btn');
  showJournalBtn = document.getElementById('show-journal-btn');
  taskManagerView = document.getElementById('task-manager-view');
  calendarView = document.getElementById('calendar-view');
  dashboardView = document.getElementById('dashboard-view');
  journalView = document.getElementById('journal-view');
}
function setupEventListeners() {
  let mouseDownCoords = null; // Variable to track mouse position for drag detection

  // --- Main Page Actions ---
  const addTaskBtn = document.getElementById('add-task-btn');
  if (addTaskBtn) {
    addTaskBtn.addEventListener('click', () => openModal());
  }
  const viewHistoricalTasksBtn = document.getElementById('view-historical-tasks-btn');
  if (viewHistoricalTasksBtn) {
    viewHistoricalTasksBtn.addEventListener('click', openHistoricalOverviewModal);
  }
  const advancedOptionsBtnMain = document.getElementById('advancedOptionsBtnMain');
  if(advancedOptionsBtnMain) {
    advancedOptionsBtnMain.addEventListener('click', openAdvancedOptionsModal);
  }

  // --- Modal Close Buttons & Global Listeners ---
  const advancedOptionsModalEl = document.getElementById('advanced-options-modal');
  if (advancedOptionsModalEl) {
    const advOptionsCloseButton = advancedOptionsModalEl.querySelector('.close-button');
    if(advOptionsCloseButton) {
      advOptionsCloseButton.addEventListener('click', () => deactivateModal(advancedOptionsModalEl));
    }
  }

  const taskViewModalEl = document.getElementById('task-view-modal');
  if (taskViewModalEl) {
    const taskViewCloseButton = taskViewModalEl.querySelector('.close-button');
    if (taskViewCloseButton) {
      taskViewCloseButton.addEventListener('click', () => {
        deactivateModal(taskViewModalEl);
        // When closing, remove the dataset attribute so the main loop stops updating it.
        delete taskViewModalEl.dataset.viewingTaskId;
      });
    }
  }

  const taskModalEl = document.getElementById('task-modal');
  if (taskModalEl) {
    const taskFormEl = document.getElementById('task-form');
    if(taskFormEl) taskFormEl.addEventListener('submit', handleFormSubmit);

    const closeButton = taskModalEl.querySelector('.close-button');
    if (closeButton) closeButton.addEventListener('click', closeModal);

    const cancelButton = taskModalEl.querySelector('.cancel-task-button');
    if (cancelButton) cancelButton.addEventListener('click', closeModal);
  }

  const iconPickerModalEl = document.getElementById('icon-picker-modal');
  if (iconPickerModalEl) {
    const closeBtn = iconPickerModalEl.querySelector('.close-button');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => deactivateModal(iconPickerModalEl));
    }
  }

  const journalModalEl = document.getElementById('journal-modal');
  if (journalModalEl) {
    const journalFormEl = document.getElementById('journal-form');
    if (journalFormEl) journalFormEl.addEventListener('submit', handleJournalFormSubmit);

    const cancelJournalBtn = journalModalEl.querySelector('.cancel-journal-button');
    if (cancelJournalBtn) cancelJournalBtn.addEventListener('click', closeJournalModal);

    const closeJournalButton = journalModalEl.querySelector('.close-button');
    if (closeJournalButton) closeJournalButton.addEventListener('click', closeJournalModal);
  }


  window.addEventListener('mousedown', (event) => {
    if (event.target === taskModalEl) closeModal();
    if (event.target === advancedOptionsModalEl) deactivateModal(advancedOptionsModalEl);
    if (event.target === journalModalEl) deactivateModal(journalModalEl);
  });


  // --- Task Form Listeners ---
  const taskFormEl = document.getElementById('task-form');
  if (taskFormEl) {
    const simpleModeToggle = document.getElementById('simple-mode-toggle');
    if (simpleModeToggle) {
      simpleModeToggle.addEventListener('change', (e) => {
        uiSettings.isSimpleMode = !e.target.checked;
        toggleSimpleMode();
        saveData();
      });
    }

    const openIconPickerBtn = document.getElementById('open-icon-picker');
    if (openIconPickerBtn) {
      openIconPickerBtn.addEventListener('click', () => openIconPicker('task'));
    }

    const timeInputTypeSelectEl = document.getElementById('time-input-type');
    if (timeInputTypeSelectEl) {
      timeInputTypeSelectEl.addEventListener('change', (e) => {
        const isSwitchingToStart = e.target.value === 'start';
        if (isSwitchingToStart) {
          if (taskDueDateInput.value) {
            taskStartDateInput.value = taskDueDateInput.value;
          }
        } else { // Switching to Due
          if (taskStartDateInput.value) {
            taskDueDateInput.value = taskStartDateInput.value;
          }
        }
        updateDateTimeFieldsVisibility();
        const estDurInput = document.getElementById('estimated-duration-amount');
        if (estDurInput) {
          estDurInput.required = (e.target.value === 'start');
        }
      });
    }

    const taskRepetitionSelectEl = document.getElementById('task-repetition');
    if (taskRepetitionSelectEl) {
      taskRepetitionSelectEl.addEventListener('change', (e) => {
        const type = e.target.value;
        document.getElementById('repetition-relative-group').classList.toggle('hidden', type !== 'relative');
        document.getElementById('repetition-absolute-group').classList.toggle('hidden', type !== 'absolute');
        document.getElementById('repeating-options-group').classList.toggle('hidden', type === 'none');
        if (type === 'relative') {
          // Set default to hours when switching to relative
          const repetitionUnitSelect = document.getElementById('repetition-unit');
          if (repetitionUnitSelect) {
            repetitionUnitSelect.value = 'hours';
          }
        }
        if(type === 'absolute') {
          toggleAbsoluteRepetitionFields(document.getElementById('absolute-frequency').value);
        }
        if (type === 'none') {
          document.getElementById('max-misses').value = '';
          document.getElementById('track-misses').checked = true;
        }
      });
    }

    const absoluteFrequencySelectEl = document.getElementById('absolute-frequency');
    if (absoluteFrequencySelectEl) {
      absoluteFrequencySelectEl.addEventListener('change', (e) => toggleAbsoluteRepetitionFields(e.target.value));
    }

    taskFormEl.querySelectorAll('input[name="monthlyOption"]').forEach(radio => {
      radio.addEventListener('change', (e) => toggleMonthlyOptions(e.target.value));
    });
    taskFormEl.querySelectorAll('input[name="yearlyOption"]').forEach(radio => {
      radio.addEventListener('change', (e) => toggleYearlyOptions(e.target.value));
    });
    taskFormEl.querySelectorAll('input[name="repeat-until-mode"]').forEach(radio => {
      radio.addEventListener('change', () => toggleRepeatUntilFields());
    });

    const dueDateTypeSelectEl = document.getElementById('due-date-type');
    if (dueDateTypeSelectEl) {
      dueDateTypeSelectEl.addEventListener('change', () => updateDateTimeFieldsVisibility());
    }

    const completionTypeSelectEl = document.getElementById('completion-type');
    if(completionTypeSelectEl) {
      completionTypeSelectEl.addEventListener('change', (e) => toggleCompletionFields(e.target.value));
    }

    const taskCategorySelectEl = document.getElementById('task-category');
    if (taskCategorySelectEl) {
      taskCategorySelectEl.addEventListener('change', (e) => {
        const categoryId = e.target.value;
        const isNew = categoryId === 'new_category';
        document.getElementById('new-category-group').classList.toggle('hidden', !isNew);
        if (isNew) {
          document.getElementById('new-category-name').focus();
        } else {
          const category = categories.find(c => c.id === categoryId);
          if (category && category.icon && category.applyIconToNewTasks) {
            document.getElementById('task-icon').value = category.icon;
          }
        }
      });
    }
  }


  // --- Icon Picker Listeners ---
  if (iconPickerModalEl) {
    const content = document.getElementById('icon-picker-content');
    if (content) {
      content.addEventListener('click', (e) => {
        const header = e.target.closest('.icon-picker-category-header');
        if (header) {
          const grid = header.nextElementSibling;
          const icon = header.querySelector('span'); // The arrow is a span now
          grid.classList.toggle('hidden');
          icon.classList.toggle('rotate-180');
          return;
        }

        const iconWrapper = e.target.closest('[data-icon]');
        if (iconWrapper) {
          const iconClass = iconWrapper.dataset.icon;
          const context = iconPickerModalEl.dataset.context;
          const journalIconInput = document.getElementById('journal-entry-icon');
          const taskIconInputEl = document.getElementById('task-icon');

          switch (context) {
          case 'simple-edit':
            const simpleEditIconInput = document.getElementById('simple-edit-icon');
            if (simpleEditIconInput) {
              simpleEditIconInput.value = iconClass;
            }
            break;
          case 'journal':
            if (journalIconInput) journalIconInput.value = iconClass;
            break;
          case 'journalGoal':
            const weeklyGoalIconInput = document.getElementById('weekly-goal-icon-input');
            if (weeklyGoalIconInput) {
              weeklyGoalIconInput.value = iconClass;
              journalSettings.weeklyGoalIcon = iconClass;
              saveData();
            }
            break;
          case 'category':
            if (editingCategoryIdForIcon) {
              const category = categories.find(c => c.id === editingCategoryIdForIcon);
              if (category) {
                category.icon = iconClass;
                saveData();
                renderCategoryManager();
              }
              editingCategoryIdForIcon = null;
            }
            break;
          case 'task':
          default:
            if (editingTaskId) {
              updateTaskIcon(editingTaskId, iconClass);
            } else if (taskIconInputEl) {
              taskIconInputEl.value = iconClass;
            }
            break;
          case 'history':
            if (editingHistoryEventId) {
              const historyItem = appState.historicalTasks.find(h => 'hist_' + h.originalTaskId + '_' + h.completionDate === editingHistoryEventId);
              if (historyItem) {
                historyItem.icon = iconClass;
                if (uiSettings.syncTaskIcons && editingTaskId) {
                  updateTaskIcon(editingTaskId, iconClass);
                } else {
                  saveData();
                  renderTasks();
                  if (calendar) calendar.refetchEvents();
                }
                openTaskView(editingHistoryEventId, true);
              }
              editingHistoryEventId = null;
              editingTaskId = null;
            }
            break;
          case 'bulk-history':
            if (editingTaskId) {
              // This action overrides the sync setting and updates everything.
              const task = tasks.find(t => t.id === editingTaskId);
              if (task) task.icon = iconClass;

              appState.historicalTasks.forEach(h => {
                if (h.originalTaskId === editingTaskId) {
                  h.icon = iconClass;
                }
              });
              if (appState.archivedTasks) {
                appState.archivedTasks.forEach(a => {
                  if (a.id === editingTaskId) {
                    a.icon = iconClass;
                  }
                });
              }
              saveData();
              renderTasks();
              if (calendar) calendar.refetchEvents();
              // Re-open the stats view to show the change
              renderTaskStats(editingTaskId);
            }
            break;
          }
          deactivateModal(iconPickerModalEl);
        }
      });
    }
  }


  // --- Task List Listeners ---
  const taskListDivEl = document.getElementById('task-list');
  if (taskListDivEl) {
    taskListDivEl.addEventListener('mousedown', (e) => {
      mouseDownCoords = { x: e.clientX, y: e.clientY };
    });

    taskListDivEl.addEventListener('click', (event) => {
      const wasDrag = mouseDownCoords && (Math.abs(event.clientX - mouseDownCoords.x) > 5 || Math.abs(event.clientY - mouseDownCoords.y) > 5);
      mouseDownCoords = null; // Reset after use

      const collapsibleHeader = event.target.closest('.collapsible-header');
      if (collapsibleHeader) {
        const group = collapsibleHeader.dataset.group;
        if (!uiSettings.taskManagerCollapseState) {
          uiSettings.taskManagerCollapseState = {};
        }
        // Toggle the state
        uiSettings.taskManagerCollapseState[group] = !uiSettings.taskManagerCollapseState[group];
        saveData();

        // Re-render the entire task list to reflect the new state.
        // This is more robust than manually manipulating the DOM.
        renderTasks();

        return;
      }

      const taskItem = event.target.closest('.task-item');
      if (!taskItem) return;

      const actionTarget = event.target.closest('[data-action]');
      const taskId = taskItem.dataset.taskId;

      if (!actionTarget || actionTarget.dataset.action === 'viewTask') {
        if (!event.target.closest('button, a, input, .edit-progress-button')) {
          if (wasDrag) return;
          // *** FIX: Explicitly pass the source so the modal knows where it came from. ***
          openTaskView(taskId, false, null, 'task-manager');
          return;
        }
      }

      if (actionTarget) {
        const action = actionTarget.dataset.action;
        const taskIdForAction = actionTarget.dataset.taskId;
        switch (action) {
        case 'edit': editTask(taskIdForAction); break;
        case 'triggerDelete': triggerDelete(taskIdForAction); break;
        case 'triggerCompletion': triggerCompletion(taskIdForAction); break;
        case 'confirmCompletion': confirmCompletionAction(taskIdForAction, actionTarget.dataset.confirmed === 'true'); break;
        case 'handleOverdue': handleOverdueChoice(taskIdForAction, actionTarget.dataset.choice); break;
        case 'confirmMiss': confirmMissAction(taskIdForAction, actionTarget.dataset.confirmed === 'true'); break;
        case 'confirmDelete': confirmDeleteAction(taskIdForAction, actionTarget.dataset.confirmed === 'true'); break;
        case 'triggerUndo':
          triggerUndoConfirmation(taskIdForAction);
          renderTasks(); // Re-render to show confirmation
          break;
        case 'confirmUndo': confirmUndoAction(taskIdForAction, actionTarget.dataset.confirmed === 'true'); break;
        case 'incrementCount': incrementCount(taskIdForAction); break;
        case 'decrementCount': decrementCount(taskIdForAction); break;
        case 'toggleTimer': toggleTimer(taskIdForAction); break;
        case 'editProgress': editProgress(taskIdForAction); break;
        case 'saveProgress': saveProgressEdit(taskIdForAction); break;
        case 'cancelProgress': cancelProgressEdit(taskIdForAction); break;
        case 'bypass':
          const taskToBypass = tasks.find(t => t.id === taskIdForAction);
          if (taskToBypass) {
            if (taskToBypass.completionType === 'count') {
              taskToBypass.currentProgress = taskToBypass.countTarget;
            } else if (taskToBypass.completionType === 'time') {
              const targetMs = getDurationMs(taskToBypass.timeTargetAmount, taskToBypass.timeTargetUnit);
              taskToBypass.currentProgress = targetMs;
            }
            triggerCompletion(taskIdForAction);
          }
          break;
        }
      }
    });
  }

  // --- Advanced Options Listeners ---
  const advancedOptionsContentEl = document.getElementById('advanced-options-content');
  if (advancedOptionsContentEl) {
    advancedOptionsContentEl.addEventListener('click', (event) => {
      const header = event.target.closest('.collapsible-header');
      if (header) {
        const section = header.parentElement;
        const key = section.dataset.sectionKey;
        const isOpen = section.classList.toggle('open');
        uiSettings.advancedOptionsCollapseState[key] = !isOpen;
        saveData();
        return;
      }

      const target = event.target.closest('[data-action]');
      if (!target) return;
      const action = target.dataset.action;
      const categoryId = target.dataset.categoryId;
      const statusKey = target.dataset.statusKey;

      switch(action) {
      case 'toggleShowCalendarFilters':
        uiSettings.showCalendarFilters = event.target.checked;
        saveData();
        renderCalendarCategoryFilters(); // Re-render to show/hide
        break;
      case 'toggleApplyIcon':
        const category = categories.find(c => c.id === categoryId);
        if (!category) break;

        const isBeingEnabled = event.target.checked;

        if (isBeingEnabled) {
          if (!category.icon) {
            alert('Please set an icon for this category before enabling this feature.');
            event.target.checked = false; // Revert the checkbox
            return;
          }
          // Don't save the state change here. The modal will handle it.
          openCategoryIconConfirmModal(categoryId);
        } else {
          // If we are disabling it, just update the state and save.
          category.applyIconToNewTasks = false;
          saveData();
        }
        break;
      case 'openIconPicker':
        const context = target.dataset.context || 'task';
        if (context === 'category') {
          editingCategoryIdForIcon = target.dataset.categoryId;
        }
        openIconPicker(context);
        break;
      case 'bulkEdit':
        const container = document.getElementById(`bulk-edit-container-${categoryId}`);
        if (container) {
          const isHidden = container.classList.contains('hidden');
          document.querySelectorAll('[id^="bulk-edit-container-"]').forEach(c => c.classList.add('hidden'));

          if (isHidden) {
            container.innerHTML = bulkEditFormTemplate(categoryId, lastBulkEditSettings);
            container.classList.remove('hidden');
            const form = document.getElementById(`bulk-edit-form-${categoryId}`);
            form.addEventListener('submit', (e) => {
              e.preventDefault();
              handleBulkEditSubmit(categoryId, form);
            });
          }
        }
        break;
      case 'deleteAllInCategory':
        if (confirm('Are you sure you want to permanently delete all tasks in this category? This cannot be undone.')) {
          tasks = tasks.filter(t => t.categoryId !== categoryId);
          saveData();
          renderTasks();
          if (calendar) calendar.refetchEvents();
          alert('All tasks in the category have been deleted.');
        }
        break;
      case 'deleteCategory':
        if (confirm('Are you sure you want to delete this category and ALL of its associated tasks? The history for these tasks will NOT be deleted. This action cannot be undone.')) {
          deleteCategory(categoryId);
        }
        break;
      case 'deleteCategoryTasks': deleteCategoryTasks(categoryId); break;
      case 'renderCategoryAdd': renderAddCategoryForm(); break;
      case 'addCategoryFromInline': addCategoryFromInline(); break;
      case 'triggerCategoryEdit': triggerCategoryEdit(categoryId); break;
      case 'saveCategoryEdit': saveCategoryEdit(categoryId); break;
      case 'cancelCategoryEdit': cancelCategoryEdit(categoryId); break;
      case 'triggerStatusNameEdit': triggerStatusNameEdit(statusKey); break;
      case 'saveStatusNameEdit': saveStatusNameEdit(statusKey); break;
      case 'cancelStatusNameEdit': cancelStatusNameEdit(); break;
      case 'restoreDefaults': triggerRestoreDefaults(); break;
      case 'confirmRestoreDefaults': confirmRestoreDefaultsAction(target.dataset.confirmed === 'true'); break;
      case 'toggleAllNotifications': handleMasterNotificationToggle(event); break;
      case 'toggleCategoryNotification':
        toggleCategoryNotification(target.dataset.categoryId, event.target.checked);
        break;
      case 'toggleTheme':
        theming.enabled = event.target.checked;
        applyTheme();
        renderThemeControls();
        renderStatusManager(); // Re-render to update the disabled state of the status toggle
        saveData();
        break;
      case 'setCalendarGradientSource':
        const source = target.dataset.source;
        if (source) {
          theming.calendarGradientSource = source;
          applyTheme();
          renderThemeControls();
          saveData();
        }
        break;
      case 'toggleThemeForStatus':
        theming.useThemeForStatus = target.checked;
        applyTheme();
        renderStatusManager();
        saveData();
        break;
      case 'randomizeTheme':
        theming.baseColor = getRandomColor();
        applyTheme();
        renderThemeControls();
        saveData();
        break;
      case 'toggleTimeFormat':
        appSettings.use24HourFormat = event.target.checked;
        saveData();
        renderTasks();
        if (calendar) calendar.refetchEvents();
        break;
      case 'exportData':
        exportData(target.dataset.exportType);
        break;
      case 'importData':
        importData();
        break;
      case 'openMigrationTool':
        openDataMigrationModal();
        break;
      case 'toggleCreationOnClick':
        calendarSettings.allowCreationOnClick = event.target.checked;
        if (uiSettings.userInteractions) uiSettings.userInteractions.toggledCalendarClick = true;
        saveData();
        break;
      case 'deleteVacation':
        const vacationId = target.dataset.id;
        handleVacationChange(() => {
          appState.vacations = appState.vacations.filter(v => v.id !== vacationId);
          renderVacationManager();
        });
        break;
      case 'toggleVacationBypass':
        const catId = target.dataset.categoryId;
        handleVacationChange(() => {
          const categoryToUpdate = categories.find(c => c.id === catId);
          if(categoryToUpdate) {
            categoryToUpdate.bypassVacation = target.checked;
            if (uiSettings.userInteractions) uiSettings.userInteractions.usedVacationBypass = true;
          }
        });
        break;
      case 'toggleAutoKpi':
        appSettings.autoKpiEnabled = event.target.checked;
        saveData();
        break;
      case 'toggleAutoKpiRemovable':
        appSettings.autoKpiRemovable = event.target.checked;
        saveData();
        break;
      case 'toggleAllHints':
        uiSettings.hintsDisabled = event.target.checked;
        saveData();
        renderHintManager(); // Re-render to apply the disabled state
        // Also hide/show the banner itself immediately
        const hintsBanner = document.getElementById('hints-banner');
        if (hintsBanner) {
          hintsBanner.style.display = uiSettings.hintsDisabled ? 'none' : '';
        }
        break;
      case 'resetAllHints':
        if (confirm('Are you sure you want to reset all hint interactions? You will start seeing hints for features you\'ve already used again.')) {
          if (!uiSettings.userInteractions) {
            uiSettings.userInteractions = {};
          }
          // Set all known hint interactions to false
          hints.forEach(hint => {
            uiSettings.userInteractions[hint.interaction] = false;
          });
          // Also re-enable the hints system
          uiSettings.hintsDisabled = false;
          saveData();
          renderHintManager(); // Re-render the manager to show all hints as unchecked and re-enable controls
          // Ensure banner is visible again
          const banner = document.getElementById('hints-banner');
          if (banner) {
            banner.style.display = '';
          }
        }
        break;
      case 'toggleCloseModalAfterAction':
        uiSettings.closeModalAfterAction = event.target.checked;
        saveData();
        break;
      case 'toggleEarlyOnTime':
        if (!uiSettings.earlyOnTimeSettings) uiSettings.earlyOnTimeSettings = { enabled: false, displaceCalendar: false, onlyAppointments: false };
        uiSettings.earlyOnTimeSettings.enabled = event.target.checked;
        renderEarlyOnTimeSettings();
        saveData();
        break;
      case 'toggleEarlyOnTimeAppointments':
        if (!uiSettings.earlyOnTimeSettings) uiSettings.earlyOnTimeSettings = { enabled: false, displaceCalendar: false, onlyAppointments: false };
        uiSettings.earlyOnTimeSettings.onlyAppointments = event.target.checked;
        saveData();
        break;
      case 'toggleSmartFormDefaults':
        if (!uiSettings.smartFormDefaults) uiSettings.smartFormDefaults = { enabled: false };
        uiSettings.smartFormDefaults.enabled = event.target.checked;
        saveData();
        break;
      case 'toggleSyncTaskIcons':
        uiSettings.syncTaskIcons = event.target.checked;
        saveData();
        break;
      case 'toggleSortByStartDate':
        uiSettings.useStartDateForSort = event.target.checked;
        saveData();
        renderTasks(); // Re-render tasks to apply the new sort logic
        break;
      }
    });

    const importFileInput = document.getElementById('import-file-input');
    if (importFileInput) {
      importFileInput.addEventListener('change', handleFileImport);
    }

    const themeModeSelector = document.getElementById('theme-mode-selector');
    if (themeModeSelector) {
      themeModeSelector.addEventListener('click', (event) => {
        const target = event.target.closest('.theme-mode-btn');
        if (!target) return;
        const mode = target.dataset.mode;
        if (mode) {
          theming.mode = mode;
          applyTheme();
          renderThemeControls();
          saveData();
        }
      });
    }
    advancedOptionsContentEl.addEventListener('input', (event) => {
      const target = event.target;
      if (target.id === 'planner-sensitivity-slider') {
        const isDefaultToggle = document.getElementById('planner-sensitivity-default-toggle');
        isDefaultToggle.checked = false;
        sensitivitySettings.sValue = parseFloat(target.value);
        if (uiSettings.userInteractions) uiSettings.userInteractions.changedSensitivity = true;
        saveData();
        updateAllTaskStatuses(true);
      }
    });

    advancedOptionsContentEl.addEventListener('change', (event) => {
      const target = event.target;

      if (target.classList.contains('month-view-display-toggle')) {
        const key = target.name;
        if (uiSettings.monthView.hasOwnProperty(key)) {
          uiSettings.monthView[key] = target.checked;
          saveData();
          if (calendar) calendar.refetchEvents();
        }
        return;
      }

      if (target.classList.contains('week-view-display-toggle')) {
        const key = target.name;
        if (uiSettings.weekView.hasOwnProperty(key)) {
          uiSettings.weekView[key] = target.checked;
          saveData();
          if (calendar) calendar.refetchEvents();
        }
        return;
      }

      if (target.classList.contains('day-view-display-toggle')) {
        const key = target.name;
        if (uiSettings.dayView.hasOwnProperty(key)) {
          uiSettings.dayView[key] = target.checked;
          saveData();
          if (calendar) calendar.refetchEvents();
        }
        return;
      }

      if (target.classList.contains('hint-seen-checkbox')) {
        const interaction = target.dataset.interaction;
        if (interaction) {
          if (!uiSettings.userInteractions) {
            uiSettings.userInteractions = {};
          }
          uiSettings.userInteractions[interaction] = target.checked;
          saveData();
        }
        return; // Prevent other change handlers from firing
      }

      const categoryFilterListEl = document.getElementById('category-filter-list');

      if (target.id === 'planner-sensitivity-default-toggle') {
        const slider = document.getElementById('planner-sensitivity-slider');
        if (target.checked) {
          sensitivitySettings.sValue = 0.5;
          slider.value = 0.5;
          slider.disabled = true;
        } else {
          slider.disabled = false;
        }
        saveData();
        updateAllTaskStatuses(true);
        return;
      }

      if (target.id === 'app-title-input') { appSettings.title = target.value.trim(); setAppBranding(); return; }
      if (target.id === 'app-subtitle-input') { appSettings.subtitle = target.value.trim(); setAppBranding(); return; }
      if (target.id === 'app-goal-label-input') { appSettings.weeklyGoalLabel = target.value.trim(); setAppBranding(); return; }
      if (target.id === 'weekly-goal-icon-input') { journalSettings.weeklyGoalIcon = target.value.trim(); saveData(); return; }
      if (target.id === 'planner-default-icon') { if (!plannerSettings) plannerSettings = {}; plannerSettings.defaultIcon = target.value.trim(); saveData(); return; }

      if (target.classList.contains('category-color-picker')) {
        const category = categories.find(cat => cat.id === target.dataset.categoryId);
        if (category) { category.color = target.value; saveData(); renderCategoryManager(); renderTasks(); }
      } else if (target.classList.contains('category-filter-checkbox') && categoryFilterListEl) {
        const allCheckbox = categoryFilterListEl.querySelector('input[value="all"]');
        const otherCheckboxes = categoryFilterListEl.querySelectorAll('input:not([value="all"])');
        if (target.value === 'all') {
          otherCheckboxes.forEach(cb => cb.checked = false);
          categoryFilter = [];
        } else {
          allCheckbox.checked = false;
          categoryFilter = Array.from(otherCheckboxes).filter(cb => cb.checked).map(cb => cb.value === 'null' ? null : cb.value);
        }
        if (categoryFilter.length === 0) allCheckbox.checked = true;
        renderTasks();
        if (calendar) calendar.refetchEvents();
      } else if (target.classList.contains('status-color-picker')) {
        if (statusColors.hasOwnProperty(target.dataset.statusKey)) {
          statusColors[target.dataset.statusKey] = target.value;
          if (uiSettings.userInteractions) uiSettings.userInteractions.changedStatusColor = true;
          saveData();
          renderTasks();
          renderStatusManager();
        }
      } else if (target.id === 'notification-rate-amount' || target.id === 'notification-rate-unit') { updateNotificationRateLimit();
      } else if (target.id === 'theme-base-color') { theming.baseColor = target.value; applyTheme(); saveData();
      } else if (target.id === 'planner-default-category') { plannerSettings.defaultCategoryId = target.value; saveData();
      } else if (target.classList.contains('task-display-toggle')) {
        if (taskDisplaySettings.hasOwnProperty(target.name)) { taskDisplaySettings[target.name] = target.checked; saveData(); renderTasks(); }
      } else if (target.id === 'calculation-horizon-amount' || target.id === 'calculation-horizon-unit') {
        uiSettings.calculationHorizonAmount = parseInt(document.getElementById('calculation-horizon-amount').value, 10) || 1;
        uiSettings.calculationHorizonUnit = document.getElementById('calculation-horizon-unit').value;
        saveData();
      } else if (target.id === 'gpa-system-select') {
        appSettings.gpaSystem = target.value;
        saveData();
      }
    });

    const sortBySelectEl = document.getElementById('sort-by');
    if(sortBySelectEl) sortBySelectEl.addEventListener('change', (e) => { sortBy = e.target.value; saveData(); renderTasks(); });

    const sortDirectionSelectEl = document.getElementById('sort-direction');
    if(sortDirectionSelectEl) sortDirectionSelectEl.addEventListener('change', (e) => { sortDirection = e.target.value; saveData(); renderTasks(); });
  }

  // --- Planner & KPI Listeners ---
  const prevWeekBtnEl = document.getElementById('prevWeekBtn');
  if (prevWeekBtnEl) prevWeekBtnEl.addEventListener('click', () => { if (calendar) calendar.prev(); });

  const nextWeekBtnEl = document.getElementById('nextWeekBtn');
  if (nextWeekBtnEl) nextWeekBtnEl.addEventListener('click', () => { if (calendar) calendar.next(); });

  const todayBtnEl = document.getElementById('todayBtn');
  if (todayBtnEl) todayBtnEl.addEventListener('click', () => { if (calendar) calendar.today(); });

  const calendarHeader = document.querySelector('.calendar-header');
  if (calendarHeader) {
    const viewBtns = calendarHeader.querySelectorAll('[data-view]');
    viewBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        if (calendar) {
          const viewName = btn.dataset.view === 'month' ? 'dayGridMonth' : btn.dataset.view === 'daily' ? 'timeGridDay' : 'timeGridWeek';
          calendar.changeView(viewName);
        }
      });
    });
  }


  const dashboardPrevWeekBtn = document.getElementById('dashboard-prev-week-btn');
  if (dashboardPrevWeekBtn) dashboardPrevWeekBtn.addEventListener('click', () => { uiSettings.dashboardWeekOffset--; saveData(); renderDashboardContent(); });

  const dashboardNextWeekBtn = document.getElementById('dashboard-next-week-btn');
  if (dashboardNextWeekBtn) dashboardNextWeekBtn.addEventListener('click', () => { uiSettings.dashboardWeekOffset++; saveData(); renderDashboardContent(); });

  const dashboardTodayBtn = document.getElementById('dashboard-today-btn');
  if (dashboardTodayBtn) dashboardTodayBtn.addEventListener('click', () => { uiSettings.dashboardWeekOffset = 0; saveData(); renderDashboardContent(); });

  const addNewKpiBtnEl = document.getElementById('add-new-kpi-btn');
  if (addNewKpiBtnEl) addNewKpiBtnEl.addEventListener('click', () => openModal(null, { isKpi: true }));

  const setKpiBtnEl = document.getElementById('set-kpi-btn');
  if (setKpiBtnEl) {
    setKpiBtnEl.addEventListener('click', () => {
      const kpiTaskSelectEl = document.getElementById('kpi-task-select');
      if (!kpiTaskSelectEl || !kpiTaskSelectEl.value) return;
      const task = tasks.find(t => t.id === kpiTaskSelectEl.value);
      if (task) {
        task.isKpi = true;
        if (uiSettings.userInteractions) uiSettings.userInteractions.setKpi = true;
        saveData();
        renderKpiList();
        renderKpiTaskSelect();
      }
    });
  }

  const weeklyGoalsEl = document.getElementById('weeklyGoals');
  if (weeklyGoalsEl) {
    weeklyGoalsEl.addEventListener('blur', () => {
      const newContent = weeklyGoalsEl.innerText.trim();

      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate() + (uiSettings.dashboardWeekOffset * 7));
      const weekStart = startOfWeek(today, { weekStartsOn: 0 });
      const weekStartDateStr = weekStart.toISOString().split('T')[0];

      const existingGoalIndex = appState.journal.findIndex(entry => entry.isWeeklyGoal && entry.weekStartDate === weekStartDateStr);

      if (existingGoalIndex > -1) {
        // Update existing entry, even if it's empty. This is safer than deleting.
        if (appState.journal[existingGoalIndex].content !== newContent) {
          appState.journal[existingGoalIndex].content = newContent;
          appState.journal[existingGoalIndex].editedAt = new Date().toISOString();
          savePlannerData();
          if (uiSettings.activeView === 'journal-view') renderJournal();
        }
      } else if (newContent !== '' && newContent !== '<br>') {
        // Only create a new entry if there's actual content.
        const newGoalEntry = {
          id: generateId(),
          createdAt: new Date().toISOString(),
          editedAt: null,
          title: 'Weekly Goal',
          content: newContent,
          icon: journalSettings.weeklyGoalIcon,
          isWeeklyGoal: true,
          weekStartDate: weekStartDateStr,
        };
        appState.journal.push(newGoalEntry);
        savePlannerData();
        if (uiSettings.activeView === 'journal-view') renderJournal();
      }
    });
  }

  const addNewTaskBtnPlanner = document.getElementById('addNewTaskBtnPlanner');
  if (addNewTaskBtnPlanner) {
    addNewTaskBtnPlanner.addEventListener('click', () => openModal());
  }

  // --- Main View & Page Listeners ---
  const dashboardViewEl = document.getElementById('dashboard-view');
  if (dashboardViewEl) {
    dashboardViewEl.addEventListener('click', (event) => {
      const target = event.target.closest('[data-action="toggleDashboardGoalContent"]');
      if (target) {
        const goalContainer = target.parentElement; // The weeklyGoalsEl
        const proseDiv = goalContainer.querySelector('.prose');
        if (proseDiv) {
          const fullContent = decodeURIComponent(goalContainer.dataset.fullGoal);
          const isTruncated = proseDiv.innerHTML.endsWith('...');

          if (isTruncated) {
            proseDiv.innerHTML = fullContent.replace(/\n/g, '<br>');
            target.textContent = 'Show Less';
          } else {
            proseDiv.innerHTML = fullContent.substring(0, 500).replace(/\n/g, '<br>') + '...';
            target.textContent = 'Show More';
          }
        }
      }
    });
  }

  const mainViewNav = document.getElementById('main-view-nav');
  if (mainViewNav) {
    mainViewNav.addEventListener('click', (event) => {
      const target = event.target.closest('.view-toggle-btn');
      if (!target) return;

      const viewId = target.id.replace('show-', '').replace('-btn', '-view');

      const allViews = ['task-manager-view', 'calendar-view', 'dashboard-view', 'journal-view'];
      const allButtons = ['show-task-manager-btn', 'show-calendar-btn', 'show-dashboard-btn', 'show-journal-btn'];

      allViews.forEach(id => {
        const viewEl = document.getElementById(id);
        if (viewEl) viewEl.classList.add('hidden');
      });
      allButtons.forEach(id => {
        const btnEl = document.getElementById(id);
        if (btnEl) btnEl.classList.remove('active-view-btn');
      });

      const activeView = document.getElementById(viewId);
      if (activeView) {
        activeView.classList.remove('hidden');
        target.classList.add('active-view-btn');
        uiSettings.activeView = viewId;

        if (viewId === 'calendar-view' && calendar) {
          calendar.updateSize();
          renderCalendarCategoryFilters();
        }
        if (viewId === 'dashboard-view') renderDashboardContent();
        if (viewId === 'journal-view') renderJournal();
      }

      applyTheme();
      saveData();
    });
  }

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      startNotificationEngine();
    } else {
      stopNotificationEngine();
    }
  });

  // --- Journal Listeners (Event Delegation) ---
  if (journalModal) {
    journalModal.addEventListener('click', (event) => {
      const target = event.target.closest('[data-action]');
      if (!target) return;
      if (target.dataset.action === 'openIconPicker') {
        const context = target.dataset.context || 'journal';
        openIconPicker(context);
      }
    });
  }
  const journalViewEl = document.getElementById('journal-view');
  if (journalViewEl) {
    // Use a single delegated listener for all actions within the journal view
    journalViewEl.addEventListener('click', (event) => {
      const target = event.target.closest('[data-action]');
      if (!target) return;

      const action = target.dataset.action;
      const entryId = target.dataset.id || target.dataset.entryId;

      switch(action) {
      case 'addJournal':
        openJournalModal();
        break;
      case 'editJournal':
        openJournalModal(entryId);
        break;
      case 'deleteJournal':
        if (confirm('Are you sure you want to delete this journal entry?')) {
          appState.journal = appState.journal.filter(e => e.id !== entryId);
          savePlannerData();
          renderJournal();
        }
        break;
      case 'toggleJournalContent':
        const contentId = target.dataset.contentId;
        const contentDiv = document.getElementById(contentId);
        const entryDiv = target.closest('.journal-entry');
        if (contentDiv && entryDiv) {
          const fullContent = decodeURIComponent(entryDiv.dataset.fullContent);
          const isTruncated = contentDiv.textContent.endsWith('...');

          if (isTruncated) {
            contentDiv.textContent = fullContent;
            target.textContent = 'Show Less';
          } else {
            contentDiv.textContent = fullContent.substring(0, 500) + '...';
            target.textContent = 'Show More';
          }
        }
        break;
      case 'toggleJournalWeekGroup':
        const weekGroup = target.dataset.weekGroup;
        const weekEntriesContainer = journalViewEl.querySelector(`.journal-entries-container[data-week-entries="${weekGroup}"]`);
        const weekChevron = target.querySelector('i.fa-solid');
        if (weekEntriesContainer && weekChevron) {
          const isHidden = weekEntriesContainer.classList.toggle('hidden');
          weekChevron.classList.toggle('fa-chevron-right', isHidden);
          weekChevron.classList.toggle('fa-chevron-down', !isHidden);
          if (!uiSettings.journalWeekCollapseState) {
            uiSettings.journalWeekCollapseState = {};
          }
          uiSettings.journalWeekCollapseState[weekGroup] = isHidden;
          saveData();
        }
        break;
      case 'toggleJournalIconGroup':
        const iconGroupEl = target.closest('.collapsible-section');
        if (iconGroupEl) {
          const iconGroupKey = target.dataset.iconGroup;
          const isOpen = iconGroupEl.classList.toggle('open');
          uiSettings.journalIconCollapseState[iconGroupKey] = !isOpen;
          saveData();
        }
        break;
      }
    });

    // Add a separate listener for 'change' events, also delegated from the main view
    journalViewEl.addEventListener('change', (event) => {
      if (event.target.id === 'journal-sort-by' || event.target.id === 'journal-sort-direction') {
        if (uiSettings.userInteractions) uiSettings.userInteractions.sortedJournal = true;
        renderJournal();
      }
    });

    journalViewEl.addEventListener('input', (event) => {
      if (event.target.id === 'journal-search-input') {
        renderJournal();
      }
    });
  }

  // --- Calendar View Listeners ---
  const calendarViewEl = document.getElementById('calendar-view');
  if (calendarViewEl) {
    calendarViewEl.addEventListener('change', (e) => {
      const target = e.target;
      if (target.id === 'calendar-filter-view-select') {
        calendarSettings.filterTargetView = target.value;
        saveData();
        if (calendar) {
          calendar.refetchEvents();
        }
      }
    });

    calendarViewEl.addEventListener('click', (e) => {
      const target = e.target.closest('[data-action="toggleCalendarFilter"]');
      if (!target) return;

      const categoryId = target.dataset.categoryId;
      const filterType = target.dataset.filterType;
      const isEnabled = target.checked;

      if (!uiSettings.calendarCategoryFilters[categoryId]) {
        uiSettings.calendarCategoryFilters[categoryId] = { show: true, schedule: true };
      }

      uiSettings.calendarCategoryFilters[categoryId][filterType] = isEnabled;

      saveData();
      updateAllTaskStatuses(true);
      if (calendar) {
        calendar.refetchEvents();
      }
    });
  }
}

function saveData() {
  if (isInitializing) {
    console.log('Initialization in progress, skipping save data.');
    return;
  }
  try {
    localStorage.setItem('tasks', JSON.stringify(tasks));
    localStorage.setItem('categories', JSON.stringify(categories));
    localStorage.setItem('statusColors', JSON.stringify(statusColors));
    localStorage.setItem('statusNames', JSON.stringify(statusNames));
    localStorage.setItem('sortBy', sortBy);
    localStorage.setItem('sortDirection', sortDirection);
    localStorage.setItem('notificationSettings', JSON.stringify(notificationSettings));
    localStorage.setItem('notificationTimestamps', JSON.stringify(notificationEngine.lastNotificationTimestamps));
    localStorage.setItem('theming', JSON.stringify(theming));
    localStorage.setItem('calendarSettings', JSON.stringify(calendarSettings));
    localStorage.setItem('categoryFilter', JSON.stringify(categoryFilter));
    localStorage.setItem('plannerSettings', JSON.stringify(plannerSettings));
    localStorage.setItem('taskDisplaySettings', JSON.stringify(taskDisplaySettings));
    localStorage.setItem('appSettings', JSON.stringify(appSettings));
    localStorage.setItem('sensitivitySettings', JSON.stringify(sensitivitySettings));
    localStorage.setItem('uiSettings', JSON.stringify(uiSettings));
    localStorage.setItem('journalSettings', JSON.stringify(journalSettings));
    localStorage.setItem('bufferSettings', JSON.stringify(bufferSettings));
    // New: Explicitly save historical tasks to their own key
    localStorage.setItem('historicalTasksV1', JSON.stringify(appState.historicalTasks));
    savePlannerData();
  } catch (error) {
    console.error('Error saving data to localStorage:', error);
  }
}

function loadData() {
  // New: Load historical tasks from their own dedicated key first.
  const storedHistory = localStorage.getItem('historicalTasksV1');
  if (storedHistory) {
    try {
      const parsedHistory = JSON.parse(storedHistory);
      appState.historicalTasks = Array.isArray(parsedHistory) ? parsedHistory : [];
    } catch(e) {
      console.error('Error parsing historical tasks from new storage:', e);
      appState.historicalTasks = [];
    }
  }

  const storedTasks = localStorage.getItem('tasks');
  const storedCategories = localStorage.getItem('categories');
  const storedColors = localStorage.getItem('statusColors');
  const storedNames = localStorage.getItem('statusNames');
  const storedSortBy = localStorage.getItem('sortBy');
  const storedSortDirection = localStorage.getItem('sortDirection');
  const storedNotifications = localStorage.getItem('notificationSettings');
  const storedNotificationTimestamps = localStorage.getItem('notificationTimestamps');
  const storedTheming = localStorage.getItem('theming');
  const storedCalendarSettings = localStorage.getItem('calendarSettings');
  const storedCategoryFilter = localStorage.getItem('categoryFilter');
  const storedPlannerSettings = localStorage.getItem('plannerSettings');
  const storedTaskDisplaySettings = localStorage.getItem('taskDisplaySettings');
  const storedAppSettings = localStorage.getItem('appSettings');
  const storedSensitivitySettings = localStorage.getItem('sensitivitySettings');
  const storedUiSettings = localStorage.getItem('uiSettings');
  const storedJournalSettings = localStorage.getItem('journalSettings');
  const storedBufferSettings = localStorage.getItem('bufferSettings');

  if (storedColors) {
    try {
      const parsedColors = JSON.parse(storedColors);
      statusColors = { ...statusColors, ...parsedColors };
    } catch (e) {
      console.error('Error parsing status colors:', e);
    }
  }
  if (storedNames) {
    try {
      const parsedNames = JSON.parse(storedNames);
      statusNames = { ...statusNames, ...parsedNames };
    } catch (e) {
      console.error('Error parsing status names:', e);
    }
  }

  if (storedSortBy) sortBy = storedSortBy;
  if (storedSortDirection) sortDirection = storedSortDirection;
  sortBySelect.value = sortBy;
  sortDirectionSelect.value = sortDirection;

  if (storedNotifications) {
    try {
      const parsedSettings = JSON.parse(storedNotifications);
      // Deep merge to handle nested objects
      notificationSettings.rateLimit = { ...notificationSettings.rateLimit, ...parsedSettings.rateLimit };
      notificationSettings.categories = { ...notificationSettings.categories, ...parsedSettings.categories };
      notificationSettings.enabled = typeof parsedSettings.enabled === 'boolean' ? parsedSettings.enabled : false;
    } catch(e) {
      console.error('Error parsing notification settings:', e);
    }
  }

  if (storedNotificationTimestamps) {
    try {
      notificationEngine.lastNotificationTimestamps = JSON.parse(storedNotificationTimestamps);
    } catch(e) {
      console.error('Error parsing notification timestamps:', e);
    }
  }

  if (storedTheming) {
    try {
      const parsedTheming = JSON.parse(storedTheming);
      theming = { ...theming, ...parsedTheming };
      if (theming.mode !== 'light' && theming.mode !== 'night' && theming.mode !== 'auto') {
        theming.mode = 'night'; // Default to night if stored value is invalid
      }
    } catch (e) {
      console.error('Error parsing theming settings:', e);
    }
  }

  if (storedCalendarSettings) {
    try {
      const parsedSettings = JSON.parse(storedCalendarSettings);
      calendarSettings = { ...calendarSettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing calendar settings:', e);
    }
  }

  if (storedCategoryFilter) {
    try {
      categoryFilter = JSON.parse(storedCategoryFilter);
    } catch (e) {
      console.error('Error parsing category filter:', e);
    }
  }

  if (storedPlannerSettings) {
    try {
      const parsedSettings = JSON.parse(storedPlannerSettings);
      plannerSettings = { ...plannerSettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing planner settings:', e);
    }
  }

  if (storedTaskDisplaySettings) {
    try {
      const parsedSettings = JSON.parse(storedTaskDisplaySettings);
      taskDisplaySettings = { ...taskDisplaySettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing task display settings:', e);
    }
  }

  if (storedAppSettings) {
    try {
      const parsedSettings = JSON.parse(storedAppSettings);
      appSettings = { ...appSettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing app settings:', e);
    }
  }

  if (storedSensitivitySettings) {
    try {
      const parsedSettings = JSON.parse(storedSensitivitySettings);
      sensitivitySettings = { ...sensitivitySettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing sensitivity settings:', e);
    }
  }

  if (storedUiSettings) {
    try {
      const parsedSettings = JSON.parse(storedUiSettings);
      uiSettings = { ...uiSettings, ...parsedSettings };
      // Ensure the userInteractions object exists after loading
      if (!uiSettings.userInteractions) {
        uiSettings.userInteractions = {};
      }
    } catch (e) {
      console.error('Error parsing UI settings:', e);
    }
  }

  if (storedJournalSettings) {
    try {
      const parsedSettings = JSON.parse(storedJournalSettings);
      journalSettings = { ...journalSettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing Journal settings:', e);
    }
  }

  if (storedBufferSettings) {
    try {
      const parsedSettings = JSON.parse(storedBufferSettings);
      bufferSettings = { ...bufferSettings, ...parsedSettings };
    } catch (e) {
      console.error('Error parsing Buffer settings:', e);
    }
  }


  // Only load from localStorage if the arrays are empty.
  // This allows verification scripts to inject data without it being overwritten.
  if (storedCategories) {
    try {
      categories = JSON.parse(storedCategories);
    } catch (error) {
      console.error('Error parsing categories from localStorage:', error);
      categories = []; // Reset on error
    }
  }
  if (storedTasks) {
    try {
      tasks = [];
      const parsedTasks = JSON.parse(storedTasks);
      tasks = parsedTasks.map(task => {
        let tempTask = { ...task };
        tempTask.dueDate = task.dueDate ? new Date(task.dueDate) : null;
        tempTask.createdAt = task.createdAt ? new Date(task.createdAt) : new Date();
        tempTask.cycleEndDate = task.cycleEndDate ? new Date(task.cycleEndDate) : null;
        tempTask.timerLastStarted = task.timerLastStarted ? new Date(task.timerLastStarted) : null;
        if (isNaN(tempTask.dueDate)) tempTask.dueDate = null;
        if (isNaN(tempTask.createdAt)) tempTask.createdAt = new Date();
        if (isNaN(tempTask.cycleEndDate)) tempTask.cycleEndDate = null;
        if (isNaN(tempTask.timerLastStarted)) tempTask.timerLastStarted = null;
        return sanitizeAndUpgradeTask(tempTask);
      });

      tasks.forEach(task => {
        if (task.isTimerRunning && task.timerLastStarted) {
          const elapsedWhileAway = Date.now() - new Date(task.timerLastStarted).getTime();
          const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
          task.currentProgress = (task.currentProgress || 0) + elapsedWhileAway;
          if (task.currentProgress >= targetMs) {
            task.currentProgress = targetMs;
            task.isTimerRunning = false;
            task.timerLastStarted = null;
          } else {
            task.timerLastStarted = new Date().toISOString();
          }
        }
      });
    } catch (error) {
      console.error('Error parsing tasks from localStorage:', error);
      tasks = []; // Reset on error
    }
  }

  renderKpiTaskSelect();
  renderKpiList();
  startMainUpdateLoop();
}

function updateAllTaskStatuses(forceRender = false) {
  const now = new Date();
  const nowMs = now.getTime();

  const calculationHorizon = getCalculationHorizonDate();
  const settings = {
    sensitivity: sensitivitySettings,
    vacations: appState.vacations,
    categories: categories,
    calendarCategoryFilters: uiSettings.calendarCategoryFilters,
    earlyOnTimeSettings: uiSettings.earlyOnTimeSettings,
  };

  // --- Task Status Updates ---
  const allOccurrences = runCalculationPipeline([...tasks], calculationHorizon, settings);
  let changed = false;
  const nextOccurrenceMap = new Map();
  allOccurrences
    .filter(o => o.scheduledEndTime && new Date(o.scheduledEndTime).getTime() > nowMs)
    .sort((a, b) => new Date(a.scheduledStartTime).getTime() - new Date(b.scheduledStartTime).getTime())
    .forEach(o => {
      if (!nextOccurrenceMap.has(o.originalId)) {
        nextOccurrenceMap.set(o.originalId, o);
      }
    });

  tasks.forEach(task => {
    const oldStatus = task.status;
    const oldConfirmationState = task.confirmationState;
    const dueDate = task.dueDate ? new Date(task.dueDate) : null;
    const isPastDue = dueDate && dueDate.getTime() <= nowMs;
    if (isPastDue && task.status !== 'blue' && !task.confirmationState) {
      task.confirmationState = 'awaiting_overdue_input';
      if (!task.overdueStartDate && task.dueDate instanceof Date && !isNaN(task.dueDate)) {
          task.overdueStartDate = task.dueDate.toISOString();
      }
      task.pendingCycles = calculatePendingCycles(task, nowMs);
      if (task.isTimerRunning) toggleTimer(task.id);
    } else if (!isPastDue && (task.confirmationState === 'awaiting_overdue_input' || task.confirmationState === 'confirming_miss')) {
      task.confirmationState = null;
      delete task.overdueStartDate;
      delete task.pendingCycles;
    }

    const nextOccurrence = nextOccurrenceMap.get(task.id);
    let newStatus, newGpa = 0;
    if (task.status === 'blue' && task.cycleEndDate && new Date(task.cycleEndDate) > now) {
      newStatus = 'blue'; newGpa = 1.0;
    } else if (task.confirmationState === 'awaiting_overdue_input') {
      newStatus = 'black'; newGpa = 0.0;
    } else if (nextOccurrence) {
      newStatus = nextOccurrence.finalStatus;
      newGpa = nextOccurrence.coloringGpa;
    } else {
      newStatus = 'green'; newGpa = 0.75;
    }

    const isPendingConfirmation = ['confirming_complete', 'confirming_miss', 'confirming_delete', 'confirming_undo'].includes(task.confirmationState);
    if (!isPendingConfirmation) {
      if (task.status !== newStatus) task.status = newStatus;
      task.coloringGpa = newGpa;
    }
    if (task.status !== oldStatus || task.confirmationState !== oldConfirmationState) changed = true;
  });

  const tasksToRemove = tasks.filter(task => task.repetitionType === 'none' && task.completed && task.cycleEndDate && nowMs >= new Date(task.cycleEndDate).getTime()).map(t => t.id);
  if (tasksToRemove.length > 0) {
    tasks = tasks.filter(t => !tasksToRemove.includes(t.id));
    changed = true;
  }

  if (changed || forceRender) {
    saveData();
    renderTasks();
  }

  // --- Calendar Event Calculation ---
  // This is now the single source of truth for calendar event data.
  calendarMonthEvents = [];
  calendarTimeGridEvents = [];

  const processEvent = (eventData) => {
    const { start, end, baseProps, isHistorical, originalId, completionDate } = eventData;

    // Final validation before adding to arrays
    if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime()) || end <= start) {
      console.warn('Skipping invalid event during processing:', { baseProps, start, end });
      return;
    }

    // TimeGrid View (Week/Day): Add as a single block
    const timeGridId = isHistorical ? `hist_${originalId}_${completionDate}` : (baseProps.id || originalId);
    calendarTimeGridEvents.push({ ...baseProps, id: timeGridId, start, end });

    // Month View: Split into daily segments
    let currentSegmentStart = new Date(start);
    while (currentSegmentStart < end) {
      const startOfNextDay = new Date(currentSegmentStart);
      startOfNextDay.setHours(24, 0, 0, 0);
      const segmentEnd = (end < startOfNextDay) ? new Date(end) : startOfNextDay;

      // Create a unique ID for the segment to avoid key collisions in React-based renderers
      const segmentId = `${timeGridId}_${currentSegmentStart.toISOString()}`;

      if (segmentEnd > currentSegmentStart) {
        calendarMonthEvents.push({ ...baseProps, id: segmentId, start: currentSegmentStart, end: segmentEnd });
      }
      currentSegmentStart = startOfNextDay;
    }
  };

  // Process active tasks from the pipeline
  allOccurrences.forEach(occurrence => {
    if (!occurrence.scheduledStartTime || !occurrence.scheduledEndTime) return;

    const start = new Date(occurrence.displayStartTime || occurrence.scheduledStartTime);
    const end = new Date(occurrence.displayEndTime || occurrence.scheduledEndTime);

    const task = tasks.find(t => t.id === occurrence.originalId);
    if (!task) return; // Don't render occurrences for tasks that no longer exist

    const category = categories.find(c => c.id === occurrence.categoryId);
    const categoryColor = category ? category.color : '#374151'; // Default gray for uncategorized
    const borderColor = statusColors[occurrence.finalStatus] || statusColors.black;

    // Handle Buffer Types (Prep/Early)
    let title = occurrence.name;
    let icon = task.icon;
    let backgroundColor = categoryColor;
    let textColor = getContrastingTextColor(categoryColor)['--text-color-primary'];
    let extendedProps = {
        taskId: occurrence.originalId,
        occurrenceDueDate: (occurrence.occurrenceDueDate && !isNaN(new Date(occurrence.occurrenceDueDate))) ? new Date(occurrence.occurrenceDueDate).toISOString() : new Date().toISOString(),
        isHistorical: false,
        category: category,
        positioningGpa: occurrence.positioningGpa
    };

    if (occurrence.type === 'buffer') {
        // Buffers use custom icons and labels
        const settings = occurrence.subtype === 'prep' ? bufferSettings.prep : bufferSettings.early;
        title = `${settings.label}: ${task.name}`;
        icon = settings.icon; // Override icon

        // Visual distinction for buffers: slightly transparent background
        // We use the category color but apply transparency if it's a hex code
        if (categoryColor.startsWith('#')) {
            const r = parseInt(categoryColor.slice(1, 3), 16);
            const g = parseInt(categoryColor.slice(3, 5), 16);
            const b = parseInt(categoryColor.slice(5, 7), 16);
            backgroundColor = `rgba(${r}, ${g}, ${b}, 0.7)`;
        } else {
            // Fallback for named colors or existing rgbs
            backgroundColor = categoryColor;
        }

        // Buffers link to the parent task
        extendedProps.isBuffer = true;
    }

    extendedProps.icon = icon;

    const baseProps = {
      title: title,
      backgroundColor: backgroundColor,
      borderColor: borderColor,
      textColor: textColor,
      extendedProps: extendedProps,
      id: occurrence.id // Pass the unique occurrence ID
    };
    processEvent({ start, end, baseProps, isHistorical: false, originalId: occurrence.id });
  });

  // Process recent historical tasks.
  // The view limit is tied to the history deletion setting for consistency.
  // If deletion is off, we default to a year to balance utility and performance.
  const historyViewDays = (uiSettings.historyDeletionEnabled && uiSettings.historyDeletionPeriod)
    ? uiSettings.historyDeletionPeriod
    : 365;
  const historyCutoffDate = new Date(nowMs - historyViewDays * MS_PER_DAY);

  if (appState.historicalTasks && Array.isArray(appState.historicalTasks)) {
    appState.historicalTasks
      .filter(ht => ht && ht.completionDate && new Date(ht.completionDate) >= historyCutoffDate)
      .forEach(ht => {
        const durationMs = getDurationMs(ht.durationAmount, ht.durationUnit) || MS_PER_HOUR;
        const endDate = new Date(ht.completionDate);
        const startDate = new Date(endDate.getTime() - durationMs);

        const category = categories.find(c => c.id === ht.categoryId);
        const baseColor = category ? category.color : '#808080';

        // Make historical events appear "faded"
        const hsl = hexToHSL(baseColor);
        hsl.s = Math.max(0, hsl.s - 20); // Desaturate
        hsl.l = document.body.classList.contains('light-mode') ? Math.min(100, hsl.l + 15) : Math.max(0, hsl.l - 15); // Lighten/darken
        const eventColor = HSLToHex(hsl.h, hsl.s, hsl.l);

        const originalTask = tasks.find(t => t.id === ht.originalTaskId) || (appState.archivedTasks && appState.archivedTasks.find(t => t.id === ht.originalTaskId));

        const baseProps = {
          title: ht.name,
          backgroundColor: eventColor,
          borderColor: statusColors[ht.status] || statusColors.black,
          textColor: getContrastingTextColor(eventColor)['--text-color-primary'],
          extendedProps: {
            taskId: ht.originalTaskId,
            isHistorical: true,
            category: category,
            icon: originalTask ? originalTask.icon : null
          }
        };
        processEvent({ start: startDate, end: endDate, baseProps, isHistorical: true, originalId: ht.originalTaskId, completionDate: ht.completionDate });
      });
  }

  // If the calendar exists, tell it to refetch events.
  if (calendar) {
    calendar.refetchEvents();
  }

  // --- Task View Modal Border Update ---
  const taskViewModalEl = document.getElementById('task-view-modal');
  if (taskViewModalEl && taskViewModalEl.classList.contains('active')) {
    const viewingTaskId = taskViewModalEl.dataset.viewingTaskId;
    if (viewingTaskId) {
      const task = tasks.find(t => t.id === viewingTaskId);
      const borderWrapper = document.getElementById('task-view-modal-border-wrapper');
      if (task && borderWrapper) {
        const gpaMap = { blue: 4.0, green: 3.0, yellow: 2.0, red: 1.0, black: 0.0 };
        let gpaPercent;
        if (typeof task.coloringGpa === 'number') {
          gpaPercent = task.coloringGpa;
        } else {
          const gpa = gpaMap[task.status] || 0; // Fallback to 0 if status is invalid
          gpaPercent = gpa / 4.0;
        }
        const baseColor = interpolateFiveColors(gpaPercent);
        const isDarkMode = !document.body.classList.contains('light-mode');
        const topColor = adjustColor(baseColor, isDarkMode ? 0.2 : -0.2);
        const bottomColor = adjustColor(baseColor, isDarkMode ? -0.2 : 0.2);
        const gradient = `linear-gradient(to bottom, ${topColor}, ${bottomColor})`;
        borderWrapper.style.background = gradient;
      }
    }
  }
}
function startMainUpdateLoop() {
  if (mainUpdateInterval) {
    clearTimeout(mainUpdateInterval);
    mainUpdateInterval = null;
  }

  const scheduledUpdate = () => {
    // These are the actions that were in the setInterval
    updateAdaptiveSensitivity();
    updateAllTaskStatuses(false);

    // Schedule the next execution, ensuring it stays aligned
    const now = new Date();
    const delay = 15000 - (now.getSeconds() % 15 * 1000 + now.getMilliseconds());
    mainUpdateInterval = setTimeout(scheduledUpdate, delay);
  };

  // Kick off the first aligned execution.
  // The `loadData` function already performs an immediate update on page load.
  // This timeout sets up the first of the recurring, clock-aligned updates.
  const now = new Date();
  const initialDelay = 15000 - (now.getSeconds() % 15 * 1000 + now.getMilliseconds());
  mainUpdateInterval = setTimeout(scheduledUpdate, initialDelay);
}

// =================================================================================
// --- MISSION PLANNER SCRIPT ---
// =================================================================================
const getStartOfWeek = (date = new Date()) => { const d = new Date(date); d.setDate(d.getDate() - d.getDay()); d.setHours(0,0,0,0); return d; };
const getISOStringAtMidnight = (date) => { const d = new Date(date); d.setHours(0, 0, 0, 0); return d.toISOString(); };
const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

const createNewWeek = (startDate) => ({
  startDate: getISOStringAtMidnight(startDate),
  weeklyGoals: 'Set new goals for the week...',
  schedule: {},
  kpiData: {},
  amendedItems: { weeklyGoals: false, schedule: {}, kpi: {} },
  originalState: null
});

const savePlannerData = () => {
  // Cleanup historical tasks older than 4 weeks
  const fourWeeksAgo = new Date();
  fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
  if (appState.historicalTasks && appState.historicalTasks.length > 0) {
    appState.historicalTasks = appState.historicalTasks.filter(ht => new Date(ht.completionDate) >= fourWeeksAgo);
  }

  localStorage.setItem(DATA_KEY, JSON.stringify({
    weeks: appState.weeks,
    indicators: appState.indicators,
    journal: appState.journal,
    archivedTasks: appState.archivedTasks // Persist archived tasks
    // historicalTasks is now saved separately
  }));
};
const saveViewState = () => localStorage.setItem(VIEW_STATE_KEY, JSON.stringify({ viewingIndex: appState.viewingIndex, currentView: appState.currentView, currentDayIndex: appState.currentDayIndex }));

const loadPlannerData = () => {
  const savedData = localStorage.getItem(DATA_KEY);
  if (!savedData) return;
  try {
    const parsedData = JSON.parse(savedData);
    appState.weeks = parsedData.weeks || [];
    appState.weeks.forEach(week => {
      if (!week.amendedItems) week.amendedItems = { weeklyGoals: false, schedule: {}, kpi: {} };
      if (week.originalState === undefined) week.originalState = null;
    });
    appState.indicators = parsedData.indicators || appState.indicators;
    appState.journal = parsedData.journal || [];

    // One-time check for weekly goal timezone issue
    if (!parsedData.goalTimezoneFixV2Applied) {
      const affectedGoals = (parsedData.journal || []).filter(entry => {
        if (!entry.isWeeklyGoal || !entry.weekStartDate) return false;
        const entryDate = new Date(entry.weekStartDate + 'T00:00:00');
        return entryDate.getDay() !== 0;
      });

      if (affectedGoals.length > 0) {
        // Use a setTimeout to ensure the rest of the app initializes
        setTimeout(() => {
          openDataMigrationModal({ show: 'goal-fix' });
        }, 500);
      }
    }

    // --- One-time Data Migration for Journal Entries ---
    const journalMigrationNeeded = !localStorage.getItem('journalMigrationV1');
    if (journalMigrationNeeded && Array.isArray(appState.journal)) {
      console.log('Running one-time journal data migration...');
      appState.journal.forEach(entry => {
        if (entry.isWeeklyGoal === undefined) {
          entry.isWeeklyGoal = false;
        }
      });
      localStorage.setItem('journalMigrationV1', 'true');
      console.log('Journal data migration complete.');
      // Re-save the data immediately after migration to persist the changes
      savePlannerData();
    }

    // --- One-time Data Migration for old Weekly Goals ---
    const weeklyGoalMigrationNeeded = !localStorage.getItem('weeklyGoalMigrationV1');
    if (weeklyGoalMigrationNeeded && Array.isArray(appState.weeks) && appState.weeks.length > 0) {
      console.log('Running one-time weekly goal migration...');
      let goalsMigrated = 0;
      appState.weeks.forEach(week => {
        if (week.weeklyGoals && week.weeklyGoals.trim() !== '' && week.weeklyGoals.trim() !== 'Set new goals for the week...') {
          const weekStartDate = new Date(week.startDate).toISOString().split('T')[0];
          // Avoid creating duplicate entries if one already exists for that week
          const existingEntry = appState.journal.find(j => j.isWeeklyGoal && j.weekStartDate === weekStartDate);

          if (!existingEntry) {
            const newGoalEntry = {
              id: generateId(),
              createdAt: new Date(week.startDate).toISOString(),
              editedAt: null,
              title: 'Weekly Goal',
              content: week.weeklyGoals,
              icon: journalSettings.weeklyGoalIcon || 'fa-solid fa-bullseye',
              isWeeklyGoal: true,
              weekStartDate: weekStartDate,
            };
            appState.journal.push(newGoalEntry);
            goalsMigrated++;
          }
        }
      });
      localStorage.setItem('weeklyGoalMigrationV1', 'true');
      console.log(`Weekly goal migration complete. Migrated ${goalsMigrated} goals.`);
      if (goalsMigrated > 0) {
        // Save the newly migrated goals
        savePlannerData();
      }
    }

    // Load archived tasks, ensuring dates are correctly parsed
    if (parsedData.archivedTasks && Array.isArray(parsedData.archivedTasks)) {
      appState.archivedTasks = parsedData.archivedTasks.map(task => {
        let tempTask = { ...task };
        tempTask.dueDate = task.dueDate ? new Date(task.dueDate) : null;
        tempTask.createdAt = task.createdAt ? new Date(task.createdAt) : new Date();
        tempTask.cycleEndDate = task.cycleEndDate ? new Date(task.cycleEndDate) : null;
        return tempTask;
      });
    } else {
      appState.archivedTasks = [];
    }


    // One-time migration for historical tasks from old storage format.
    if (parsedData.historicalTasks && Array.isArray(parsedData.historicalTasks) && parsedData.historicalTasks.length > 0) {
      // Only migrate if the new storage is empty, to avoid overwriting good data.
      const newHistoryStorage = localStorage.getItem('historicalTasksV1');
      if (!newHistoryStorage || newHistoryStorage === '[]') {
        console.log('Migrating historical tasks from old storage location...');
        // The history loaded in loadData() would be empty, so we can just assign it.
        appState.historicalTasks = parsedData.historicalTasks.filter(item =>
          item && typeof item === 'object' && item.originalTaskId && item.completionDate && item.status
        );
        // Save immediately to the new location
        localStorage.setItem('historicalTasksV1', JSON.stringify(appState.historicalTasks));
      }
      // After migration (or if new storage already exists), remove history from the old object and re-save it.
      delete parsedData.historicalTasks;
      localStorage.setItem(DATA_KEY, JSON.stringify(parsedData));
      console.log('Old history key removed from planner data.');
    }

  } catch (error) {
    console.error('Failed to parse saved planner data.', error);
  }
};

const loadViewState = () => {
  const savedState = localStorage.getItem(VIEW_STATE_KEY);
  if (!savedState) return;
  try {
    const parsedState = JSON.parse(savedState);
    appState.viewingIndex = parsedState.viewingIndex ?? CURRENT_WEEK_INDEX;
    appState.currentView = parsedState.currentView ?? 'weekly';
    appState.currentDayIndex = parsedState.currentDayIndex ?? 0;
  } catch (error) { console.error('Failed to parse view state:', error); }
};

const getFutureWeekStartDate = (viewingIndex) => {
  const lastKnownWeek = appState.weeks[appState.weeks.length - 1];
  const lastKnownStartDate = new Date(lastKnownWeek.startDate);
  const weeksAhead = viewingIndex - (appState.weeks.length - 1);
  const futureStartDate = new Date(lastKnownStartDate);
  futureStartDate.setDate(futureStartDate.getDate() + (weeksAhead * 7));
  return futureStartDate;
};

const renderFutureWeeklyView = (startDate) => {
  const weekStartDate = startDate;
  const weekEndDate = new Date(weekStartDate);
  weekEndDate.setDate(weekEndDate.getDate() + 7);

  plannerContainer.innerHTML = ''; // Clear previous content

  // --- Render Header (copied from renderWeeklyView) ---
  plannerContainer.insertAdjacentHTML('beforeend', '<div class="table-cell day-header-cell font-semibold bg-gray-800 sticky top-0 z-10" style="grid-column: 1;">Time</div>');
  for (let i = 0; i < 7; i++) {
    const dayDate = new Date(weekStartDate);
    dayDate.setDate(weekStartDate.getDate() + i);
    plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell day-header-cell font-semibold bg-gray-800 sticky top-0 z-10" style="grid-column: ${i + 2};">${dayDate.toLocaleDateString(undefined, { weekday: 'short' })}<br>${dayDate.toLocaleDateString(undefined, { month: 'numeric', day: 'numeric' })}</div>`);
  }

  // --- Render Time Labels and Grid Cells (copied from renderWeeklyView) ---
  for (let hour = 0; hour <= 23; hour++) {
    const rowStart = hour * 4 + 2;
    const d = new Date();
    d.setHours(hour, 0);
    const timeStr = formatTime(d);
    plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell time-label-cell font-semibold bg-gray-800" style="grid-row: ${rowStart} / span 4;">${timeStr}</div>`);
    for (let day = 0; day < 7; day++) {
      for (let i = 0; i < 4; i++) {
        const slotRow = rowStart + i;
        // Note: In a read-only view, these slots are not interactive for creating new tasks.
        // We still need them for the grid structure.
        plannerContainer.insertAdjacentHTML('beforeend', `<div class="planner-slot" style="grid-column: ${day + 2}; grid-row: ${slotRow};"></div>`);
      }
    }
  }

  // --- Process and Render Tasks (copied from renderWeeklyView) ---
  const dailyTasks = Array.from({ length: 7 }, () => []);

  if (typeof tasks !== 'undefined' && tasks.length > 0) {
    const filteredTasks = tasks.filter(task => {
      if (categoryFilter.length === 0) return true;
      if (!task.categoryId) return categoryFilter.includes(null);
      return categoryFilter.includes(task.categoryId);
    });

    filteredTasks.forEach(task => {
      const occurrences = getTaskOccurrences(task, weekStartDate, weekEndDate);
      occurrences.forEach(({ occurrenceStartDate, occurrenceDueDate }) => {
        const dayOfWeek = occurrenceStartDate.getDay();
        dailyTasks[dayOfWeek].push({ task, occurrenceDate: occurrenceStartDate, dueDate: occurrenceDueDate });
      });
    });
  }

  dailyTasks.forEach((tasksForDay, dayIndex) => {
    const lanes = accommodate(tasksForDay);
    lanes.forEach((lane, laneIndex) => {
      lane.forEach(({ task, occurrenceDate, dueDate }) => {
        renderTaskOnGrid(task, occurrenceDate, dueDate, dayIndex, laneIndex, lanes.length, plannerContainer);
      });
    });
  });
};


// All the old planner rendering functions have been removed.

const initializePlannerState = () => {
  loadPlannerData();
  const today = new Date();
  const currentWeekStartDate = getStartOfWeek(today);
  if (appState.weeks.length === 0) {
    for (let i = -CURRENT_WEEK_INDEX; i < MAX_WEEKS_STORED - CURRENT_WEEK_INDEX; i++) {
      const weekStartDate = new Date(currentWeekStartDate);
      weekStartDate.setDate(weekStartDate.getDate() + (i * 7));
      appState.weeks.push(createNewWeek(weekStartDate));
    }
  } else {
    const storedCurrentWeekStart = new Date(appState.weeks[CURRENT_WEEK_INDEX].startDate);
    let weekDiff = Math.round((currentWeekStartDate.getTime() - storedCurrentWeekStart.getTime()) / (1000 * 60 * 60 * 24 * 7));
    if (weekDiff > 0) {
      uiSettings.dashboardWeekOffset = 0;
      saveData();
    }
  }
  while(appState.weeks.length > MAX_WEEKS_STORED) appState.weeks.shift();
  loadViewState();
  if(appState.viewingIndex < 0 || appState.viewingIndex >= MAX_WEEKS_STORED) {
    appState.viewingIndex = CURRENT_WEEK_INDEX;
  }
  savePlannerData();
};

function applyActiveView() {
  const views = [
    { btnId: 'show-task-manager-btn', viewId: 'task-manager-view' },
    { btnId: 'show-calendar-btn', viewId: 'calendar-view' },
    { btnId: 'show-dashboard-btn', viewId: 'dashboard-view' },
    { btnId: 'show-journal-btn', viewId: 'journal-view' }
  ];

  const activeViewId = uiSettings.activeView || 'dashboard-view';
  let foundActive = false;

  // Deactivate all views and buttons first
  views.forEach(item => {
    const viewEl = document.getElementById(item.viewId);
    const btnEl = document.getElementById(item.btnId);
    if (viewEl) viewEl.classList.add('hidden');
    if (btnEl) btnEl.classList.remove('active-view-btn');
  });

  // Activate the correct one
  const activeItem = views.find(item => item.viewId === activeViewId);

  if (activeItem) {
    const viewEl = document.getElementById(activeItem.viewId);
    const btnEl = document.getElementById(activeItem.btnId);
    if (viewEl) viewEl.classList.remove('hidden');
    if (btnEl) btnEl.classList.add('active-view-btn');

    // Post-activation logic
    if (activeItem.viewId === 'calendar-view' && calendar) calendar.updateSize();
    if (activeItem.viewId === 'dashboard-view') renderDashboardContent();
    if (activeItem.viewId === 'journal-view') renderJournal();
    foundActive = true;
  }


  // Fallback if the saved view ID is invalid
  if (!foundActive) {
    const dashboardView = document.getElementById('dashboard-view');
    const dashboardBtn = document.getElementById('show-dashboard-btn');
    if (dashboardView) dashboardView.classList.remove('hidden');
    if (dashboardBtn) dashboardBtn.classList.add('active-view-btn');
    renderDashboardContent();
  }
}

function initializeCalendar() {
  if (!calendarEl) {
    console.error('Calendar element not found!');
    return;
  }

  calendar = new Calendar(calendarEl, {
    plugins: [dayGridPlugin, timeGridPlugin, interactionPlugin],
    initialView: 'timeGridWeek',
    headerToolbar: false,
    editable: false,
    eventStartEditable: false,
    eventDrop: function(info) {
      info.revert();
    },
    slotEventOverlap: true,
    nowIndicator: true, // Show the current time indicator
    navLinks: true, // Allow clicking on day/week numbers to navigate
    eventOrder: (a, b) => {
      const startA_date = a.start ? new Date(a.start) : null;
      const startB_date = b.start ? new Date(b.start) : null;

      // Defensive check for valid start dates
      if (!startA_date || !startB_date || isNaN(startA_date) || isNaN(startB_date)) {
        return 0;
      }

      // Primary sort: start time (earlier first)
      if (startA_date.getTime() !== startB_date.getTime()) {
        return startA_date.getTime() - startB_date.getTime();
      }

      // Secondary sort: Positioning GPA (lower GPA is more urgent and comes first)
      const gpaA = a.extendedProps.positioningGpa ?? 4.0;
      const gpaB = b.extendedProps.positioningGpa ?? 4.0;
      if (gpaA !== gpaB) {
        return gpaA - gpaB;
      }

      // Tertiary sort: alphabetical by title
      return a.title.localeCompare(b.title);
    },
    eventClassNames: function(arg) {
      const { event } = arg;
      const durationMs = event.end - event.start;
      const thirtyMinutesMs = 30 * 60 * 1000;
      if (durationMs > 0 && durationMs < thirtyMinutesMs) {
        return ['fc-event-short'];
      }
      return [];
    },
    eventContent: function(arg) {
      const { event, timeText, view } = arg;
      const { extendedProps } = event;

      // --- Filtering Logic ---
      const filterTargetView = calendarSettings.filterTargetView || 'all';
      const applyFilters = filterTargetView === 'all' || filterTargetView === view.type;
      if (applyFilters) {
        const catId = extendedProps.category ? extendedProps.category.id : 'null';
        const filter = uiSettings.calendarCategoryFilters[catId];
        if (filter && !filter.show) {
          return { domNodes: [] };
        }
      }

      // --- Month View Rendering ---
      if (view.type === 'dayGridMonth') {
        const categoryColor = event.backgroundColor;
        const textColor = event.textColor;
        const iconHtml = extendedProps.icon && uiSettings.monthView.showIcon ? `<i class="${extendedProps.icon} fa-fw month-view-icon" style="color: ${textColor};"></i>` : '';
        const timeHtml = uiSettings.monthView.showTime ? `<span class="month-view-time">${timeText}</span>` : '';
        const nameHtml = uiSettings.monthView.showName ? `<span class="month-view-name">${event.title}</span>` : '';
        // The background is applied to the wrapper, and text color to the contents.
        return { html: `<div class="month-view-event-item" style="background-color: ${categoryColor}; color: ${textColor};">${iconHtml} ${timeHtml} ${nameHtml}</div>` };
      }

      // --- TimeGrid Week View Rendering ---
      if (view.type === 'timeGridWeek') {
        const iconHtml = uiSettings.weekView.showIcon && extendedProps.icon ? `<div><i class="${extendedProps.icon} fa-fw fc-event-icon"></i></div>` : '';
        const timeHtml = uiSettings.weekView.showTime ? `<div class="fc-event-time">${timeText}</div>` : '';
        const titleHtml = uiSettings.weekView.showName ? `<div class="fc-event-title">${event.title}</div>` : '';
        return { html: `<div class="fc-event-main-inner">${iconHtml}${timeHtml}${titleHtml}</div>` };
      }

      // --- TimeGrid Day View Rendering ---
      if (view.type === 'timeGridDay') {
        const iconHtml = uiSettings.dayView.showIcon && extendedProps.icon ? `<i class="${extendedProps.icon} fa-fw fc-event-icon mr-1"></i>` : '';
        const timeHtml = uiSettings.dayView.showTime ? `<span class="fc-event-time">${timeText}</span>` : '';
        const titleHtml = uiSettings.dayView.showName ? `<span class="fc-event-title ml-1">${event.title}</span>` : '';
        return { html: `<div class="fc-event-main-inner flex flex-wrap items-center">${iconHtml}${timeHtml}${titleHtml}</div>` };
      }

      // Fallback for any other views
      return { html: `<div class="fc-event-main-inner">${event.title}</div>` };
    },
    events: (fetchInfo, successCallback, failureCallback) => {
      try {
        // It's more robust to check the calendar's current view directly,
        // as fetchInfo.view can be undefined during certain refreshes.
        if (calendar && calendar.view.type === 'dayGridMonth') {
          successCallback(calendarMonthEvents);
        } else {
          // Default to the time-grid events if the view isn't month or calendar is not ready
          successCallback(calendarTimeGridEvents);
        }
      } catch (e) {
        console.error('Error providing events to FullCalendar:', e);
        // Ensure failureCallback exists before calling it
        if (failureCallback) {
          failureCallback(e);
        }
      }
    },
    datesSet: (info) => {
      // Update the custom header title
      if (weekStatusEl) {
        weekStatusEl.textContent = info.view.title;
      }

      // Update prev/next button labels and view button highlights
      const viewType = info.view.type;
      let prevText = '&lt; Prev';
      let nextText = 'Next &gt;';
      let activeView = 'weekly'; // default

      if (viewType === 'dayGridMonth') {
        prevText = '&lt; Prev Month';
        nextText = 'Next Month &gt;';
        activeView = 'month';
      } else if (viewType === 'timeGridWeek') {
        prevText = '&lt; Prev Week';
        nextText = 'Next Week &gt;';
        activeView = 'weekly';
      } else if (viewType === 'timeGridDay') {
        prevText = '&lt; Prev Day';
        nextText = 'Next Day &gt;';
        activeView = 'daily';
      }

      if (prevWeekBtn) prevWeekBtn.innerHTML = prevText;
      if (nextWeekBtn) nextWeekBtn.innerHTML = nextText;

      // Update active state on view buttons
      viewBtns.forEach(btn => {
        btn.classList.remove('active-view-btn');
        if (btn.dataset.view === activeView) {
          btn.classList.add('active-view-btn');
        }
      });
      // Use a timeout to ensure this runs after the button classes have been set, avoiding a race condition.
      setTimeout(() => applyTheme(), 0);
    },
    eventClick: (info) => {
      let eventId = info.event.id;
      const isHistorical = info.event.extendedProps.isHistorical;
      const occurrenceDueDate = info.event.extendedProps.occurrenceDueDate ? new Date(info.event.extendedProps.occurrenceDueDate) : null;

      // In month view, the event ID is a composite "segment ID". We need the base part.
      if (info.view.type === 'dayGridMonth' && eventId.includes('_')) {
        const parts = eventId.split('_');
        const potentialDate = parts[parts.length - 1];
        // Check if the last part is an ISO date string, which indicates a segment ID
        if (potentialDate.endsWith('Z') && !isNaN(new Date(potentialDate).getTime())) {
          eventId = parts.slice(0, -1).join('_');
        }
      }

      // Use the eventId (which includes the occurrence date for repeating tasks) to ensure we open the specific occurrence.
      // The previous logic incorrectly forced the master taskId, breaking occurrence editing.
      const idToOpen = eventId;

      openTaskView(idToOpen, isHistorical, occurrenceDueDate, 'calendar');
    },
    eventDidMount: function(info) {
      if (info.view.type === 'dayGridMonth') {
        if (info.event.borderColor) {
          info.el.style.borderColor = info.event.borderColor;
        }
      }
    },
    dateClick: (info) => {
      if (!calendarSettings.allowCreationOnClick) {
        return;
      }
      const taskStartDate = new Date(info.date);
      const taskDueDate = new Date(taskStartDate.getTime() + (60 * 60 * 1000)); // Add 1 hour

      const defaultCategoryName = plannerSettings.defaultCategoryId || 'Planner';
      let plannerCategory = categories.find(c => c.id === defaultCategoryName);
      if (!plannerCategory) {
        plannerCategory = { id: defaultCategoryName, name: defaultCategoryName, color: getRandomColor() };
        categories.push(plannerCategory);
        renderCategoryManager();
        renderCategoryFilters();
      }

      const newTaskData = {
        id: generateId(),
        name: 'New Event',
        dueDate: taskDueDate,
        estimatedDurationAmount: 1,
        estimatedDurationUnit: 'hours',
        categoryId: plannerCategory.id,
        createdAt: new Date(),
        repetitionType: 'none',
        misses: 0,
        completed: false,
        status: 'green',
      };

      const sanitizedTask = sanitizeAndUpgradeTask(newTaskData);
      tasks.push(sanitizedTask);

      saveData();
      calendar.refetchEvents();
      openModal(sanitizedTask.id, { occurrenceDate: taskDueDate });
    }
  });

  calendar.render();

  // --- Swipe Navigation for Calendar ---
  let touchStartX = 0;
  let touchEndX = 0;
  let lastSwipeDirection = null;
  let lastSwipeTime = 0;
  let swipeResetTimer = null;
  const SWIPE_TIMEOUT = 500; // ms

  calendarEl.addEventListener('touchstart', function(event) {
    touchStartX = event.changedTouches[0].screenX;
  }, { passive: true });

  calendarEl.addEventListener('touchend', function(event) {
    touchEndX = event.changedTouches[0].screenX;
    handleSwipeGesture();
  }, { passive: true });

  function handleSwipeGesture() {
    const swipeThreshold = 50; // Minimum pixels for a swipe
    const now = Date.now();
    let currentSwipeDirection = null;

    if (touchStartX - touchEndX > swipeThreshold) {
      currentSwipeDirection = 'left'; // Next
    } else if (touchEndX - touchStartX > swipeThreshold) {
      currentSwipeDirection = 'right'; // Prev
    }

    if (!currentSwipeDirection) return;

    // Clear any pending reset timer
    if (swipeResetTimer) {
      clearTimeout(swipeResetTimer);
      swipeResetTimer = null;
    }

    // Check for a consecutive swipe
    if (lastSwipeDirection === currentSwipeDirection && (now - lastSwipeTime < SWIPE_TIMEOUT)) {
      // This is the second swipe, trigger navigation
      if (currentSwipeDirection === 'left') {
        calendar.next();
      } else {
        calendar.prev();
      }
      // Reset state after successful double swipe
      lastSwipeDirection = null;
      lastSwipeTime = 0;
      if (uiSettings.userInteractions) {
        uiSettings.userInteractions.usedSwipeNavigation = true;
      }

    } else {
      // This is the first swipe, or the direction/timeout didn't match.
      // Set the state for the next potential swipe.
      lastSwipeDirection = currentSwipeDirection;
      lastSwipeTime = now;

      // Set a timer to reset the swipe state if a second swipe doesn't happen soon.
      swipeResetTimer = setTimeout(() => {
        lastSwipeDirection = null;
        lastSwipeTime = 0;
      }, SWIPE_TIMEOUT);
    }
  }
}

// =================================================================================
// S-6.0: INITIALIZATION
// =================================================================================
document.addEventListener('DOMContentLoaded', () => {
  console.log('Unified DOMContentLoaded event fired.');

  // --- Initialize Task Manager ---
  try {
    console.log('Initializing Task Manager...');
    initializeDOMElements(); // From Task Manager
    setupEventListeners();   // From Task Manager
    loadData();              // From Task Manager
    setAppBranding(); // Set the title on load

    // The automatic check for orphaned history has been removed.
    // This functionality is now available via a button in Advanced Options.

    console.log('Task Manager initialized.');
  } catch (e) {
    console.error('Error during Task Manager initialization:', e);
    const listDiv = document.getElementById('task-list');
    if(listDiv) listDiv.innerHTML = '<p class="text-red-600 font-bold text-center">Error initializing Task Manager. Please check console.</p>';
  }

  // --- Initialize Mission Planner ---
  try {
    console.log('Initializing Mission Planner...');
    initializePlannerState(); // Renamed from initializeOrSyncState
    applyTheme(); // Apply theme after state is initialized
    initializeCalendar(); // New function to set up FullCalendar
    applyActiveView(); // Apply the saved view
    if (uiSettings.activeView === 'journal-view') {
      renderJournal();
    }
    console.log('Mission Planner initialized.');
  } catch (e) {
    console.error('Error during Mission Planner initialization:', e);
  }

  // All initialization is complete. It's now safe to save data.
  updateAllTaskStatuses(true); // Manually trigger a full update and render on load
  isInitializing = false;
  console.log('Initialization complete. Data saving is now enabled.');

  // Retroactively mark welcome screen as shown for users who already have a theme.
  if (theming.enabled && !uiSettings.welcomeScreenShown) {
    uiSettings.welcomeScreenShown = true;
    saveData();
  }

  initializeHints();
  if (!uiSettings.welcomeScreenShown) {
    showWelcomeModal();
  }

  // Add a listener for custom test events
  window.addEventListener('run-test-action', (e) => {
    if (e.detail.action === 'updateAllTaskStatuses') {
      updateAllTaskStatuses(true);
    }
  });
});

function showWelcomeModal() {
  document.body.insertAdjacentHTML('beforeend', welcomeModalTemplate());
  const welcomeModal = document.getElementById('welcome-modal');
  const colorPicker = document.getElementById('welcome-color-picker');
  const noThanksBtn = document.getElementById('welcome-no-thanks');
  const submitBtn = document.getElementById('welcome-submit');

  const closeModal = () => {
    uiSettings.welcomeScreenShown = true;
    saveData();
    deactivateModal(welcomeModal);
    welcomeModal.remove();
  };

  noThanksBtn.addEventListener('click', () => {
    theming.mode = 'auto';
    saveData();
    applyTheme();
    initialFormState = getFormState(taskForm);
    closeModal();
  });

  submitBtn.addEventListener('click', () => {
    theming.enabled = true;
    theming.baseColor = colorPicker.value;
    theming.mode = 'auto';
    saveData();
    applyTheme();
    initialFormState = getFormState(taskForm);
    closeModal();
  });

  activateModal(welcomeModal);
}

// --- Hints & Tips Banner ---
const hints = [
  {
    id: 'prepTime',
    text: 'Did you know? You can set a \'Preparation Time\' for tasks to get earlier reminders in the task form.',
    interaction: 'usedPrepTime'
  },
  {
    id: 'calendarClickCreate',
    text: 'You can turn on \'Tap to Create\' for the calendar in Advanced Options under \'Planner Integration\' to quickly create events.',
    interaction: 'toggledCalendarClick'
  },
  {
    id: 'vacationMode',
    text: 'Going on a trip? Use \'Vacation Schedule\' in Advanced Options to automatically push task due dates.',
    interaction: 'addedVacation'
  },
  {
    id: 'vacationBypass',
    text: 'For important tasks during a break, set their category to \'Bypass Vacation\' in \'Vacation Schedule\'.',
    interaction: 'usedVacationBypass'
  },
  {
    id: 'bulkEdit',
    text: 'Pro-tip: Bulk-edit all tasks in a category from \'Category Management\' in Advanced Options.',
    interaction: 'usedBulkEdit'
  },
  {
    id: 'setKPI',
    text: 'Set a task as a \'KPI\' from the Dashboard to track your completion accuracy over time.',
    interaction: 'setKpi'
  },
  {
    id: 'journaling',
    text: 'Use the Journal to reflect on your week. Entries can be tagged with icons and grouped.',
    interaction: 'addedJournalEntry'
  },
  {
    id: 'sensitivity',
    text: 'The \'Planner Sensitivity\' slider changes how early the app warns you about upcoming tasks. Find what works for you!',
    interaction: 'changedSensitivity'
  },
  {
    id: 'exportData',
    text: 'Create a backup of your tasks and settings by using the \'Data & Notifications\' section in Advanced Options.',
    interaction: 'exportedData'
  },
  {
    id: 'statusColors',
    text: 'Personalize the look of your task list by changing the Status Colors in Advanced Options.',
    interaction: 'changedStatusColor'
  },
  {
    id: 'sortJournal',
    text: 'Did you know you can sort your Journal entries by date or by icon?',
    interaction: 'sortedJournal'
  },
  {
    id: 'dataCleanup',
    text: 'Keep your data tidy by using the \'Orphaned History Cleanup\' tool in Advanced Options under \'Data & Notifications\'.',
    interaction: 'usedDataMigration'
  },
  {
    id: 'swipeNav',
    text: 'To prevent accidental date changes on mobile, you now need to swipe twice in the same direction to navigate the calendar.',
    interaction: 'usedSwipeNavigation'
  }
];

function initializeHints() {
  const hintsBanner = document.getElementById('hints-banner');
  if (!hintsBanner) return;

  // Check if hints are globally disabled first.
  if (uiSettings.hintsDisabled) {
    hintsBanner.style.display = 'none';
    return;
  }


  if (!uiSettings.userInteractions) {
    uiSettings.userInteractions = {};
  }

  const showRandomHint = () => {
    // Double-check disabled flag inside the interval as well
    if (uiSettings.hintsDisabled) {
      hintsBanner.style.display = 'none';
      return;
    }

    const hintContent = hintsBanner.querySelector('.hints-content span');
    if (!hintContent) return;

    const availableHints = hints.filter(hint => !uiSettings.userInteractions[hint.interaction]);

    if (availableHints.length > 0) {
      const randomIndex = Math.floor(Math.random() * availableHints.length);
      hintContent.textContent = ` ${availableHints[randomIndex].text}`;
      hintsBanner.style.display = '';
    } else {
      hintsBanner.style.display = 'none';
    }
  };

  showRandomHint();
  setInterval(showRandomHint, 30000);
}
</script>
</body>
</html>
