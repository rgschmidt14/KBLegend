import { getDurationMs, calculateStatus, autoGenerateDailyKpiTasks, calculateScheduledTimes } from './task-logic.js';
import { taskTemplate, categoryManagerTemplate, taskViewTemplate, notificationManagerTemplate, taskStatsTemplate, actionAreaTemplate, commonButtonsTemplate, statusManagerTemplate, categoryFilterTemplate, iconPickerTemplate, editProgressTemplate, editCategoryTemplate, editStatusNameTemplate, restoreDefaultsConfirmationTemplate, taskGroupHeaderTemplate, bulkEditFormTemplate, dataMigrationModalTemplate } from './templates.js';
import { Calendar } from 'https://esm.sh/@fullcalendar/core@6.1.19';
import dayGridPlugin from 'https://esm.sh/@fullcalendar/daygrid@6.1.19';
import timeGridPlugin from 'https://esm.sh/@fullcalendar/timegrid@6.1.19';
import interactionPlugin from 'https://esm.sh/@fullcalendar/interaction@6.1.19';
import { Chart, registerables } from 'https://esm.sh/chart.js@4.4.3';
import { startOfWeek, format } from 'https://esm.sh/date-fns@3.6.0';
// =================================================================================
// SCRIPT.JS - COMBINED AND CLEANED
// =================================================================================

Chart.register(...registerables);

// =================================================================================
// SECTION 1: Global State, Constants, & DOM References
// =================================================================================
let tasks = [];
let categories = [];
const defaultStatusColors = { blue: '#00BFFF', green: '#22c55e', yellow: '#facc15', red: '#dc2626', black: '#4b5563' };
const defaultStatusNames = { blue: 'Locked', green: 'Ready', yellow: 'Start Soon', red: 'Do Right Now', black: 'Overdue' };
let statusColors = { ...defaultStatusColors };
let statusNames = { ...defaultStatusNames };
let notificationSettings = { enabled: false, rateLimit: { amount: 5, unit: 'minutes' }, categories: {} };
let notificationEngine = { timeouts: [], lastNotificationTimestamps: {} };
let theming = { enabled: false, baseColor: '#3b82f6', mode: 'auto' };
let appSettings = { title: "Task & Mission Planner", use24HourFormat: false };
let calendarSettings = { categoryFilter: [], syncFilter: true, lastView: 'timeGridWeek' };
let lastBulkEditSettings = {};
let oldTasksData = [];
let editingTaskId = null;
let isSimpleMode = true;
let countdownIntervals = {};
let mainUpdateInterval = null;
let taskTimers = {};
let sortBy = 'status';
let sortDirection = 'asc';
let categoryFilter = [];
let plannerSettings = { defaultCategoryId: 'Planner' };
let taskDisplaySettings = {
    showDueDate: true, showRepetition: true, showDuration: true,
    showCategory: true, showCountdown: true, showProgress: true,
};
const STATUS_UPDATE_INTERVAL = 15000;
const MS_PER_SECOND = 1000;

const iconCategories = {
    'General': ['fa-solid fa-star', 'fa-solid fa-heart', 'fa-solid fa-check', 'fa-solid fa-xmark', 'fa-solid fa-flag', 'fa-solid fa-bell', 'fa-solid fa-bolt', 'fa-solid fa-gift', 'fa-solid fa-key', 'fa-solid fa-lightbulb', 'fa-solid fa-moon', 'fa-solid fa-sun'],
    'Productivity': ['fa-solid fa-briefcase', 'fa-solid fa-bullseye', 'fa-solid fa-calendar-days', 'fa-solid fa-clock', 'fa-solid fa-file-signature', 'fa-solid fa-laptop-file', 'fa-solid fa-list-check', 'fa-solid fa-pencil', 'fa-solid fa-book-open', 'fa-solid fa-graduation-cap'],
    'Communication': ['fa-solid fa-at', 'fa-solid fa-envelope', 'fa-solid fa-phone', 'fa-solid fa-comments', 'fa-solid fa-users'],
    'Finance': ['fa-solid fa-dollar-sign', 'fa-solid fa-euro-sign', 'fa-solid fa-pound-sign', 'fa-solid fa-yen-sign', 'fa-solid fa-credit-card', 'fa-solid fa-wallet', 'fa-solid fa-piggy-bank'],
    'Health & Fitness': ['fa-solid fa-heart-pulse', 'fa-solid fa-dumbbell', 'fa-solid fa-person-running', 'fa-solid fa-apple-whole', 'fa-solid fa-pills', 'fa-solid fa-stethoscope'],
    'Travel': ['fa-solid fa-plane', 'fa-solid fa-car', 'fa-solid fa-train', 'fa-solid fa-bus', 'fa-solid fa-ship', 'fa-solid fa-earth-americas', 'fa-solid fa-map-location-dot', 'fa-solid fa-suitcase'],
    'Food & Drink': ['fa-solid fa-utensils', 'fa-solid fa-mug-hot', 'fa-solid fa-martini-glass', 'fa-solid fa-ice-cream', 'fa-solid fa-pizza-slice'],
};

const MS_PER_MINUTE = 60000;
const MS_PER_HOUR = 3600000;
const MS_PER_DAY = 86400000;
const DUE_THRESHOLD_MS = 1000;
const MAX_CYCLE_CALCULATION = 100;

// DOM Element References (Task Manager)
let taskModal, taskForm, taskListDiv, modalTitle, taskIdInput, taskNameInput, taskIconInput,
    iconPickerModal, dataMigrationModal,
    timeInputTypeSelect, dueDateGroup, taskDueDateInput, startDateGroup, taskStartDateInput,
    dueDateTypeSelect, relativeDueDateGroup,
    relativeAmountInput, relativeUnitSelect, taskRepetitionSelect, repetitionRelativeGroup,
    repetitionAmountInput, repetitionUnitSelect, repeatingOptionsGroup,
    maxMissesGroup, maxMissesInput, trackMissesInput,
    completionTypeSelect, estimatedDurationGroup,
    estimatedDurationAmountInput, estimatedDurationUnitSelect,
    completionCountGroup, countTargetInput,
    completionTimeGroup, timeTargetAmountInput, timeTargetUnitSelect,
    repetitionAbsoluteGroup, absoluteFrequencySelect,
    absoluteWeeklyOptions, absoluteMonthlyOptions, absoluteYearlyOptions,
    monthlyDayNumberOptions, monthlyDayOfWeekOptions, yearlyDayNumberOptions, yearlyDayOfWeekOptions,
    weekdayCheckboxes, monthlyOccurrenceCheckboxes, yearlyOccurrenceCheckboxes, yearlyMonthCheckboxes,
    monthlyWeekdayCheckboxes, yearlyWeekdayCheckboxes, monthlyDayCheckboxes, yearlyDayCheckboxes,
    requiresFullAttentionInput,
    taskCategorySelect, newCategoryGroup, newCategoryNameInput,
    advancedOptionsModal,
    sortBySelect, sortDirectionSelect, categoryFilterList,
    plannerDefaultCategorySelect, dayNightToggle;

// DOM Element References (Planner)
let app, weeklyGoalsEl, indicatorListEl, newIndicatorInput, newIndicatorFrequency, addIndicatorBtn,
    calendarEl, // New element for FullCalendar
    progressTrackerContainer, viewBtns, startNewWeekBtn, confirmModal,
    cancelNewWeekBtn, confirmNewWeekBtn, prevWeekBtn, nextWeekBtn, todayBtn,
    weekStatusEl, weekDateRangeEl,
    showTaskManagerBtn, showCalendarBtn, showDashboardBtn, taskManagerView, calendarView, dashboardView,
    taskViewModal, taskViewContent, taskStatsContent;

// FullCalendar instance
let calendar;

// Planner State
const MAX_WEEKS_STORED = 6;
const CURRENT_WEEK_INDEX = 4;
const DATA_KEY = 'pilotPlannerDataV8';
const VIEW_STATE_KEY = 'pilotPlannerViewStateV8';

const appState = {
    weeks: [],
    indicators: [ { id: 1, name: 'Hours Studied', frequency: 'weekly' }, { id: 2, name: 'Maneuvers Practiced', frequency: 'weekly' } ],
    historicalTasks: [],
    viewingIndex: CURRENT_WEEK_INDEX, currentView: 'weekly', currentDayIndex: 0,
};


// =================================================================================
// SECTION 2: Logic & Utility Functions
// =================================================================================
function generateId() { return '_' + Math.random().toString(36).substr(2, 9); }
const pad = (num, length = 2) => String(num).padStart(length, '0');

function formatTime(date) {
    if (!date || isNaN(date)) return 'N/A';
    const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: !appSettings.use24HourFormat };
    return date.toLocaleTimeString('en-US', timeOptions);
}

function formatDateForInput(date) {
    if (!date || !(date instanceof Date) || isNaN(date)) return '';
    try {
        const yr = date.getFullYear();
        const mm = pad(date.getMonth() + 1);
        const dd = pad(date.getDate());
        const hh = pad(date.getHours());
        const min = pad(date.getMinutes());
        return `${yr}-${mm}-${dd}T${hh}:${min}`;
    } catch (e) { console.error("Error formatting date:", date, e); return ''; }
}
function calculateFutureDate(amount, unit, baseDate) {
    try {
        const date = new Date(baseDate);
        amount = parseInt(amount, 10);
        if (isNaN(amount) || amount <= 0) amount = 1;
        switch (unit) {
            case 'minutes': date.setMinutes(date.getMinutes() + amount); break;
            case 'hours': date.setHours(date.getHours() + amount); break;
            case 'days': date.setDate(date.getDate() + amount); break;
            case 'weeks': date.setDate(date.getDate() + amount * 7); break;
            case 'months': date.setMonth(date.getMonth() + amount); break;
            default: console.warn("Unknown unit:", unit);
        }
        return date;
    } catch (e) { console.error("Error calculating future date:", e); return new Date(baseDate); }
}
function parseTimeToMs(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return 0;
    const parts = timeStr.split(':').map(Number);
    let ms = 0;
    if (parts.length === 3) {
        ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_HOUR;
        ms += (isNaN(parts[1]) ? 0 : parts[1]) * MS_PER_MINUTE;
        ms += (isNaN(parts[2]) ? 0 : parts[2]) * MS_PER_SECOND;
    } else if (parts.length === 2) {
        ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_MINUTE;
        ms += (isNaN(parts[1]) ? 0 : parts[1]) * MS_PER_SECOND;
    } else if (parts.length === 1) {
        ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_SECOND;
    }
    return ms;
}
function parseMinutesToMs(minutes) {
    minutes = parseInt(minutes, 10);
    return isNaN(minutes) || minutes < 0 ? 0 : minutes * MS_PER_MINUTE;
}
function calculatePendingCycles(task, nowMs) {
    let cycles = 0;
    const originalDueDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate ? new Date(task.dueDate) : null);
    if (!originalDueDate || isNaN(originalDueDate)) {
        console.warn(`Cannot calculate pending cycles for task ${task.id}: Invalid original due date.`);
        return 0;
    }
    const originalDueDateMs = originalDueDate.getTime();
    const nowDate = new Date(nowMs);
    if (task.repetitionType !== 'none' && originalDueDateMs < nowMs) {
        if (task.repetitionType === 'relative' && task.repetitionAmount && task.repetitionUnit) {
            const intervalMs = getDurationMs(task.repetitionAmount, task.repetitionUnit);
            if (intervalMs > 0) {
                cycles = Math.floor((nowMs - originalDueDateMs) / intervalMs);
                cycles = Math.max(0, cycles) + 1;
            } else {
                console.warn(`Invalid relative interval for task ${task.id}. Defaulting to 1 cycle.`);
                cycles = 1;
            }
        } else if (task.repetitionType === 'absolute') {
            try {
                const occurrences = generateAbsoluteOccurrences(task, new Date(originalDueDate), new Date(nowDate));
                const missedOccurrences = occurrences.filter(occ =>
                    occ.getTime() > originalDueDateMs && occ.getTime() <= nowMs
                );
                cycles = missedOccurrences.length + 1;
            } catch (e) {
                console.error(`Error generating occurrences for pending cycles task ${task.id}:`, e);
                cycles = 1;
            }
        } else {
            cycles = 1;
        }
    }
    return Math.max(cycles, 0);
}
function checkDayOfMonthMatch(date, daysOfMonth) {
    if (!daysOfMonth || daysOfMonth.length === 0) return false;
    const day = date.getDate();
    const year = date.getFullYear();
    const month = date.getMonth();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    for (const selectedDay of daysOfMonth) {
        const selectedDayStr = String(selectedDay);
        if (selectedDayStr === 'last' && day === daysInMonth) return true;
        if (selectedDayStr === 'second_last' && day === daysInMonth - 1) return true;
        if (selectedDayStr === 'third_last' && day === daysInMonth - 2) return true;
        const selectedDayNum = parseInt(selectedDayStr, 10);
        if (!isNaN(selectedDayNum) && selectedDayNum === day) {
            return true;
        }
    }
    return false;
}
function checkNthWeekdayMatch(date, occurrences, weekdays) {
    if (!occurrences || occurrences.length === 0 || !weekdays || weekdays.length === 0) return false;
    const targetDayOfWeek = date.getDay();
    if (!weekdays.includes(targetDayOfWeek)) {
        return false;
    }
    const dayOfMonth = date.getDate();
    const month = date.getMonth();
    const occurrenceNumber = Math.ceil(dayOfMonth / 7);
    for (const selectedOcc of occurrences) {
        const selectedOccStr = String(selectedOcc);
        if (selectedOccStr === 'last') {
            let nextWeekDate = new Date(date);
            nextWeekDate.setDate(dayOfMonth + 7);
            if (nextWeekDate.getMonth() !== month) return true;
        } else {
            const selectedOccNum = parseInt(selectedOccStr, 10);
            if (!isNaN(selectedOccNum) && selectedOccNum === occurrenceNumber) {
                return true;
            }
        }
    }
    return false;
}
function generateAbsoluteOccurrences(task, startDate, endDate) {
    if (task.repetitionType !== 'absolute' || !task.repetitionAbsoluteFrequency || !startDate || isNaN(startDate) || !endDate || isNaN(endDate) || endDate < startDate) {
        console.error(`Invalid input for generateAbsoluteOccurrences for task ${task.id}`);
        return [];
    }
    let occurrences = [];
    let currentDate = new Date(startDate);
    currentDate.setHours(0, 0, 0, 0);
    const maxDaysToScan = 366 * 10;
    let daysScanned = 0;
    const applyTime = (date) => {
        const originalTimeSource = task.dueDate || startDate;
        if (originalTimeSource && !isNaN(originalTimeSource)) {
            date.setHours(originalTimeSource.getHours(), originalTimeSource.getMinutes(), originalTimeSource.getSeconds(), originalTimeSource.getMilliseconds());
        } else {
            date.setHours(0, 0, 0, 0);
        }
        return date;
    };
    while (currentDate <= endDate && daysScanned < maxDaysToScan) {
        daysScanned++;
        let month = currentDate.getMonth();
        let dayOfWeek = currentDate.getDay();
        let isMatch = false;
        try {
            switch (task.repetitionAbsoluteFrequency) {
                case 'weekly':
                    if (task.repetitionAbsoluteWeeklyDays?.includes(dayOfWeek)) isMatch = true;
                    break;
                case 'monthly':
                    if (task.repetitionAbsoluteMonthlyMode === 'day_number') {
                        if (checkDayOfMonthMatch(currentDate, task.repetitionAbsoluteDaysOfMonth)) isMatch = true;
                    } else {
                        if (checkNthWeekdayMatch(currentDate, task.repetitionAbsoluteNthWeekdayOccurrence, task.repetitionAbsoluteNthWeekdayDays)) isMatch = true;
                    }
                    break;
                case 'yearly':
                    if (task.repetitionAbsoluteYearlyMonths?.includes(month)) {
                        if (task.repetitionAbsoluteYearlyMode === 'day_number') {
                            if (checkDayOfMonthMatch(currentDate, task.repetitionAbsoluteYearlyDaysOfMonth)) isMatch = true;
                        } else {
                            if (checkNthWeekdayMatch(currentDate, task.repetitionAbsoluteYearlyNthWeekdayOccurrence, task.repetitionAbsoluteYearlyNthWeekdayDays)) isMatch = true;
                        }
                    }
                    break;
            }
        } catch (e) {
            console.error(`Error checking match for ${task.id} on ${currentDate} in generateAbsoluteOccurrences:`, e);
        }
        if (isMatch) {
            let occurrenceDate = applyTime(new Date(currentDate));
            if (occurrenceDate.getTime() >= startDate.getTime() && occurrenceDate.getTime() <= endDate.getTime()) {
                occurrences.push(occurrenceDate);
            }
        }
        currentDate.setDate(currentDate.getDate() + 1);
        currentDate.setHours(0, 0, 0, 0);
    }
    if (daysScanned >= maxDaysToScan) {
        console.warn(`generateAbsoluteOccurrences reached scan limit (${maxDaysToScan} days) for task ${task.id}`);
    }
    occurrences.sort((a, b) => a.getTime() - b.getTime());
    return occurrences;
}
function sanitizeAndUpgradeTask(task) {
    const defaults = {
        name: 'Unnamed Task',
        icon: null,
        timeInputType: 'due',
        dueDateType: 'absolute',
        dueDate: null,
        repetitionType: 'none',
        maxMisses: null,
        trackMisses: true,
        requiresFullAttention: true,
        completionType: 'simple',
        currentProgress: 0,
        isTimerRunning: false,
        timerLastStarted: null,
        confirmationState: null,
        overdueStartDate: null,
        pendingCycles: null,
        misses: 0,
        completed: false,
        status: 'green',
        createdAt: new Date(),
        cycleEndDate: null,
        completionReducedMisses: false,
        estimatedDurationAmount: null,
        estimatedDurationUnit: 'minutes',
        categoryId: null,
        relativeAmount: null,
        relativeUnit: null,
        repetitionAmount: null,
        repetitionUnit: null,
        repetitionAbsoluteFrequency: null,
        repetitionAbsoluteWeeklyDays: null,
        repetitionAbsoluteMonthlyMode: null,
        repetitionAbsoluteDaysOfMonth: null,
        repetitionAbsoluteNthWeekdayOccurrence: null,
        repetitionAbsoluteNthWeekdayDays: null,
        repetitionAbsoluteYearlyMonths: null,
        repetitionAbsoluteYearlyMode: null,
        repetitionAbsoluteYearlyDaysOfMonth: null,
        repetitionAbsoluteYearlyNthWeekdayOccurrence: null,
        repetitionAbsoluteYearlyNthWeekdayDays: null,
        countTarget: null,
        timeTargetAmount: null,
        timeTargetUnit: null,
    };
    const originalTaskJSON = JSON.stringify(task);
    let upgradedTask = { ...defaults };
    for (const key in defaults) {
        if (task.hasOwnProperty(key) && task[key] !== undefined) {
            upgradedTask[key] = task[key];
        }
    }

    upgradedTask.id = task.id;
    if (task.createdAt) {
      upgradedTask.createdAt = task.createdAt;
    }
    if (task.estimatedDuration && !task.estimatedDurationAmount) {
        upgradedTask.estimatedDurationAmount = parseInt(task.estimatedDuration, 10);
        upgradedTask.estimatedDurationUnit = 'minutes';
    }
    if (upgradedTask.dueDateType !== 'relative') {
        upgradedTask.relativeAmount = null;
        upgradedTask.relativeUnit = null;
    }
    if (upgradedTask.repetitionType === 'none') {
        upgradedTask.repetitionAmount = null;
        upgradedTask.repetitionUnit = null;
        upgradedTask.repetitionAbsoluteFrequency = null;
        upgradedTask.maxMisses = null;
    }
    if (upgradedTask.repetitionType !== 'relative') {
        upgradedTask.repetitionAmount = null;
        upgradedTask.repetitionUnit = null;
    }
    if (upgradedTask.repetitionType !== 'absolute') {
        upgradedTask.repetitionAbsoluteFrequency = null;
    }
    if (upgradedTask.completionType !== 'count') {
        upgradedTask.countTarget = null;
    }
    if (upgradedTask.completionType !== 'time') {
        upgradedTask.timeTargetAmount = null;
        upgradedTask.timeTargetUnit = null;
    }
    if (JSON.stringify(upgradedTask) !== originalTaskJSON) {
        console.log(`Upgraded task ID ${task.id}:`, { from: JSON.parse(originalTaskJSON), to: upgradedTask });
    }
    return upgradedTask;
}
function getRandomColor() {
    if (theming.enabled) {
        const palette = generateComplementaryPalette(theming.baseColor);
        const accentColors = [palette.accent1, palette.accent2, palette.accent3];
        return accentColors[Math.floor(Math.random() * accentColors.length)];
    }
    // Original random pastel color logic
    const hue = Math.floor(Math.random() * 360);
    const hslToHex = (h, s, l) => {
        l /= 100;
        const a = s * Math.min(l, 1 - l) / 100;
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    };
    return hslToHex(hue, 80, 85);
}
function getContrastingTextColor(hexcolor) {
    if (!hexcolor) return { color: '#000000', textShadow: 'none' };

    const r = parseInt(hexcolor.substr(1, 2), 16);
    const g = parseInt(hexcolor.substr(3, 2), 16);
    const b = parseInt(hexcolor.substr(5, 2), 16);

    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

    let textColor = luminance > 0.5 ? '#000000' : '#FFFFFF';
    let textShadow = 'none';

    const distanceFromMiddle = Math.abs(luminance - 0.5);
    const opacity = 1 - (distanceFromMiddle / 0.5);

    if (luminance > 0.25 && luminance < 0.75) {
        let shadowColor = luminance > 0.5 ? `rgba(255, 255, 255, ${opacity * 0.7})` : `rgba(0, 0, 0, ${opacity * 0.7})`;
        textShadow = `0px 0px 1px ${shadowColor}`;
    }

    return { color: textColor, textShadow: textShadow };
}
function hexToRgb(hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
}
function interpolateColor(color1, color2, factor) {
    let rgb1 = hexToRgb(color1);
    let rgb2 = hexToRgb(color2);
    if (!rgb1 || !rgb2) return color1; // Fallback

    let result = {
        r: Math.round(rgb1.r + factor * (rgb2.r - rgb1.r)),
        g: Math.round(rgb1.g + factor * (rgb2.g - rgb1.g)),
        b: Math.round(rgb1.b + factor * (rgb2.b - rgb1.b))
    };
    return rgbToHex(result.r, result.g, result.b);
}
function interpolateFiveColors(percent) {
    const colors = [statusColors.black, statusColors.red, statusColors.yellow, statusColors.green, statusColors.blue];
    if (percent <= 0) return colors[0];
    if (percent >= 1) return colors[4];

    const scaledPercent = percent * 4; // Scale to 0-4 range
    const colorIndex = Math.floor(scaledPercent);
    const factor = scaledPercent - colorIndex;

    const interpolatedHex = interpolateColor(colors[colorIndex], colors[colorIndex + 1], factor);

    // Adjust lightness to prevent colors from becoming too pale, ensuring text contrast.
    const hsl = hexToHSL(interpolatedHex);
    hsl.l = Math.max(25, Math.min(hsl.l, 85)); // Clamp lightness between 25% and 85%
    return HSLToHex(hsl.h, hsl.s, hsl.l);
}
function getDueDateGroup(dueDate) {
    if (!dueDate || isNaN(dueDate)) return { name: 'Unscheduled', index: 12 };

    const now = new Date();
    const diffMs = dueDate.getTime() - now.getTime();

    if (diffMs <= 0) return { name: 'Overdue', index: 0 };
    if (diffMs <= MS_PER_HOUR) return { name: 'Next Hour', index: 1 };
    if (diffMs <= MS_PER_HOUR * 4) return { name: 'Next 4 Hours', index: 2 };
    if (diffMs <= MS_PER_HOUR * 8) return { name: 'Next 8 Hours', index: 3 };

    const endOfDay = new Date(now);
    endOfDay.setHours(23, 59, 59, 999);
    if (dueDate <= endOfDay) return { name: 'End of Day', index: 4 };

    const endOfTomorrow = new Date(endOfDay);
    endOfTomorrow.setDate(endOfTomorrow.getDate() + 1);
    if (dueDate <= endOfTomorrow) return { name: 'End of Tomorrow', index: 5 };

    const endOfWeek = new Date(now);
    endOfWeek.setDate(now.getDate() + (6 - now.getDay())); // Assuming Sunday is day 0
    endOfWeek.setHours(23, 59, 59, 999);
    if (dueDate <= endOfWeek) return { name: 'End of Week', index: 6 };

    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
    if (dueDate <= endOfMonth) return { name: 'End of Month', index: 7 };

    const quarter = Math.floor(now.getMonth() / 3);
    const endOfQuarter = new Date(now.getFullYear(), quarter * 3 + 3, 0, 23, 59, 59, 999);
    if (dueDate <= endOfQuarter) return { name: 'End of Quarter', index: 8 };

    const endOfYear = new Date(now.getFullYear(), 12, 0, 23, 59, 59, 999);
    if (dueDate <= endOfYear) return { name: 'End of Year', index: 9 };

    const endOf5Years = new Date(now.getFullYear() + 5, 11, 31, 23, 59, 59, 999);
    if (dueDate <= endOf5Years) return { name: 'Next 5 Years', index: 10 };

    const endOf10Years = new Date(now.getFullYear() + 10, 11, 31, 23, 59, 59, 999);
    if (dueDate <= endOf10Years) return { name: 'Next 10 Years', index: 11 };

    return { name: 'Beyond 10 Years', index: 12 };
}

function getTaskOccurrences(task, viewStartDate, viewEndDate) {
    if (!task.dueDate) return [];

    const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit) || 0;

    // We need to search for due dates in a slightly expanded window to catch tasks that start before the view
    const expandedViewStartDate = new Date(viewStartDate.getTime() - (24 * MS_PER_HOUR)); // Look back 24h as a safe buffer

    let dueDatesInExpandedWindow = [];
    const initialDueDate = new Date(task.dueDate);

    if (task.repetitionType === 'none') {
        dueDatesInExpandedWindow.push(initialDueDate);
    } else if (task.repetitionType === 'absolute') {
        // Generate all occurrences in the expanded window
        dueDatesInExpandedWindow = generateAbsoluteOccurrences(task, expandedViewStartDate, viewEndDate);
    } else if (task.repetitionType === 'relative') {
        const intervalMs = getDurationMs(task.repetitionAmount, task.repetitionUnit);
        if (intervalMs > 0) {
            let currentDate = new Date(initialDueDate);
            // Move backward from the initial due date to find the first potential occurrence before our expanded view.
            while (currentDate.getTime() > expandedViewStartDate.getTime()) {
                currentDate = new Date(currentDate.getTime() - intervalMs);
            }
            // Now, `currentDate` is before or at the start of our search window.
            // Move forward and collect all due dates that fall within the search window up to the view's end.
            let i = 0; // Safety break
            while (currentDate.getTime() < viewEndDate.getTime() && i < 500) {
                // We only need to add it if it's after the start of our search window.
                if (currentDate.getTime() >= expandedViewStartDate.getTime()) {
                    dueDatesInExpandedWindow.push(new Date(currentDate));
                }
                currentDate = new Date(currentDate.getTime() + intervalMs);
                i++;
            }
        }
    }

    // Now, map the candidate due dates to occurrence objects { start, due }
    // and filter for the ones that actually overlap with the *original* view window.
    const occurrences = dueDatesInExpandedWindow.map(dueDate => {
        // If the task has a scheduled time, and this is the first occurrence, use it.
        if (task.scheduledStartTime && dueDate.getTime() === new Date(task.dueDate).getTime()) {
            return {
                occurrenceDueDate: new Date(task.scheduledEndTime),
                occurrenceStartDate: new Date(task.scheduledStartTime)
            };
        }
        return {
            occurrenceDueDate: dueDate,
            occurrenceStartDate: new Date(dueDate.getTime() - durationMs)
        };
    }).filter(occ => {
        // Overlap condition: The task's start is before the view's end, AND the task's end is after the view's start.
        return occ.occurrenceStartDate < viewEndDate && occ.occurrenceDueDate > viewStartDate;
    });

    return occurrences;
}

function processTaskHistoryForChart(history) {
    if (!history || history.length === 0) {
        return { labels: [], completions: [], misses: [] };
    }

    const weeklyData = {}; // Key: YYYY-MM-DD of the start of the week

    history.forEach(item => {
        const date = new Date(item.completionDate);
        if (isNaN(date)) return;

        const weekStart = startOfWeek(date, { weekStartsOn: 1 }); // Monday start
        const weekKey = format(weekStart, 'yyyy-MM-dd');

        if (!weeklyData[weekKey]) {
            weeklyData[weekKey] = { completions: 0, misses: 0 };
        }

        if (item.status === 'completed') {
            weeklyData[weekKey].completions++;
        } else if (item.status === 'missed') {
            weeklyData[weekKey].misses++;
        }
    });

    const sortedWeeks = Object.keys(weeklyData).sort();

    const labels = sortedWeeks;
    const completions = sortedWeeks.map(week => weeklyData[week].completions);
    const misses = sortedWeeks.map(week => weeklyData[week].misses);

    return { labels, completions, misses };
}


// --- Theming Engine Functions ---

function hexToHSL(H) {
    let r = 0, g = 0, b = 0;
    if (H.length == 4) {
        r = "0x" + H[1] + H[1]; g = "0x" + H[2] + H[2]; b = "0x" + H[3] + H[3];
    } else if (H.length == 7) {
        r = "0x" + H[1] + H[2]; g = "0x" + H[3] + H[4]; b = "0x" + H[5] + H[6];
    }
    r /= 255; g /= 255; b /= 255;
    let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0, s = 0, l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return { h, s, l };
}

function HSLToHex(h, s, l) {
    s /= 100; l /= 100;
    let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c/2, r = 0, g = 0, b = 0;
    if (0 <= h && h < 60) { r = c; g = x; b = 0; }
    else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
    else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
    else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
    else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
    else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
    r = Math.round((r + m) * 255).toString(16);
    g = Math.round((g + m) * 255).toString(16);
    b = Math.round((b + m) * 255).toString(16);
    if (r.length == 1) r = "0" + r;
    if (g.length == 1) g = "0" + g;
    if (b.length == 1) b = "0" + b;
    return "#" + r + g + b;
}

function generateGradientPalette(baseColor) {
    const baseHSL = hexToHSL(baseColor);
    const isDarkMode = theming.mode === 'night';
    const minLightness = isDarkMode ? 45 : 0; // Ensure minimum brightness in dark mode

    const palette = {
        blue:   HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + 10), Math.max(minLightness, baseHSL.l + 15)),
        green:  HSLToHex(baseHSL.h, baseHSL.s, Math.max(minLightness, baseHSL.l)),
        yellow: HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + 15), Math.max(minLightness, baseHSL.l - 15)),
        red:    HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + 25), Math.max(minLightness, baseHSL.l - 30)),
        black:  HSLToHex(baseHSL.h, baseHSL.s, Math.max(minLightness, baseHSL.l - 45))
    };
    return palette;
}

function generateComplementaryPalette(baseColor) {
    const baseHSL = hexToHSL(baseColor);
    const isDarkMode = theming.mode === 'night';
    const minLightness = isDarkMode ? 50 : 0;

    // Triadic color scheme for primary, secondary, tertiary buttons
    const primary = HSLToHex(baseHSL.h, baseHSL.s, Math.max(minLightness, baseHSL.l));
    const secondary = HSLToHex((baseHSL.h + 120) % 360, baseHSL.s, Math.max(minLightness, baseHSL.l));
    const tertiary = HSLToHex((baseHSL.h + 240) % 360, baseHSL.s, Math.max(minLightness, baseHSL.l));

    // Accent colors for other things, like new categories
    const complementaryHue = (baseHSL.h + 180) % 360;
    const accent1 = HSLToHex(complementaryHue, baseHSL.s - 10, Math.max(minLightness, baseHSL.l + 10));
    const accent2 = HSLToHex((complementaryHue + 45) % 360, baseHSL.s - 10, Math.max(minLightness, baseHSL.l + 5));
    const accent3 = HSLToHex((complementaryHue - 45 + 360) % 360, baseHSL.s, Math.max(minLightness, baseHSL.l));

    return { primary, secondary, tertiary, accent1, accent2, accent3 };
}

function applyThemeMode() {
    document.body.classList.remove('light-mode', 'auto-theme');
    if (theming.mode === 'light') {
        document.body.classList.add('light-mode');
    } else if (theming.mode === 'auto') {
        document.body.classList.add('auto-theme');
    }
    // For 'night' mode, no class is needed as it's the default.
}

function setAppTitle(newTitle) {
    if (!newTitle || newTitle.trim() === '') {
        newTitle = "Task & Mission Planner"; // Default title
    }
    appSettings.title = newTitle;
    const headerTitle = document.querySelector('#app header h1');
    if (headerTitle) {
        headerTitle.textContent = newTitle;
    }
    document.title = newTitle;
    saveData();
}

function applyTheme() {
    applyThemeMode(); // Apply day/night/auto mode first

    const styleButton = (btn, bgColor) => {
        const textStyle = getContrastingTextColor(bgColor);
        btn.style.backgroundColor = bgColor;
        btn.style.color = textStyle.color;
        btn.style.textShadow = textStyle.textShadow;
        btn.style.borderColor = 'transparent'; // Remove default borders that might clash
    };

    const unstyleButton = (btn) => {
        btn.style.backgroundColor = '';
        btn.style.color = '';
        btn.style.textShadow = '';
        btn.style.borderColor = '';
    };

    if (theming.enabled) {
        const gradientPalette = generateGradientPalette(theming.baseColor);
        statusColors = gradientPalette;

        const buttonPalette = generateComplementaryPalette(theming.baseColor);
        const { primary, secondary, tertiary } = buttonPalette;

        // Theme buttons based on their functional color class
        document.querySelectorAll('.themed-button-primary').forEach(btn => styleButton(btn, primary));
        document.querySelectorAll('.themed-button-secondary').forEach(btn => styleButton(btn, secondary));
        document.querySelectorAll('.themed-button-tertiary').forEach(btn => styleButton(btn, tertiary));

    } else {
        // Revert to default colors
        statusColors = { ...defaultStatusColors };

        // Remove inline styles from all themed buttons to revert to CSS
        document.querySelectorAll('.themed-button-primary, .themed-button-secondary, .themed-button-tertiary').forEach(btn => {
            unstyleButton(btn);
        });
    }
    renderTasks();
    if (calendar) {
        calendar.refetchEvents();
        calendar.updateSize(); // Force calendar to re-render its container
    }
}





// =================================================================================
// SECTION 3: UI Rendering Functions
// =================================================================================
function stopAllTimers() {
    stopAllCountdownTimers();
    Object.keys(taskTimers).forEach(taskId => stopTaskTimer(taskId));
}
function stopCountdownTimer(taskId) {
    if (countdownIntervals[taskId]) {
        clearInterval(countdownIntervals[taskId]);
        delete countdownIntervals[taskId];
    }
}
function stopAllCountdownTimers() {
    Object.keys(countdownIntervals).forEach(taskId => clearInterval(countdownIntervals[taskId]));
    countdownIntervals = {};
}
function stopTaskTimer(taskId) {
    if (taskTimers[taskId]) {
        clearInterval(taskTimers[taskId]);
        delete taskTimers[taskId];
    }
}
function renderTasks() {
    stopAllTimers();
    taskListDiv.innerHTML = '';
    const filteredTasks = tasks.filter(task => {
        if (categoryFilter.length === 0) return true;
        if (!task.categoryId) return categoryFilter.includes(null);
        return categoryFilter.includes(task.categoryId);
    });
    if (filteredTasks.length === 0) {
        taskListDiv.innerHTML = '<p class="text-gray-500 text-center italic">No tasks match the current filter.</p>';
        return;
    }
    const statusOrder = { 'black': 0, 'red': 1, 'yellow': 2, 'green': 3, 'blue': 4 };

    const sortedTasks = filteredTasks.sort((a, b) => {
        const completedA = a.repetitionType === 'none' && a.completed;
        const completedB = b.repetitionType === 'none' && b.completed;
        if (completedA && !completedB) return 1;
        if (!completedA && completedB) return -1;
        let comparison = 0;
        if (sortBy === 'status') {
            comparison = (statusOrder[a.status] ?? 5) - (statusOrder[b.status] ?? 5);
        } else if (sortBy === 'dueDate') {
            const dueDateA = a.dueDate ? a.dueDate.getTime() : Infinity;
            const dueDateB = b.dueDate ? b.dueDate.getTime() : Infinity;
            comparison = dueDateA - dueDateB;
        } else if (sortBy === 'category') {
            const categoryA = categories.find(c => c.id === a.categoryId)?.name || 'Uncategorized';
            const categoryB = categories.find(c => c.id === b.categoryId)?.name || 'Uncategorized';
            comparison = categoryA.localeCompare(categoryB);
        }
        if (comparison === 0) {
            const dueDateA = a.dueDate ? a.dueDate.getTime() : Infinity;
            const dueDateB = b.dueDate ? b.dueDate.getTime() : Infinity;
            comparison = dueDateA - dueDateB;
        }
        return sortDirection === 'asc' ? comparison : -comparison;
    });

    const renderTaskItem = (task, groupName) => {
        const taskElement = document.createElement('div');
        const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;

        taskElement.className = `task-item p-2 rounded-lg shadow flex justify-between items-start`;
        taskElement.dataset.taskId = task.id;
        taskElement.dataset.action = 'viewTask'; // Make the whole card clickable
        taskElement.dataset.status = task.status;
        if (groupName) {
            taskElement.dataset.group = groupName;
        }
        taskElement.dataset.confirming = !!task.confirmationState;

        const statusColor = statusColors[task.status] || statusColors.green;
        taskElement.style.backgroundColor = statusColor;
        const category = categories.find(c => c.id === task.categoryId);
        const categoryColor = category ? category.color : 'transparent';
        taskElement.style.borderLeft = `5px solid ${categoryColor}`;
        const textStyle = getContrastingTextColor(statusColor);
        taskElement.style.color = textStyle.color;
        taskElement.style.textShadow = textStyle.textShadow;

        if (isCompletedNonRepeating) taskElement.classList.add('task-completed');
        if (task.confirmationState === 'confirming_delete') taskElement.classList.add('task-confirming-delete');

        taskElement.innerHTML = taskTemplate(task, { categories, taskDisplaySettings, getContrastingTextColor, appSettings });

        taskListDiv.appendChild(taskElement);

        const actionArea = taskElement.querySelector(`#action-area-${task.id}`);
        const commonButtonsArea = taskElement.querySelector(`#common-buttons-${task.id}`);
        if (actionArea) actionArea.innerHTML = actionAreaTemplate(task);
        if (commonButtonsArea) commonButtonsArea.innerHTML = commonButtonsTemplate(task);
    };

    if (sortBy === 'dueDate') {
        const groupedByDate = {};
        sortedTasks.forEach(task => {
            const group = getDueDateGroup(task.dueDate);
            if (!groupedByDate[group.index]) {
                groupedByDate[group.index] = { name: group.name, tasks: [] };
            }
            groupedByDate[group.index].tasks.push(task);
        });

        const groupOrder = Object.keys(groupedByDate).sort((a, b) => a - b);
        if (sortDirection === 'desc') groupOrder.reverse();

        groupOrder.forEach((groupIndex, i) => {
            const group = groupedByDate[groupIndex];
            const percent = groupOrder.length <= 1 ? 0 : (sortDirection === 'asc' ? i / (groupOrder.length - 1) : (groupOrder.length - 1 - i) / (groupOrder.length - 1));
            const bgColor = interpolateFiveColors(percent);
            const textStyle = getContrastingTextColor(bgColor);
            taskListDiv.insertAdjacentHTML('beforeend', taskGroupHeaderTemplate(group.name, bgColor, textStyle));
            group.tasks.forEach(task => renderTaskItem(task, group.name));
        });

    } else { // Handles 'status' and 'category' sorting
        let lastGroup = null;
        sortedTasks.forEach(task => {
            let currentGroup = '';
            let groupColor = '#e5e7eb';

            if (sortBy === 'status') {
                currentGroup = statusNames[task.status] || task.status;
                groupColor = statusColors[task.status] || '#e5e7eb';
            } else if (sortBy === 'category') {
                const category = categories.find(c => c.id === task.categoryId);
                currentGroup = category ? category.name : 'Uncategorized';
                groupColor = category ? category.color : '#FFFFFF';
            }

            if (currentGroup !== lastGroup) {
                const textStyle = getContrastingTextColor(groupColor);
                taskListDiv.insertAdjacentHTML('beforeend', taskGroupHeaderTemplate(currentGroup, groupColor, textStyle));
                lastGroup = currentGroup;
            }
            renderTaskItem(task, currentGroup);
        });
    }

    startAllCountdownTimers();
}

function formatTimeRemaining(ms) {
    try {
        if (ms <= DUE_THRESHOLD_MS && ms > -DUE_THRESHOLD_MS) return "Due!";
        const isOverdue = ms < 0;
        const absMs = Math.abs(ms);
        const s = Math.floor(absMs / 1000) % 60;
        const m = Math.floor(absMs / MS_PER_MINUTE) % 60;
        const h = Math.floor(absMs / MS_PER_HOUR) % 24;
        const d = Math.floor(absMs / MS_PER_DAY);
        let parts = [];
        if (d > 0) parts.push(`${d} day${d > 1 ? 's' : ''}`);
        if (h > 0) parts.push(`${h} hr${h > 1 ? 's' : ''}`);
        if ((d === 0 || parts.length < 2) && m > 0) parts.push(`${m} min${m > 1 ? 's' : ''}`);
        if (d === 0 && h === 0 && (parts.length < 2 || m === 0) && s > 0) parts.push(`${s} sec${s > 1 ? 's' : ''}`);
        const timeStr = parts.slice(0, 2).join(' ') || (isOverdue ? 'just now' : 'Less than a minute');
        return isOverdue ? `Overdue by: ${timeStr}` : timeStr;
    } catch (e) {
        console.error("Error formatting time remaining:", ms, e);
        return "Error";
    }
}
function updateCountdown(taskId) {
    try {
        const task = tasks.find(t => t.id === taskId);
        const countdownElement = document.getElementById(`countdown-${taskId}`);
        if (!task || !countdownElement) { stopCountdownTimer(taskId); return; }
        if (task.repetitionType === 'none' && task.completed) {
            countdownElement.textContent = '';
            stopCountdownTimer(taskId);
            return;
        }
        const nowMs = Date.now();
        let targetDateMs = null;
        let prefix = '';
        if (task.status === 'blue' && task.cycleEndDate && !isNaN(task.cycleEndDate)) {
            targetDateMs = task.cycleEndDate.getTime();
            prefix = 'Unlocks in: ';
            if (targetDateMs - nowMs <= 0) {
                countdownElement.textContent = '';
                stopCountdownTimer(taskId);
                return;
            }
        } else if (task.dueDate && !isNaN(task.dueDate)) {
            targetDateMs = task.dueDate.getTime();
        } else {
            countdownElement.textContent = '';
            stopCountdownTimer(taskId);
            return;
        }
        const timeRemaining = targetDateMs - nowMs;
        if (task.confirmationState && timeRemaining < 0) prefix = '';
        countdownElement.textContent = prefix + formatTimeRemaining(timeRemaining);
    } catch (e) {
        console.error("Error updating countdown for task:", taskId, e);
        stopCountdownTimer(taskId);
    }
}
function startAllCountdownTimers() {
    stopAllCountdownTimers();
    tasks.forEach(task => {
        try {
            if (task.repetitionType === 'none' && task.completed) return;
            let targetDate = null;
            if (task.status === 'blue' && task.cycleEndDate && !isNaN(task.cycleEndDate)) {
                targetDate = task.cycleEndDate;
            } else if (task.dueDate && !isNaN(task.dueDate)) {
                targetDate = task.dueDate;
            }
            if (targetDate) {
                updateCountdown(task.id);
                const timeRemaining = targetDate.getTime() - Date.now();
                if ((task.status === 'blue' && timeRemaining > 0) || task.status !== 'blue') {
                    if (!countdownIntervals[task.id]) {
                        countdownIntervals[task.id] = setInterval(() => updateCountdown(task.id), 1000);
                    }
                }
            }
        } catch(e) {
            console.error("Error starting countdown timer for task:", task?.id, e);
        }
    });
}
function activateModal(modalElement) {
    if (!modalElement) return;
    modalElement.classList.add('active');
    document.body.classList.add('modal-open');
}

function deactivateModal(modalElement) {
    if (!modalElement) return;
    modalElement.classList.remove('active');
    document.body.classList.remove('modal-open');
}

function openModal(taskId = null, options = {}) {
    try {
        taskForm.reset();
        editingTaskId = taskId;

        // Reset all dynamic fields to their default state
        dueDateGroup.classList.remove('hidden');
        startDateGroup.classList.add('hidden');
        relativeDueDateGroup.classList.add('hidden');
        repetitionRelativeGroup.classList.add('hidden');
        repetitionAbsoluteGroup.classList.add('hidden');
        repeatingOptionsGroup.classList.add('hidden');
        completionCountGroup.classList.add('hidden');
        completionTimeGroup.classList.add('hidden');
        estimatedDurationGroup.classList.remove('hidden');
        newCategoryGroup.classList.add('hidden');

        while (taskCategorySelect.options.length > 2) {
            taskCategorySelect.remove(2);
        }
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.id;
            option.textContent = cat.name;
            taskCategorySelect.appendChild(option);
        });

        if (taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) { console.error("Task not found for editing:", taskId); return; }
            modalTitle.textContent = 'Edit Task';
            taskIdInput.value = task.id;
            taskNameInput.value = task.name;
            taskIconInput.value = task.icon || '';

            // Set Time Input Type and corresponding date fields
            timeInputTypeSelect.value = task.timeInputType || 'due';
            const dateToUse = options.occurrenceDate || task.dueDate;

            if (task.timeInputType === 'start') {
                dueDateGroup.classList.add('hidden');
                startDateGroup.classList.remove('hidden');
                const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
                const startDate = new Date(dateToUse.getTime() - durationMs);
                taskStartDateInput.value = formatDateForInput(startDate);
            } else {
                dueDateGroup.classList.remove('hidden');
                startDateGroup.classList.add('hidden');
                taskDueDateInput.value = formatDateForInput(dateToUse);
            }

            dueDateTypeSelect.value = task.dueDateType || 'absolute';
            relativeDueDateGroup.classList.toggle('hidden', task.dueDateType !== 'relative');
            if (task.dueDateType === 'relative') {
                relativeAmountInput.value = task.relativeAmount || 1;
                relativeUnitSelect.value = task.relativeUnit || 'days';
            }

            taskRepetitionSelect.value = task.repetitionType || 'none';
            repetitionRelativeGroup.classList.toggle('hidden', task.repetitionType !== 'relative');
            repetitionAbsoluteGroup.classList.toggle('hidden', task.repetitionType !== 'absolute');
            repeatingOptionsGroup.classList.toggle('hidden', task.repetitionType === 'none');
            if (task.repetitionType === 'relative') {
                repetitionAmountInput.value = task.repetitionAmount || 1;
                repetitionUnitSelect.value = task.repetitionUnit || 'days';
            } else if (task.repetitionType === 'absolute') {
                absoluteFrequencySelect.value = task.repetitionAbsoluteFrequency || 'weekly';
                toggleAbsoluteRepetitionFields(absoluteFrequencySelect.value);
                if (task.repetitionAbsoluteFrequency === 'weekly') {
                    (task.repetitionAbsoluteWeeklyDays || []).forEach(day => {
                        const cb = taskForm.querySelector(`input[name="weekday"][value="${day}"]`);
                        if (cb) cb.checked = true;
                    });
                } else if (task.repetitionAbsoluteFrequency === 'monthly') {
                    taskForm.monthlyOption.value = task.repetitionAbsoluteMonthlyMode || 'day_number';
                    toggleMonthlyOptions(taskForm.monthlyOption.value);
                    if (task.repetitionAbsoluteMonthlyMode === 'day_of_week') {
                        (task.repetitionAbsoluteNthWeekdayOccurrence || []).forEach(occ => { const cb = taskForm.querySelector(`input[name="monthlyOccurrence"][value="${occ}"]`); if (cb) cb.checked = true; });
                        (task.repetitionAbsoluteNthWeekdayDays || []).forEach(day => { const cb = taskForm.querySelector(`input[name="monthlyWeekday"][value="${day}"]`); if (cb) cb.checked = true; });
                    } else {
                        (task.repetitionAbsoluteDaysOfMonth || []).forEach(day => { const cb = taskForm.querySelector(`input[name="monthlyDay"][value="${day}"]`); if (cb) cb.checked = true; });
                    }
                } else if (task.repetitionAbsoluteFrequency === 'yearly') {
                    (task.repetitionAbsoluteYearlyMonths || []).forEach(month => { const cb = taskForm.querySelector(`input[name="yearlyMonth"][value="${month}"]`); if (cb) cb.checked = true; });
                    taskForm.yearlyOption.value = task.repetitionAbsoluteYearlyMode || 'day_number';
                    toggleYearlyOptions(taskForm.yearlyOption.value);
                    if (task.repetitionAbsoluteYearlyMode === 'day_of_week') {
                        (task.repetitionAbsoluteNthWeekdayOccurrence || []).forEach(occ => { const cb = taskForm.querySelector(`input[name="yearlyOccurrence"][value="${occ}"]`); if (cb) cb.checked = true; });
                        (task.repetitionAbsoluteNthWeekdayDays || []).forEach(day => { const cb = taskForm.querySelector(`input[name="yearlyWeekday"][value="${day}"]`); if (cb) cb.checked = true; });
                    } else {
                        (task.repetitionAbsoluteYearlyDaysOfMonth || []).forEach(day => { const cb = taskForm.querySelector(`input[name="yearlyDay"][value="${day}"]`); if (cb) cb.checked = true; });
                    }
                }
            }
            maxMissesInput.value = task.maxMisses || '';
            trackMissesInput.checked = typeof task.trackMisses === 'boolean' ? task.trackMisses : true;
            requiresFullAttentionInput.checked = typeof task.requiresFullAttention === 'boolean' ? task.requiresFullAttention : true;
            completionTypeSelect.value = task.completionType || 'simple';
            estimatedDurationAmountInput.value = task.estimatedDurationAmount || '';
            estimatedDurationUnitSelect.value = task.estimatedDurationUnit || 'minutes';
            countTargetInput.value = task.countTarget || '';
            timeTargetAmountInput.value = task.timeTargetAmount || '';
            timeTargetUnitSelect.value = task.timeTargetUnit || 'minutes';
            taskCategorySelect.value = task.categoryId || '';

            const isComplex = (task.repetitionType && task.repetitionType !== 'none') ||
                (task.completionType && task.completionType !== 'simple') ||
                task.icon || task.categoryId ||
                (task.timeInputType && task.timeInputType === 'start') ||
                (task.dueDateType && task.dueDateType === 'relative');
            isSimpleMode = !isComplex;

        } else {
            modalTitle.textContent = 'Add New Task';
            taskIdInput.value = '';
            isSimpleMode = true; // Default to simple mode for new tasks
        }

        toggleSimpleMode(); // Set the view based on isSimpleMode

        // Ensure estimated duration requirement is set based on time input type
        if (estimatedDurationAmountInput) {
            estimatedDurationAmountInput.required = (timeInputTypeSelect.value === 'start');
        }

        toggleCompletionFields(completionTypeSelect.value);
        activateModal(taskModal);
    } catch (e) {
        console.error("Error opening modal:", e);
    }
}
function closeModal() {
    deactivateModal(taskModal);
    editingTaskId = null;
}

function toggleSimpleMode() {
    const advancedFields = document.getElementById('advanced-task-fields');
    const simpleModeToggle = document.getElementById('simple-mode-toggle');

    if (advancedFields && simpleModeToggle) {
        advancedFields.classList.toggle('hidden', isSimpleMode);
        simpleModeToggle.checked = !isSimpleMode;
    }
}

function toggleCompletionFields(type) {
    completionCountGroup.classList.toggle('hidden', type !== 'count');
    completionTimeGroup.classList.toggle('hidden', type !== 'time');
    const isTimeType = type === 'time';
    estimatedDurationGroup.classList.toggle('hidden', isTimeType);

    // If completion type is 'time', the duration is derived from the time target,
    // so the separate estimated duration input is not needed and should not be required.
    if (isTimeType) {
        if (estimatedDurationAmountInput) {
            estimatedDurationAmountInput.required = false;
        }
    } else {
        // Otherwise, the requirement depends on the time input type (due vs start)
        if (estimatedDurationAmountInput && timeInputTypeSelect) {
             estimatedDurationAmountInput.required = (timeInputTypeSelect.value === 'start');
        }
    }
}
function toggleAbsoluteRepetitionFields(frequency) {
    absoluteWeeklyOptions.classList.toggle('hidden', frequency !== 'weekly');
    absoluteMonthlyOptions.classList.toggle('hidden', frequency !== 'monthly');
    absoluteYearlyOptions.classList.toggle('hidden', frequency !== 'yearly');
    if(frequency === 'monthly') toggleMonthlyOptions(taskForm.monthlyOption.value);
    if(frequency === 'yearly') toggleYearlyOptions(taskForm.yearlyOption.value);
}
function toggleMonthlyOptions(mode) {
    monthlyDayNumberOptions.classList.toggle('hidden', mode !== 'day_number');
    monthlyDayOfWeekOptions.classList.toggle('hidden', mode !== 'day_of_week');
}
function toggleYearlyOptions(mode) {
    yearlyDayNumberOptions.classList.toggle('hidden', mode !== 'day_number');
    yearlyDayOfWeekOptions.classList.toggle('hidden', mode !== 'day_of_week');
}
function renderCategoryManager() {
    const list = document.getElementById('category-manager-list');
    if (!list) return;
    list.innerHTML = categoryManagerTemplate(categories);
}
function renderPlannerSettings() {
    if (!plannerDefaultCategorySelect) return;

    plannerDefaultCategorySelect.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = 'Planner';
    defaultOption.textContent = 'Planner (Default)';
    plannerDefaultCategorySelect.appendChild(defaultOption);

    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        plannerDefaultCategorySelect.appendChild(option);
    });

    plannerDefaultCategorySelect.value = plannerSettings.defaultCategoryId || 'Planner';
}

function renderTaskDisplaySettings() {
    const container = document.getElementById('task-card-display-options');
    if (!container) return;
    for (const key in taskDisplaySettings) {
        const checkbox = container.querySelector(`input[name="${key}"]`);
        if (checkbox) {
            checkbox.checked = taskDisplaySettings[key];
        }
    }
}

function renderAppSettings() {
    const titleInput = document.getElementById('app-title-input');
    if (titleInput) {
        titleInput.value = appSettings.title;
    }
    const timeFormatToggle = document.getElementById('time-format-toggle');
    if (timeFormatToggle) {
        timeFormatToggle.checked = appSettings.use24HourFormat;
    }
}

function openAdvancedOptionsModal() {
    renderCategoryManager();
    renderCategoryFilters();
    renderNotificationManager();
    renderThemeControls();
    renderStatusManager();
    renderPlannerSettings();
    renderTaskDisplaySettings();
    renderAppSettings();
    activateModal(advancedOptionsModal);
}

function openTaskView(taskId, occurrenceDate) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) {
        console.error("Task not found for view:", taskId);
        return;
    }

    // Ensure stats content is hidden and view content is visible initially
    taskViewContent.innerHTML = taskViewTemplate(task, { categories, appSettings });
    taskViewContent.classList.remove('hidden');
    taskStatsContent.classList.add('hidden');
    taskStatsContent.innerHTML = ''; // Clear old stats

    // Add event listeners for the buttons inside the view
    const viewStatsBtn = taskViewContent.querySelector('[data-action="viewTaskStats"]');
    const editTaskBtn = taskViewContent.querySelector('[data-action="editTaskFromView"]');

    if (viewStatsBtn) {
        viewStatsBtn.addEventListener('click', () => renderTaskStats(taskId), { once: true });
    }
    if (editTaskBtn) {
        editTaskBtn.addEventListener('click', () => {
            deactivateModal(taskViewModal);
            openModal(taskId, { occurrenceDate });
        });
    }


    activateModal(taskViewModal);
}

function renderTaskStats(taskId) {
    const task = tasks.find(t => t.id === taskId);
    const history = appState.historicalTasks.filter(ht => ht.originalTaskId === taskId).sort((a, b) => new Date(b.completionDate) - new Date(a.completionDate));

    if (!task) return;

    taskViewContent.classList.add('hidden');
    taskStatsContent.classList.remove('hidden');

    const completions = history.filter(h => h.status === 'completed').length;
    const misses = history.filter(h => h.status === 'missed').length;
    const total = completions + misses;
    const stats = {
        completions,
        misses,
        total,
        completionRate: total > 0 ? ((completions / total) * 100).toFixed(1) : 'N/A'
    };

    const historyHtml = history.length > 0
        ? history.map(h => `<li>${new Date(h.completionDate).toLocaleDateString()}: <span class="${h.status === 'completed' ? 'text-green-600' : 'text-red-600'} font-semibold">${h.status}</span></li>`).join('')
        : '<li>No history yet.</li>';

    const chartData = processTaskHistoryForChart(history);
    const hasChartData = chartData.labels.length > 0;

    taskStatsContent.innerHTML = taskStatsTemplate(task, stats, historyHtml, hasChartData);

    if (hasChartData) {
        const ctx = document.getElementById('task-history-chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: chartData.labels,
                datasets: [
                    {
                        label: 'Completions',
                        data: chartData.completions,
                        backgroundColor: 'rgba(34, 197, 94, 0.2)', // green-500 with lower opacity
                        borderColor: 'rgba(22, 163, 74, 1)', // green-600
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    },
                    {
                        label: 'Misses',
                        data: chartData.misses,
                        backgroundColor: 'rgba(220, 38, 38, 0.2)', // red-600 with lower opacity
                        borderColor: 'rgba(185, 28, 28, 1)', // red-700
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }
                ]
            },
            options: {
                scales: {
                    x: {
                        title: { display: true, text: 'Week Of' }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Count' },
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                responsive: true,
                maintainAspectRatio: false
            }
        });
    }


    const backBtn = taskStatsContent.querySelector('[data-action="backToTaskView"]');
    if (backBtn) {
        backBtn.addEventListener('click', () => {
            taskStatsContent.innerHTML = ''; // Clear content to destroy chart instance
            taskStatsContent.classList.add('hidden');
            taskViewContent.classList.remove('hidden');
        }, { once: true });
    }
}
function renderCategoryFilters() {
    if (!categoryFilterList) return;
    categoryFilterList.innerHTML = categoryFilterTemplate(categories, categoryFilter);
}

function renderStatusManager() {
    const manager = document.getElementById('status-color-manager');
    if (!manager) return;
    manager.innerHTML = statusManagerTemplate(statusNames, statusColors, defaultStatusNames);
}

function renderNotificationManager() {
    const container = document.getElementById('notification-manager-content');
    if (!container) return;

    // Ensure all categories have a setting. Default to true.
    categories.forEach(cat => {
        if (notificationSettings.categories[cat.id] === undefined) {
            notificationSettings.categories[cat.id] = true;
        }
    });

    container.innerHTML = notificationManagerTemplate(notificationSettings, categories);
}

function renderThemeControls() {
    const themeModeSelector = document.getElementById('theme-mode-selector');
    if (themeModeSelector) {
        themeModeSelector.querySelectorAll('.theme-mode-btn').forEach(btn => {
            btn.classList.remove('active-theme-btn');
            if (btn.dataset.mode === theming.mode) {
                btn.classList.add('active-theme-btn');
            }
        });
    }

    const themeToggle = document.getElementById('theme-enabled-toggle');
    const themeControls = document.getElementById('theme-controls');
    const themeColorPicker = document.getElementById('theme-base-color');

    if (themeToggle) themeToggle.checked = theming.enabled;
    if (themeColorPicker) themeColorPicker.value = theming.baseColor;
    if (themeControls) themeControls.classList.toggle('hidden', !theming.enabled);
}

function renderIconPicker() {
    const content = document.getElementById('icon-picker-content');
    if (!content) return;
    content.innerHTML = iconPickerTemplate(iconCategories);
}

function openIconPicker() {
    renderIconPicker();
    activateModal(iconPickerModal);
}


// =================================================================================
// SECTION 4: User Action Handlers
// =================================================================================

function startTimerInterval(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || !task.isTimerRunning || task.completionType !== 'time') return;

    stopTaskTimer(taskId);

    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
    const progressBeforeStart = (task.currentProgress || 0);
    const timerLastStartedTimestamp = (task.timerLastStarted ? new Date(task.timerLastStarted).getTime() : Date.now());


    taskTimers[taskId] = setInterval(() => {
        const currentTask = tasks.find(t => t.id === taskId);
        if (!currentTask || !currentTask.isTimerRunning) {
            stopTaskTimer(taskId);
            return;
        }

        const elapsedSinceStart = Date.now() - timerLastStartedTimestamp;
        const totalCurrentProgress = progressBeforeStart + elapsedSinceStart;

        const progressElement = document.getElementById(`progress-${taskId}`);
        if (progressElement) {
            progressElement.textContent = `${formatMsToTime(Math.min(totalCurrentProgress, targetMs))} / ${formatMsToTime(targetMs)}`;
        }

        if (totalCurrentProgress >= targetMs) {
            toggleTimer(taskId);
        }
    }, 1000);
}

function handleFormSubmit(event) {
    event.preventDefault();
    try {
        const now = new Date();

        const taskData = {
            name: taskNameInput.value.trim(),
            icon: taskIconInput.value.trim(),
            timeInputType: timeInputTypeSelect.value,
            dueDateType: dueDateTypeSelect.value,
            dueDate: null,
            repetitionType: taskRepetitionSelect.value,
            maxMisses: null,
            trackMisses: true,
            requiresFullAttention: requiresFullAttentionInput.checked,
            completionType: completionTypeSelect.value,
            currentProgress: 0,
            isTimerRunning: false,
            confirmationState: null,
            overdueStartDate: null,
            pendingCycles: null,
            categoryId: null
        };

        if (taskData.dueDateType === 'absolute') {
            if (taskData.timeInputType === 'start') {
                const startDate = taskStartDateInput.value ? new Date(taskStartDateInput.value) : null;
                if (startDate) {
                    const durationMs = getDurationMs(estimatedDurationAmountInput.value, estimatedDurationUnitSelect.value);
                    taskData.dueDate = new Date(startDate.getTime() + durationMs);
                }
            } else {
                taskData.dueDate = taskDueDateInput.value ? new Date(taskDueDateInput.value) : null;
            }
        } else if (taskData.dueDateType === 'relative') {
            const amount = parseInt(relativeAmountInput.value, 10);
            const unit = relativeUnitSelect.value;
            taskData.dueDate = calculateFutureDate(amount, unit, now);
            taskData.relativeAmount = amount;
            taskData.relativeUnit = unit;
        }

        if (taskData.repetitionType === 'relative') {
            taskData.repetitionAmount = parseInt(repetitionAmountInput.value, 10);
            taskData.repetitionUnit = repetitionUnitSelect.value;
            taskData.maxMisses = maxMissesInput.value ? parseInt(maxMissesInput.value, 10) : null;
            taskData.trackMisses = trackMissesInput.checked;
        } else if (taskData.repetitionType === 'absolute') {
            taskData.repetitionAbsoluteFrequency = absoluteFrequencySelect.value;
            if (taskData.repetitionAbsoluteFrequency === 'weekly') {
                taskData.repetitionAbsoluteWeeklyDays = Array.from(weekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
            } else if (taskData.repetitionAbsoluteFrequency === 'monthly') {
                taskData.repetitionAbsoluteMonthlyMode = taskForm.monthlyOption.value;
                if (taskData.repetitionAbsoluteMonthlyMode === 'day_of_week') {
                    taskData.repetitionAbsoluteNthWeekdayOccurrence = Array.from(monthlyOccurrenceCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                    taskData.repetitionAbsoluteNthWeekdayDays = Array.from(monthlyWeekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
                } else {
                    taskData.repetitionAbsoluteDaysOfMonth = Array.from(monthlyDayCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                }
            } else if (taskData.repetitionAbsoluteFrequency === 'yearly') {
                taskData.repetitionAbsoluteYearlyMonths = Array.from(yearlyMonthCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
                taskData.repetitionAbsoluteYearlyMode = taskForm.yearlyOption.value;
                if (taskData.repetitionAbsoluteYearlyMode === 'day_of_week') {
                    taskData.repetitionAbsoluteNthWeekdayOccurrence = Array.from(yearlyOccurrenceCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                    taskData.repetitionAbsoluteNthWeekdayDays = Array.from(yearlyWeekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
                } else {
                    taskData.repetitionAbsoluteYearlyDaysOfMonth = Array.from(yearlyDayCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                }
            }
            taskData.maxMisses = maxMissesInput.value ? parseInt(maxMissesInput.value, 10) : null;
            taskData.trackMisses = trackMissesInput.checked;
        }
        const categoryValue = taskCategorySelect.value;
        if (categoryValue === 'new_category') {
            const newCategoryName = newCategoryNameInput.value.trim();
            if (newCategoryName && !categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
                const newCategory = {
                    id: newCategoryName,
                    name: newCategoryName,
                    color: getRandomColor()
                };
                categories.push(newCategory);
                taskData.categoryId = newCategory.id;
            } else if (newCategoryName) {
                taskData.categoryId = categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase()).id;
            }
        } else if (categoryValue) {
            taskData.categoryId = categoryValue;
        }
        if (taskData.completionType === 'count') {
            taskData.countTarget = countTargetInput.value ? parseInt(countTargetInput.value, 10) : null;
            taskData.estimatedDurationAmount = estimatedDurationAmountInput.value ? parseInt(estimatedDurationAmountInput.value, 10) : null;
            taskData.estimatedDurationUnit = estimatedDurationUnitSelect.value;
        } else if (taskData.completionType === 'time') {
            taskData.timeTargetAmount = timeTargetAmountInput.value ? parseInt(timeTargetAmountInput.value, 10) : null;
            taskData.timeTargetUnit = timeTargetUnitSelect.value;
            taskData.estimatedDurationAmount = taskData.timeTargetAmount;
            taskData.estimatedDurationUnit = taskData.timeTargetUnit;
        } else {
            taskData.estimatedDurationAmount = estimatedDurationAmountInput.value ? parseInt(estimatedDurationAmountInput.value, 10) : null;
            taskData.estimatedDurationUnit = estimatedDurationUnitSelect.value;
        }
        if (editingTaskId) {
            const taskIndex = tasks.findIndex(t => t.id === editingTaskId);
            if (taskIndex > -1) {
                const originalTask = tasks[taskIndex];
                const mergedTask = { ...originalTask, ...taskData };
                let updatedTask = sanitizeAndUpgradeTask(mergedTask);
                if (originalTask.repetitionType !== 'none' && updatedTask.repetitionType !== 'none') {
                    updatedTask.misses = originalTask.misses;
                } else {
                    updatedTask.misses = 0;
                }
                if (originalTask.completionType === updatedTask.completionType) {
                    updatedTask.currentProgress = originalTask.currentProgress;
                } else {
                    updatedTask.currentProgress = 0;
                }
                const otherTasks = tasks.filter(t => t.id !== editingTaskId);
                const newStatus = calculateStatus(updatedTask, now.getTime(), otherTasks);
                updatedTask.status = (originalTask.status === 'blue' && originalTask.cycleEndDate?.getTime() > now.getTime()) ? 'blue' : newStatus.name;
                tasks[taskIndex] = updatedTask;
            }
        } else {
            taskData.id = generateId();
            taskData.createdAt = now;
            taskData.misses = 0;
            taskData.completed = false;
            taskData.status = 'green';
            const newTask = sanitizeAndUpgradeTask(taskData);
            const otherTasks = [...tasks];
            newTask.status = calculateStatus(newTask, now.getTime(), otherTasks).name;
            tasks.push(newTask);
        }
        saveData();
        updateAllTaskStatuses(true);
        if (calendar) calendar.refetchEvents();
        closeModal();
    } catch (e) {
        console.error("Error handling form submit:", e);
    }
}
function editTask(taskId) { openModal(taskId); }
function triggerDelete(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (task) {
        task.confirmationState = 'confirming_delete';
        saveData();
        renderTasks();
    }
}
function triggerUndoConfirmation(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (task && task.status === 'blue' && task.repetitionType !== 'none') {
        task.confirmationState = 'confirming_undo';
        saveData();
        renderTasks();
    }
}
function confirmDeleteAction(taskId, confirmed) {
    if (confirmed) {
        stopAllTimers();
        tasks = tasks.filter(t => t.id !== taskId);
        saveData();
        renderTasks();
        if (calendar) calendar.refetchEvents();
    } else {
        const task = tasks.find(t => t.id === taskId);
        if (task) {
            task.confirmationState = null;
            saveData();
            renderTasks();
        }
    }
}
function triggerCompletion(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    if (task.isTimerRunning) toggleTimer(taskId);
    task.confirmationState = 'confirming_complete';
    const nowMs = Date.now();
    if (task.dueDate && nowMs >= task.dueDate.getTime()) {
        if (!task.overdueStartDate) task.overdueStartDate = task.dueDate.toISOString();
        task.pendingCycles = calculatePendingCycles(task, nowMs);
    } else {
        task.pendingCycles = 1;
        delete task.overdueStartDate;
    }
    saveData();
    renderTasks();
}
function confirmCompletionAction(taskId, confirmed) {
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    if (taskIndex === -1) return;

    let task = tasks[taskIndex];
    const cyclesToComplete = task.pendingCycles || 1;
    const wasOverdue = !!task.overdueStartDate;
    const baseDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate || new Date());

    if (confirmed) {
        stopTaskTimer(taskId);

        if (task.repetitionType !== 'none') {
            // Logic for repeating tasks
            const historicalTask = {
                originalTaskId: task.id, name: task.name, completionDate: baseDate, status: 'completed',
                categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
            };
            appState.historicalTasks.push(historicalTask);

            const missesBefore = task.misses || 0;
            task.misses = Math.max(0, missesBefore - cyclesToComplete);
            let missCountReduced = task.misses < missesBefore;

            let nextDueDate = null;
            if (task.repetitionType === 'relative') {
                let current = new Date(baseDate);
                for (let i = 0; i < cyclesToComplete; i++) current = calculateFutureDate(task.repetitionAmount, task.repetitionUnit, current);
                nextDueDate = current;
            } else { // absolute
                const futureOccurrences = generateAbsoluteOccurrences(task, new Date(baseDate.getTime() + 1), new Date(baseDate.getFullYear() + 5, 0, 1));
                if (futureOccurrences.length >= cyclesToComplete) nextDueDate = futureOccurrences[cyclesToComplete - 1];
            }

            if (nextDueDate) {
                task.dueDate = nextDueDate;
                task.status = wasOverdue ? calculateStatus(task, Date.now(), tasks).name : 'blue';
                task.cycleEndDate = wasOverdue ? null : baseDate;
                task.completionReducedMisses = missCountReduced;
            } else {
                task.status = calculateStatus(task, Date.now(), tasks).name;
                delete task.completionReducedMisses;
            }
            task.currentProgress = 0;
            task.completed = false;
            task.confirmationState = null;
            delete task.pendingCycles;
            delete task.overdueStartDate;
            saveData();
            updateAllTaskStatuses(true);

        } else { // Logic for non-repeating tasks
            const historicalTask = {
                originalTaskId: task.id, name: task.name, completionDate: new Date(), status: 'completed',
                categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
            };
            appState.historicalTasks.push(historicalTask);
            tasks = tasks.filter(t => t.id !== taskId);
            saveData();
            updateAllTaskStatuses(true);
            return;
        }
    } else { // User clicked "No"
        if (wasOverdue) {
            task.confirmationState = 'awaiting_overdue_input';
        } else {
            task.confirmationState = null;
            const target = (task.completionType === 'count') ? task.countTarget : getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
            if (target && task.currentProgress >= target) {
                task.currentProgress = target - (task.completionType === 'time' ? 1000 : 1);
            }
        }
        delete task.pendingCycles;
        delete task.overdueStartDate;
        // Do not nullify confirmationState here if it was just set
        if (task.confirmationState !== 'awaiting_overdue_input') {
            task.confirmationState = null;
        }
        saveData();
        updateAllTaskStatuses(true);
    }
}
function confirmUndoAction(taskId, confirmed) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    if (confirmed) {
        if (task.status !== 'blue' || task.repetitionType === 'none') return;

        // Find and remove the last completed instance from history
        const lastCompletedIndex = appState.historicalTasks.map(t => t.originalTaskId).lastIndexOf(taskId);
        if (lastCompletedIndex > -1 && appState.historicalTasks[lastCompletedIndex].status === 'completed') {
            appState.historicalTasks.splice(lastCompletedIndex, 1);
        }

        task.dueDate = task.cycleEndDate ? new Date(task.cycleEndDate) : new Date();
        task.cycleEndDate = null;
        if (task.completionReducedMisses && task.trackMisses && task.maxMisses > 0) {
            task.misses = Math.min(task.maxMisses, (task.misses || 0) + 1);
        }
        delete task.completionReducedMisses;
    }
    task.confirmationState = null;
    saveData();
    updateAllTaskStatuses(true);
}
function confirmMissAction(taskId, confirmed) {
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    if (taskIndex === -1) return;
    let task = tasks[taskIndex];

    if (confirmed) {
        const totalCycles = task.pendingCycles || 1;
        const inputEl = document.getElementById(`miss-count-input-${taskId}`);
        const missesToApply = (inputEl && totalCycles > 1) ? parseInt(inputEl.value, 10) : totalCycles;
        const completionsToApply = totalCycles - missesToApply;
        const baseDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate || new Date());

        if (task.repetitionType !== 'none') {
            // Logic for repeating tasks
            if (missesToApply > 0) {
                const historicalTask = {
                    originalTaskId: task.id, name: task.name, completionDate: baseDate, status: 'missed',
                    categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
                };
                appState.historicalTasks.push(historicalTask);
            }

            if (completionsToApply > 0) task.misses = Math.max(0, (task.misses || 0) - completionsToApply);
            if (missesToApply > 0 && task.trackMisses) {
                let missesToAdd = missesToApply; // Default to full misses
                // Only apply partial miss logic to the first cycle being missed
                if (missesToApply > 0 && (task.completionType === 'count' || task.completionType === 'time')) {
                    let progress = 0;
                    if (task.completionType === 'count' && task.countTarget > 0) {
                        progress = (task.currentProgress || 0) / task.countTarget;
                    } else if (task.completionType === 'time') {
                        const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
                        if (targetMs > 0) {
                            progress = (task.currentProgress || 0) / targetMs;
                        }
                    }
                    // This logic correctly handles bulk misses with partial completion.
                    // It calculates the partial miss value (0.0 to 1.0) for the *first* overdue cycle based on its progress.
                    // For any additional cycles being missed at the same time (missesToApply - 1), it adds them as full integer misses.
                    // This prevents multiple partial misses from being summed up in a single action.
                    const partialMiss = 1 - Math.min(1, progress);
                    missesToAdd = (missesToApply - 1) + partialMiss;
                }

                if(missesToAdd > 0) {
                    task.misses = Math.min(task.maxMisses || Infinity, (task.misses || 0) + missesToAdd);
                }
            }

            let nextDueDate = null;
            if (task.repetitionType === 'relative') {
                let current = new Date(baseDate);
                for (let i = 0; i < totalCycles; i++) current = calculateFutureDate(task.repetitionAmount, task.repetitionUnit, current);
                nextDueDate = current;
            } else { // absolute
                const futureOccurrences = generateAbsoluteOccurrences(task, new Date(baseDate.getTime() + 1), new Date(baseDate.getFullYear() + 5, 0, 1));
                if (futureOccurrences.length >= totalCycles) nextDueDate = futureOccurrences[totalCycles - 1];
            }
            task.dueDate = nextDueDate;
            task.cycleEndDate = null;
            task.currentProgress = 0;
            task.confirmationState = null;
            delete task.pendingCycles;
            delete task.overdueStartDate;
        } else { // Logic for non-repeating tasks
            const historicalTask = {
                originalTaskId: task.id, name: task.name, completionDate: new Date(), status: 'missed',
                categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
            };
            appState.historicalTasks.push(historicalTask);
            tasks = tasks.filter(t => t.id !== taskId);
            // Save and render immediately, then exit function.
            saveData();
            updateAllTaskStatuses(true);
            return;
        }
    } else {
        task.confirmationState = 'awaiting_overdue_input';
        delete task.pendingCycles;
        delete task.overdueStartDate;
    }

    task.confirmationState = null;
    saveData();
    updateAllTaskStatuses(true);
}
function handleOverdueChoice(taskId, choice) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    if (!task.overdueStartDate) task.overdueStartDate = task.dueDate ? task.dueDate.toISOString() : null;
    task.pendingCycles = calculatePendingCycles(task, Date.now());
    task.confirmationState = (choice === 'completed') ? 'confirming_complete' : 'confirming_miss';
    saveData();
    renderTasks();
}
function incrementCount(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.completionType !== 'count' || !task.countTarget) return;
    task.currentProgress = (task.currentProgress || 0) + 1;
    if (task.currentProgress >= task.countTarget) {
        task.currentProgress = task.countTarget;
        triggerCompletion(taskId);
    } else {
        saveData();
        renderTasks();
    }
}
function decrementCount(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.completionType !== 'count') return;
    task.currentProgress = Math.max(0, (task.currentProgress || 0) - 1);
    saveData();
    renderTasks();
}
function toggleTimer(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.completionType !== 'time') return;
    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);

    if (task.isTimerRunning) {
        const elapsed = Date.now() - (new Date(task.timerLastStarted).getTime() || Date.now());
        stopTaskTimer(taskId);

        task.currentProgress = (task.currentProgress || 0) + elapsed;
        if (task.currentProgress >= targetMs) {
            task.currentProgress = targetMs;
        }
        task.isTimerRunning = false;
        task.timerLastStarted = null;

        saveData();
        renderTasks();

        if (task.currentProgress >= targetMs) {
            triggerCompletion(taskId);
        }

    } else {
        if (task.currentProgress >= targetMs) {
            triggerCompletion(taskId);
            return;
        }
        task.isTimerRunning = true;
        task.timerLastStarted = new Date().toISOString();

        startTimerInterval(taskId);

        const timerButton = document.getElementById(`timer-btn-${taskId}`);
        if (timerButton) {
            timerButton.textContent = 'Pause';
            timerButton.classList.remove('control-button-green');
            timerButton.classList.add('control-button-yellow');
        }
        saveData();
    }
}
function editProgress(taskId) {
    const task = tasks.find(t => t.id === taskId);
    const container = document.getElementById(`progress-container-${taskId}`);
    if (!task || !container) return;

    if (task.isTimerRunning) {
        toggleTimer(taskId);
    }

    let currentValue, max;
    if (task.completionType === 'count') {
        currentValue = task.currentProgress || 0;
        max = task.countTarget || Infinity;
    } else if (task.completionType === 'time') {
        currentValue = Math.round((task.currentProgress || 0) / MS_PER_MINUTE);
        max = Math.round(getDurationMs(task.timeTargetAmount, task.timeTargetUnit) / MS_PER_MINUTE);
    } else return;

    container.innerHTML = editProgressTemplate(taskId, currentValue, max);
    document.getElementById(`edit-progress-input-${taskId}`).focus();
}
function saveProgressEdit(taskId) {
    const task = tasks.find(t => t.id === taskId);
    const input = document.getElementById(`edit-progress-input-${taskId}`);
    if (!task || !input) return;
    let newValue = parseInt(input.value, 10);
    if (isNaN(newValue)) { renderTasks(); return; }
    if (task.completionType === 'count') {
        const target = task.countTarget || Infinity;
        task.currentProgress = Math.max(0, Math.min(newValue, target));
        if (task.currentProgress >= target) { triggerCompletion(taskId); }
    } else if (task.completionType === 'time') {
        const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
        task.currentProgress = Math.max(0, Math.min(parseMinutesToMs(newValue), targetMs));
        if (task.currentProgress >= targetMs) { triggerCompletion(taskId); }
    }
    saveData();
    renderTasks();
}
function cancelProgressEdit(taskId) { renderTasks(); }
function deleteCategory(categoryId) {
    // Filter out tasks that belong to the category being deleted
    tasks = tasks.filter(task => task.categoryId !== categoryId);
    // Filter out the category itself
    categories = categories.filter(cat => cat.id !== categoryId);
    saveData();
    renderCategoryManager();
    renderTasks();
    if (calendar) calendar.refetchEvents();
}
function addCategoryFromManager() {
    const newCategoryName = prompt("Enter new category name:");
    if (newCategoryName && !categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
        const newCategory = {
            id: newCategoryName,
            name: newCategoryName,
            color: getRandomColor()
        };
        categories.push(newCategory);
        saveData();
        renderCategoryManager();
        renderCategoryFilters();
    } else if (newCategoryName) {
        alert("A category with that name already exists.");
    }
}

function triggerCategoryEdit(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    if (!category) return;

    renderCategoryManager();

    const displayDiv = document.getElementById(`category-display-${categoryId}`);
    if (!displayDiv) return;

    displayDiv.innerHTML = editCategoryTemplate(categoryId, category.name);
    document.getElementById(`edit-category-input-${categoryId}`).focus();
}

function saveCategoryEdit(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    const input = document.getElementById(`edit-category-input-${categoryId}`);
    if (!category || !input) return;

    const newName = input.value.trim();
    if (newName && newName !== '' && !categories.find(c => c.name.toLowerCase() === newName.toLowerCase() && c.id !== categoryId)) {
        const oldId = category.id;
        category.name = newName;
        category.id = newName;
        tasks.forEach(task => {
            if (task.categoryId === oldId) {
                task.categoryId = category.id;
            }
        });
        saveData();
        renderCategoryManager();
        renderTasks();
        renderCategoryFilters();
    } else if (newName) {
        alert("A category with that name already exists or the name is invalid.");
        renderCategoryManager();
    }
}

function deleteCategoryTasks(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    if (!category) return;

    const tasksToDelete = tasks.filter(task => task.categoryId === categoryId);

    if (tasksToDelete.length === 0) {
        alert(`There are no tasks in the "${category.name}" category to delete.`);
        return;
    }

    if (confirm(`Are you sure you want to delete all ${tasksToDelete.length} task(s) in the "${category.name}" category? This action cannot be undone.`)) {
        const idsToDelete = tasksToDelete.map(t => t.id);
        tasks = tasks.filter(task => !idsToDelete.includes(task.id));
        saveData();
        renderTasks();
        if (calendar) calendar.refetchEvents();
        alert('All tasks in the category have been deleted.');
    }
}

function cancelCategoryEdit(categoryId) {
    renderCategoryManager();
}

function triggerStatusNameEdit(statusKey) {
    const status = statusNames[statusKey];
    if (status === undefined) return;
    renderStatusManager();
    const displayDiv = document.getElementById(`status-display-${statusKey}`);
    if (!displayDiv) return;
    displayDiv.innerHTML = editStatusNameTemplate(statusKey, status);
    document.getElementById(`edit-status-input-${statusKey}`).focus();
}

function saveStatusNameEdit(statusKey) {
    const input = document.getElementById(`edit-status-input-${statusKey}`);
    if (!input) return;
    const newName = input.value.trim();
    if (newName && newName !== '') {
        statusNames[statusKey] = newName;
        saveData();
        renderStatusManager();
        renderTasks();
    } else {
        alert("Status name cannot be empty.");
        renderStatusManager();
    }
}

function cancelStatusNameEdit(statusKey) {
    renderStatusManager();
}

function handleBulkEditSubmit(categoryId, form) {
    const formData = new FormData(form);
    const updates = {};
    const durationAmount = formData.get('durationAmount');
    if (durationAmount) {
        updates.estimatedDurationAmount = parseInt(durationAmount, 10);
        updates.estimatedDurationUnit = formData.get('durationUnit');
    }
    const completionType = formData.get('completionType');
    if (completionType) {
        updates.completionType = completionType;
    }

    if (Object.keys(updates).length === 0) {
        alert("No changes specified. Please fill out at least one field to apply changes.");
        return;
    }

    let updatedCount = 0;
    tasks.forEach(task => {
        if (task.categoryId === categoryId) {
            Object.assign(task, updates);
            updatedCount++;
        }
    });

    // Save the settings for next time
    lastBulkEditSettings = {
        durationAmount: formData.get('durationAmount'),
        durationUnit: formData.get('durationUnit'),
        completionType: formData.get('completionType'),
    };

    saveData();
    updateAllTaskStatuses(true);
    if (calendar) calendar.refetchEvents();

    alert(`${updatedCount} task(s) in the category have been updated.`);
    const container = document.getElementById(`bulk-edit-container-${categoryId}`);
    if(container) {
        container.innerHTML = '';
        container.classList.add('hidden');
    }
}


function triggerRestoreDefaults() {
    const container = document.getElementById('restore-defaults-container');
    if (container) {
        container.innerHTML = restoreDefaultsConfirmationTemplate();
    }
}

function confirmRestoreDefaultsAction(confirmed) {
    const container = document.getElementById('restore-defaults-container');
    if (confirmed) {
        statusColors = { ...defaultStatusColors };
        statusNames = { ...defaultStatusNames };
        sortBy = 'status';
        sortDirection = 'asc';
        theming.enabled = false;

        saveData();
        sortBySelect.value = sortBy;
        sortDirectionSelect.value = sortDirection;
        applyTheme();
        openAdvancedOptionsModal();
    }

    if (container) {
        container.innerHTML = `<button data-action="restoreDefaults" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Restore All Defaults</button>`;
    }
}

// --- Data Migration Tool Functions ---
function openDataMigrationModal() {
    if (!dataMigrationModal) return;
    dataMigrationModal.innerHTML = dataMigrationModalTemplate();
    activateModal(dataMigrationModal);

    // Add event listeners for the new modal
    const closeButton = dataMigrationModal.querySelector('.close-button');
    if (closeButton) {
        closeButton.addEventListener('click', () => deactivateModal(dataMigrationModal));
    }
    const fileInput = document.getElementById('migration-file-input');
    if (fileInput) {
        fileInput.addEventListener('change', handleMigrationFileSelect);
    }
    const cancelBtn = document.getElementById('cancel-migration-btn');
    if(cancelBtn) {
        cancelBtn.addEventListener('click', () => deactivateModal(dataMigrationModal));
    }
    const runBtn = document.getElementById('run-migration-btn');
    if(runBtn) {
        runBtn.addEventListener('click', runMigration);
    }
}

function handleMigrationFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // Assuming the old data is an array of task-like objects
            if (!Array.isArray(data) || data.length === 0) {
                alert('Error: The selected file does not contain a valid array of tasks.');
                return;
            }
            oldTasksData = data; // Store the raw data
            const oldTaskFields = Object.keys(data[0]);
            const newTaskFields = Object.keys(sanitizeAndUpgradeTask({id: 'test'}));

            const mappingArea = document.getElementById('migration-mapping-area');
            mappingArea.innerHTML = ''; // Clear previous mappings

            oldTaskFields.forEach(oldField => {
                const row = document.createElement('div');
                row.className = 'grid grid-cols-2 gap-4 items-center';
                row.innerHTML = `<label class="text-right font-medium">${oldField}:</label>`;

                const select = document.createElement('select');
                select.className = 'w-full p-1 border rounded';
                select.dataset.oldField = oldField;

                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Ignore this field --';
                select.appendChild(defaultOption);

                newTaskFields.forEach(newField => {
                    const option = document.createElement('option');
                    option.value = newField;
                    option.textContent = newField;
                    // Simple auto-mapping
                    if (oldField.toLowerCase() === newField.toLowerCase()) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
                row.appendChild(select);
                mappingArea.appendChild(row);
            });

            document.getElementById('migration-step-1').classList.add('hidden');
            document.getElementById('migration-step-2').classList.remove('hidden');

        } catch (error) {
            alert('Error parsing JSON file. Please ensure it is a valid JSON file containing an array of tasks.');
            console.error("Migration file parse error:", error);
        }
    };
    reader.readAsText(file);
}

function runMigration() {
    if (oldTasksData.length === 0) {
        alert("No data to migrate.");
        return;
    }

    const mappingSelectors = document.querySelectorAll('#migration-mapping-area select');
    const fieldMapping = {};
    mappingSelectors.forEach(select => {
        if (select.value) {
            fieldMapping[select.dataset.oldField] = select.value;
        }
    });

    const newTasks = oldTasksData.map(oldTask => {
        let newTask = { id: generateId(), createdAt: new Date() };
        for (const oldField in fieldMapping) {
            const newField = fieldMapping[oldField];
            if (oldTask.hasOwnProperty(oldField)) {
                // Basic type coercion for dates
                if (newField.toLowerCase().includes('date') && typeof oldTask[oldField] === 'string') {
                    const parsedDate = new Date(oldTask[oldField]);
                    if (!isNaN(parsedDate)) {
                        newTask[newField] = parsedDate;
                    }
                } else {
                    newTask[newField] = oldTask[oldField];
                }
            }
        }
        return sanitizeAndUpgradeTask(newTask);
    });

    // Merge with existing tasks, avoiding duplicates by checking a property like 'name'
    const existingTaskNames = new Set(tasks.map(t => t.name));
    const tasksToAdd = newTasks.filter(nt => !existingTaskNames.has(nt.name));

    tasks.push(...tasksToAdd);
    saveData();
    updateAllTaskStatuses(true);
    if (calendar) calendar.refetchEvents();

    alert(`Migration complete! ${tasksToAdd.length} new tasks were added. The page will now reload.`);
    deactivateModal(dataMigrationModal);
    location.reload();
}


// --- Data Portability Functions ---

function exportData(exportType) {
    const dataToExport = {
        exportFormatVersion: '1.0',
        exportDate: new Date().toISOString(),
        dataType: exportType,
        data: {}
    };

    const allSettings = {
        statusColors, statusNames, sortBy, sortDirection, notificationSettings, theming,
        calendarSettings, categoryFilter, plannerSettings, taskDisplaySettings, appSettings
    };

    switch (exportType) {
        case 'all':
            dataToExport.data = {
                tasks,
                categories,
                appState,
                settings: allSettings
            };
            break;
        case 'tasks':
            const taskCategoryIds = new Set(tasks.map(t => t.categoryId).filter(id => id));
            const relevantCategories = categories.filter(c => taskCategoryIds.has(c.id));
            dataToExport.data = { tasks, categories: relevantCategories };
            break;
        case 'categories':
            dataToExport.data = { categories };
            break;
        case 'history':
            dataToExport.data = { appState: { historicalTasks: appState.historicalTasks } };
            break;
        case 'settings':
            dataToExport.data = { settings: allSettings };
            break;
        default:
            console.error("Unknown export type:", exportType);
            return;
    }

    const dataStr = JSON.stringify(dataToExport, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    link.download = `task-planner-backup-${exportType}-${timestamp}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}


function importData() {
    const fileInput = document.getElementById('import-file-input');
    fileInput.click();
}

function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importedData = JSON.parse(e.target.result);

            if (!importedData.exportFormatVersion || !importedData.dataType || !importedData.data) {
                alert('Error: Invalid or corrupted backup file.');
                return;
            }

            const importMode = prompt("Choose import mode: 'overwrite' to replace all existing data, or 'merge' to add new tasks and categories.", "merge");

            if (!importMode) {
                event.target.value = '';
                return; // User cancelled the prompt
            }

            if (importMode.toLowerCase() === 'overwrite') {
                if (!confirm('This will overwrite existing data. Are you sure you want to continue?')) {
                    event.target.value = '';
                    return;
                }
                 const importContent = importedData.data;

                if (importedData.dataType === 'all') {
                    if(importContent.tasks) localStorage.setItem('tasks', JSON.stringify(importContent.tasks));
                    if(importContent.categories) localStorage.setItem('categories', JSON.stringify(importContent.categories));
                    if(importContent.appState) localStorage.setItem(DATA_KEY, JSON.stringify(importContent.appState));
                    if(importContent.settings) {
                        Object.keys(importContent.settings).forEach(key => {
                            localStorage.setItem(key, JSON.stringify(importContent.settings[key]));
                        });
                    }
                } else if (importedData.dataType === 'tasks' && importContent.tasks) {
                    let existingCategories = JSON.parse(localStorage.getItem('categories') || '[]');
                    if (importContent.categories && Array.isArray(importContent.categories)) {
                        importContent.categories.forEach(importedCat => {
                            const existingIndex = existingCategories.findIndex(c => c.id === importedCat.id);
                            if (existingIndex > -1) {
                                existingCategories[existingIndex] = importedCat;
                            } else {
                                existingCategories.push(importedCat);
                            }
                        });
                    }
                    localStorage.setItem('categories', JSON.stringify(existingCategories));
                    localStorage.setItem('tasks', JSON.stringify(importContent.tasks));
                } else if (importedData.dataType === 'categories' && importContent.categories) {
                     localStorage.setItem('categories', JSON.stringify(importContent.categories));
                } else if (importedData.dataType === 'history' && importContent.appState) {
                    const existingPlannerData = JSON.parse(localStorage.getItem(DATA_KEY)) || {};
                    existingPlannerData.historicalTasks = importContent.appState.historicalTasks;
                    localStorage.setItem(DATA_KEY, JSON.stringify(existingPlannerData));
                } else if (importedData.dataType === 'settings' && importContent.settings) {
                     Object.keys(importContent.settings).forEach(key => {
                        localStorage.setItem(key, JSON.stringify(importContent.settings[key]));
                    });
                } else {
                    alert('Error: The data type in the file is not recognized or data is missing.');
                    return;
                }
            } else if (importMode.toLowerCase() === 'merge') {
                const importContent = importedData.data;

                const merge = (existing, incoming, idKey) => {
                    const existingIds = new Set(existing.map(item => item[idKey]));
                    incoming.forEach(item => {
                        if (!existingIds.has(item[idKey])) {
                            existing.push(item);
                        }
                    });
                    return existing;
                };

                if (importedData.dataType === 'all') {
                    if (importContent.tasks) {
                        let existingTasks = JSON.parse(localStorage.getItem('tasks') || '[]');
                        localStorage.setItem('tasks', JSON.stringify(merge(existingTasks, importContent.tasks, 'id')));
                    }
                    if (importContent.categories) {
                        let existingCategories = JSON.parse(localStorage.getItem('categories') || '[]');
                        localStorage.setItem('categories', JSON.stringify(merge(existingCategories, importContent.categories, 'id')));
                    }
                } else if (importedData.dataType === 'tasks' && importContent.tasks) {
                     if (importContent.categories) {
                        let existingCategories = JSON.parse(localStorage.getItem('categories') || '[]');
                        localStorage.setItem('categories', JSON.stringify(merge(existingCategories, importContent.categories, 'id')));
                    }
                    let existingTasks = JSON.parse(localStorage.getItem('tasks') || '[]');
                    localStorage.setItem('tasks', JSON.stringify(merge(existingTasks, importContent.tasks, 'id')));
                } else if (importedData.dataType === 'categories' && importContent.categories) {
                    let existingCategories = JSON.parse(localStorage.getItem('categories') || '[]');
                    localStorage.setItem('categories', JSON.stringify(merge(existingCategories, importContent.categories, 'id')));
                }

                alert('Merge successful! The application will now reload.');
                location.reload();

            } else {
                alert("Invalid import mode. Please choose 'overwrite' or 'merge'.");
                event.target.value = '';
                return;
            }

        } catch (error) {
            console.error('Error importing data:', error);
            alert('Error: Could not parse the file. Please ensure it is a valid JSON backup file.');
        } finally {
            // Reset the file input so the user can import the same file again if needed
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

// --- Notification Handlers ---

function handleMasterNotificationToggle(event) {
    const isEnabled = event.target.checked;

    const updateState = (enabled) => {
        notificationSettings.enabled = enabled;
        event.target.checked = enabled;
        event.target.classList.toggle('bg-green-500', enabled);
        document.getElementById('notification-details').classList.toggle('hidden', !enabled);
        saveData();
    };

    if (isEnabled) {
        if (Notification.permission === 'granted') {
            updateState(true);
        } else if (Notification.permission === 'denied') {
            alert("Notifications are blocked by your browser. Please update your site settings to allow them.");
            updateState(false);
        } else {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    updateState(true);
                    new Notification("Task Manager", { body: "Notifications have been enabled!" });
                } else {
                    alert("You have denied permission for notifications.");
                    updateState(false);
                }
            });
        }
    } else {
        updateState(false);
    }
}

function toggleCategoryNotification(categoryId, isEnabled) {
    if (notificationSettings.categories.hasOwnProperty(categoryId)) {
        notificationSettings.categories[categoryId] = isEnabled;
        saveData();
    }
}

function updateNotificationRateLimit() {
    const amountInput = document.getElementById('notification-rate-amount');
    const unitInput = document.getElementById('notification-rate-unit');
    if (amountInput && unitInput) {
        notificationSettings.rateLimit.amount = parseInt(amountInput.value, 10) || 5;
        notificationSettings.rateLimit.unit = unitInput.value;
        saveData();
    }
}







// =================================================================================
// SECTION 5: Initialization & Notification Engine
// =================================================================================

// --- Notification Engine ---

/**
 * Schedules a single notification to be sent in the future.
 * @param {object} task - The task object for the notification.
 * @param {string} futureStatus - The status the task is changing to (e.g., 'yellow', 'red').
 * @param {number} triggerTimestamp - The future timestamp (in ms) when the notification should be sent.
 */
function scheduleNotification(task, futureStatus, triggerTimestamp) {
    const now = Date.now();
    const delay = triggerTimestamp - now;

    if (delay <= 0) return; // Don't schedule notifications for the past.

    // 1. Check if notifications are globally enabled.
    if (!notificationSettings.enabled) return;

    // 2. Check if the task's category is enabled for notifications.
    const categoryId = task.categoryId || 'null'; // Use 'null' for uncategorized
    if (notificationSettings.categories[categoryId] === false) return;

    // 3. Check the rate limit.
    const rateLimitMs = getDurationMs(notificationSettings.rateLimit.amount, notificationSettings.rateLimit.unit);
    const lastNotified = notificationEngine.lastNotificationTimestamps[task.id] || 0;
    if (now - lastNotified < rateLimitMs) {
        console.log(`Notification for task "${task.name}" suppressed due to rate limit.`);
        return;
    }

    const timeoutId = setTimeout(() => {
        const notificationBody = `Task "${task.name}" is now ${futureStatus}.`;
        new Notification("Task Status Change", {
            body: notificationBody,
            tag: task.id // Using a tag prevents multiple notifications for the same task.
        });
        // Update the timestamp after sending the notification.
        notificationEngine.lastNotificationTimestamps[task.id] = Date.now();
        saveData(); // Save the updated timestamps.
    }, delay);

    // Store the timeout ID so we can cancel it if the user returns to the page.
    notificationEngine.timeouts.push(timeoutId);
}

/**
 * Calculates all future status changes for active tasks and schedules notifications.
 */
function calculateAndScheduleAllNotifications() {
    const now = Date.now();

    tasks.forEach(task => {
        // Skip completed, locked, or tasks with pending user actions.
        if (task.completed || task.status === 'blue' || task.confirmationState) return;
        if (!task.dueDate || isNaN(task.dueDate)) return;

        const dueDateMs = task.dueDate.getTime();
        const estimateMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit) || (30 * MS_PER_MINUTE);

        // Define potential trigger points for status changes.
        const triggerPoints = [
            { status: 'yellow', timestamp: dueDateMs - (estimateMs * 2) },
            { status: 'red', timestamp: dueDateMs - estimateMs },
            { status: 'red', timestamp: dueDateMs } // Becomes overdue
        ];

        triggerPoints.forEach(point => {
            if (point.timestamp > now) {
                scheduleNotification(task, point.status, point.timestamp);
            }
        });
    });

    console.log(`Scheduled ${notificationEngine.timeouts.length} potential notifications.`);
}

/**
 * Starts the notification engine when the page becomes hidden.
 */
function startNotificationEngine() {
    console.log("Page hidden. Starting notification engine...");
    // Ensure the engine is clean before starting.
    stopNotificationEngine();
    calculateAndScheduleAllNotifications();
}

/**
 * Stops the notification engine and clears all scheduled notifications.
 */
function stopNotificationEngine() {
    console.log(`Page visible. Stopping notification engine and clearing ${notificationEngine.timeouts.length} scheduled notifications.`);
    notificationEngine.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
    notificationEngine.timeouts = [];
}


// --- Initialization ---

function initializeDOMElements() {
    // Task Manager
    taskModal = document.getElementById('task-modal'); taskForm = document.getElementById('task-form'); taskListDiv = document.getElementById('task-list'); modalTitle = document.getElementById('modal-title'); taskIdInput = document.getElementById('task-id'); taskNameInput = document.getElementById('task-name');
    taskIconInput = document.getElementById('task-icon');
    iconPickerModal = document.getElementById('icon-picker-modal');
    dataMigrationModal = document.getElementById('data-migration-modal');
    timeInputTypeSelect = document.getElementById('time-input-type');
    dueDateGroup = document.getElementById('due-date-group');
    taskDueDateInput = document.getElementById('task-due-date');
    startDateGroup = document.getElementById('start-date-group');
    taskStartDateInput = document.getElementById('task-start-date');
    dueDateTypeSelect = document.getElementById('due-date-type');
    relativeDueDateGroup = document.getElementById('relative-due-date-group');
    relativeAmountInput = document.getElementById('relative-amount');
    relativeUnitSelect = document.getElementById('relative-unit');
    taskRepetitionSelect = document.getElementById('task-repetition');
    repetitionRelativeGroup = document.getElementById('repetition-relative-group');
    repetitionAmountInput = document.getElementById('repetition-amount');
    repetitionUnitSelect = document.getElementById('repetition-unit');
    repeatingOptionsGroup = document.getElementById('repeating-options-group');
    maxMissesGroup = document.getElementById('max-misses-group'); maxMissesInput = document.getElementById('max-misses');
    trackMissesInput = document.getElementById('track-misses');
    completionTypeSelect = document.getElementById('completion-type'); estimatedDurationGroup = document.getElementById('estimated-duration-group'); estimatedDurationAmountInput = document.getElementById('estimated-duration-amount'); estimatedDurationUnitSelect = document.getElementById('estimated-duration-unit'); completionCountGroup = document.getElementById('completion-count-group'); countTargetInput = document.getElementById('count-target'); completionTimeGroup = document.getElementById('completion-time-group'); timeTargetAmountInput = document.getElementById('time-target-amount'); timeTargetUnitSelect = document.getElementById('time-target-unit');
    repetitionAbsoluteGroup = document.getElementById('repetition-absolute-group');
    absoluteFrequencySelect = document.getElementById('absolute-frequency');
    absoluteWeeklyOptions = document.getElementById('absolute-weekly-options');
    absoluteMonthlyOptions = document.getElementById('absolute-monthly-options');
    absoluteYearlyOptions = document.getElementById('absolute-yearly-options');
    weekdayCheckboxes = document.querySelectorAll('input[name="weekday"]');
    monthlyDayNumberOptions = document.getElementById('monthly-day-number-options');
    monthlyDayOfWeekOptions = document.getElementById('monthly-day-of-week-options');
    yearlyDayNumberOptions = document.getElementById('yearly-day-number-options');
    yearlyDayOfWeekOptions = document.getElementById('yearly-day-of-week-options');
    monthlyOccurrenceCheckboxes = document.querySelectorAll('input[name="monthlyOccurrence"]');
    monthlyWeekdayCheckboxes = document.querySelectorAll('input[name="monthlyWeekday"]');
    monthlyDayCheckboxes = document.querySelectorAll('input[name="monthlyDay"]');
    yearlyOccurrenceCheckboxes = document.querySelectorAll('input[name="yearlyOccurrence"]');
    yearlyMonthCheckboxes = document.querySelectorAll('input[name="yearlyMonth"]');
    yearlyWeekdayCheckboxes = document.querySelectorAll('input[name="yearlyWeekday"]');
    yearlyDayCheckboxes = document.querySelectorAll('input[name="yearlyDay"]');
    requiresFullAttentionInput = document.getElementById('requires-full-attention');
    taskCategorySelect = document.getElementById('task-category');
    newCategoryGroup = document.getElementById('new-category-group');
    newCategoryNameInput = document.getElementById('new-category-name');
    advancedOptionsModal = document.getElementById('advanced-options-modal');
    sortBySelect = document.getElementById('sort-by');
    sortDirectionSelect = document.getElementById('sort-direction');
    categoryFilterList = document.getElementById('category-filter-list');
    plannerDefaultCategorySelect = document.getElementById('planner-default-category');
    dayNightToggle = document.getElementById('day-night-toggle');
    taskViewModal = document.getElementById('task-view-modal');
    taskViewContent = document.getElementById('task-view-content');
    taskStatsContent = document.getElementById('task-stats-content');

    // Pilot Planner
    app = document.getElementById('app');
    weeklyGoalsEl = document.getElementById('weeklyGoals');
    indicatorListEl = document.getElementById('indicatorList');
    newIndicatorInput = document.getElementById('newIndicatorInput');
    newIndicatorFrequency = document.getElementById('newIndicatorFrequency');
    addIndicatorBtn = document.getElementById('addIndicatorBtn');
    calendarEl = document.getElementById('calendar');
    progressTrackerContainer = document.getElementById('progressTrackerContainer');
    viewBtns = document.querySelectorAll('.view-btn');
    startNewWeekBtn = document.getElementById('startNewWeekBtn');
    confirmModal = document.getElementById('confirmModal');
    cancelNewWeekBtn = document.getElementById('cancelNewWeek');
    confirmNewWeekBtn = document.getElementById('confirmNewWeek');
    prevWeekBtn = document.getElementById('prevWeekBtn');
    nextWeekBtn = document.getElementById('nextWeekBtn');
    todayBtn = document.getElementById('todayBtn');
    weekStatusEl = document.getElementById('weekStatus');
    weekDateRangeEl = document.getElementById('weekDateRange');

    // View-switching elements
    showTaskManagerBtn = document.getElementById('show-task-manager-btn');
    showCalendarBtn = document.getElementById('show-calendar-btn');
    showDashboardBtn = document.getElementById('show-dashboard-btn');
    taskManagerView = document.getElementById('task-manager-view');
    calendarView = document.getElementById('calendar-view');
    dashboardView = document.getElementById('dashboard-view');
}
function promptToAdvanceWeeks(weekDiff) {
    const modalTitle = confirmModal.querySelector('h3');
    const modalText = confirmModal.querySelector('p');
    const confirmBtn = document.getElementById('confirmNewWeek');
    const cancelBtn = document.getElementById('cancelNewWeek');

    if (weekDiff === 1) {
        modalTitle.textContent = 'Advance to Next Week?';
        modalText.textContent = 'This will archive the current week, make your "Next Week Preview" the new current week, and remove the oldest week\'s data. This action cannot be undone.';
    } else {
        modalTitle.textContent = `Catch up by ${weekDiff} weeks?`;
        modalText.textContent = `You are ${weekDiff} weeks behind. This will archive all past weeks and catch you up to the current date. This action cannot be undone.`;
    }

    const onConfirm = () => {
        for (let i = 0; i < weekDiff; i++) {
            const weekToSnapshot = appState.weeks[CURRENT_WEEK_INDEX];
            if (!weekToSnapshot.originalState) {
                weekToSnapshot.originalState = {
                    weeklyGoals: weekToSnapshot.weeklyGoals,
                    schedule: deepClone(weekToSnapshot.schedule),
                    kpiData: deepClone(weekToSnapshot.kpiData)
                };
            }
            const lastWeek = appState.weeks[appState.weeks.length - 1];
            const nextWeekStartDate = new Date(lastWeek.startDate); nextWeekStartDate.setDate(nextWeekStartDate.getDate() + 7);
            appState.weeks.push(createNewWeek(nextWeekStartDate)); appState.weeks.shift();
        }
        appState.viewingIndex = CURRENT_WEEK_INDEX;
        savePlannerData();
        saveViewState();
        if (calendar) calendar.refetchEvents();
        confirmModal.classList.add('hidden');
        cleanup();
    };

    const onCancel = () => {
        confirmModal.classList.add('hidden');
        cleanup();
    };

    const cleanup = () => {
        confirmBtn.removeEventListener('click', onConfirm);
        cancelBtn.removeEventListener('click', onCancel);
    };

    confirmBtn.addEventListener('click', onConfirm, { once: true });
    cancelBtn.addEventListener('click', onCancel, { once: true });

    confirmModal.classList.remove('hidden');
}

function setupEventListeners() {
    // Task Manager
    const addTaskBtn = document.getElementById('add-task-btn');
    if (addTaskBtn) {
        addTaskBtn.addEventListener('click', () => openModal());
    }
    const advancedOptionsBtn = document.getElementById('advanced-options-btn');
    if(advancedOptionsBtn) {
        advancedOptionsBtn.addEventListener('click', openAdvancedOptionsModal);
    }
    const advancedOptionsBtnMain = document.getElementById('advancedOptionsBtnMain');
    if(advancedOptionsBtnMain) {
        advancedOptionsBtnMain.addEventListener('click', openAdvancedOptionsModal);
    }
    const advOptionsCloseButton = advancedOptionsModal.querySelector('.close-button');
    if(advOptionsCloseButton) {
        advOptionsCloseButton.addEventListener('click', () => {
            deactivateModal(advancedOptionsModal);
        });
    }

    const taskViewCloseButton = taskViewModal.querySelector('.close-button');
    if (taskViewCloseButton) {
        taskViewCloseButton.addEventListener('click', () => deactivateModal(taskViewModal));
    }

    if (taskForm) {
        taskForm.addEventListener('submit', handleFormSubmit);
    }

    const closeButton = taskModal.querySelector('.close-button');
    const cancelButton = taskModal.querySelector('.cancel-task-button');
    if (closeButton) closeButton.addEventListener('click', closeModal);
    if (cancelButton) cancelButton.addEventListener('click', closeModal);

    const simpleModeToggle = document.getElementById('simple-mode-toggle');
    if (simpleModeToggle) {
        simpleModeToggle.addEventListener('change', (e) => {
            isSimpleMode = !e.target.checked;
            toggleSimpleMode();
        });
    }

    const openIconPickerBtn = document.getElementById('open-icon-picker');
    if (openIconPickerBtn) {
        openIconPickerBtn.addEventListener('click', openIconPicker);
    }

    if (iconPickerModal) {
        const closeBtn = iconPickerModal.querySelector('.close-button');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => deactivateModal(iconPickerModal));
        }

        const content = document.getElementById('icon-picker-content');
        content.addEventListener('click', (e) => {
            // Handle category header clicks for accordion behavior
            const header = e.target.closest('.icon-picker-category-header');
            if (header) {
                const grid = header.nextElementSibling;
                const icon = header.querySelector('span');
                grid.classList.toggle('hidden');
                icon.style.transform = grid.classList.contains('hidden') ? 'rotate(0deg)' : 'rotate(180deg)';
                return;
            }

            // Handle icon selection
            const iconWrapper = e.target.closest('[data-icon]');
            if (iconWrapper) {
                const iconClass = iconWrapper.dataset.icon;
                if (taskIconInput) {
                    taskIconInput.value = iconClass;
                }
                deactivateModal(iconPickerModal);
            }
        });
    }

    timeInputTypeSelect.addEventListener('change', (e) => {
        const isStart = e.target.value === 'start';
        dueDateGroup.classList.toggle('hidden', isStart);
        startDateGroup.classList.toggle('hidden', !isStart);
        if (estimatedDurationAmountInput) {
            estimatedDurationAmountInput.required = isStart;
        }
    });

    taskRepetitionSelect.addEventListener('change', (e) => {
        const type = e.target.value;
        repetitionRelativeGroup.classList.toggle('hidden', type !== 'relative');
        repetitionAbsoluteGroup.classList.toggle('hidden', type !== 'absolute');
        repeatingOptionsGroup.classList.toggle('hidden', type === 'none');
        if(type === 'absolute') { toggleAbsoluteRepetitionFields(absoluteFrequencySelect.value); }
        if (type === 'none') { maxMissesInput.value = ''; trackMissesInput.checked = true; }
    });
    absoluteFrequencySelect.addEventListener('change', (e) => {
        toggleAbsoluteRepetitionFields(e.target.value);
    });
    taskForm.querySelectorAll('input[name="monthlyOption"]').forEach(radio => {
        radio.addEventListener('change', (e) => toggleMonthlyOptions(e.target.value));
    });
    taskForm.querySelectorAll('input[name="yearlyOption"]').forEach(radio => {
        radio.addEventListener('change', (e) => toggleYearlyOptions(e.target.value));
    });
    dueDateTypeSelect.addEventListener('change', (e) => {
        relativeDueDateGroup.classList.toggle('hidden', e.target.value !== 'relative');
    });
    completionTypeSelect.addEventListener('change', (e) => {
        toggleCompletionFields(e.target.value);
    });
    taskCategorySelect.addEventListener('change', (e) => {
        const isNew = e.target.value === 'new_category';
        newCategoryGroup.classList.toggle('hidden', !isNew);
        if (isNew) {
            newCategoryNameInput.focus();
        }
    });
    window.addEventListener('mousedown', (event) => {
        if (event.target === taskModal) {
            closeModal();
        }
        if (event.target === advancedOptionsModal) {
            deactivateModal(advancedOptionsModal);
        }
    });
    taskListDiv.addEventListener('click', (event) => {
        const collapsibleHeader = event.target.closest('.collapsible-header');
        if (collapsibleHeader) {
            const group = collapsibleHeader.dataset.group;
            const tasksToToggle = taskListDiv.querySelectorAll(`.task-item[data-group="${group}"]`);
            const icon = collapsibleHeader.querySelector('span');
            collapsibleHeader.classList.toggle('collapsed');
            if (collapsibleHeader.classList.contains('collapsed')) {
                icon.style.transform = 'rotate(-90deg)';
                tasksToToggle.forEach(t => t.style.display = 'none');
            } else {
                icon.style.transform = 'rotate(0deg)';
                tasksToToggle.forEach(t => t.style.display = 'flex');
            }
            return;
        }

        const taskItem = event.target.closest('.task-item');
        if (!taskItem) return;

        const actionTarget = event.target.closest('[data-action]');
        const taskId = taskItem.dataset.taskId;

        if (!actionTarget || actionTarget.dataset.action === 'viewTask') {
            // If the click is on the task item itself but not on a button, or it's explicitly the view action
             if (!event.target.closest('button, a, input, .edit-progress-button')) {
                openTaskView(taskId);
                return;
            }
        }

        // If an action button was clicked, handle it
        if (actionTarget) {
            const action = actionTarget.dataset.action;
            const taskIdForAction = actionTarget.dataset.taskId; // Use the taskId from the button
            switch (action) {
                case 'edit':
                    editTask(taskIdForAction);
                    break;
                case 'triggerDelete':
                    triggerDelete(taskIdForAction);
                    break;
                case 'triggerCompletion':
                    triggerCompletion(taskIdForAction);
                    break;
                case 'confirmCompletion':
                    confirmCompletionAction(taskIdForAction, actionTarget.dataset.confirmed === 'true');
                    break;
                case 'handleOverdue':
                    handleOverdueChoice(taskIdForAction, actionTarget.dataset.choice);
                    break;
                case 'confirmMiss':
                    confirmMissAction(taskIdForAction, actionTarget.dataset.confirmed === 'true');
                    break;
                case 'confirmDelete':
                    confirmDeleteAction(taskIdForAction, actionTarget.dataset.confirmed === 'true');
                    break;
                case 'triggerUndo':
                    triggerUndoConfirmation(taskIdForAction);
                    break;
                case 'confirmUndo':
                    confirmUndoAction(taskIdForAction, actionTarget.dataset.confirmed === 'true');
                    break;
                case 'incrementCount':
                    incrementCount(taskIdForAction);
                    break;
                case 'decrementCount':
                    decrementCount(taskIdForAction);
                    break;
                case 'toggleTimer':
                    toggleTimer(taskIdForAction);
                    break;
                case 'editProgress':
                    editProgress(taskIdForAction);
                    break;
                case 'saveProgress':
                    saveProgressEdit(taskIdForAction);
                    break;
                case 'cancelProgress':
                    cancelProgressEdit(taskIdForAction);
                    break;
            }
        }
    });
    const advancedOptionsContent = document.getElementById('advanced-options-content');
    if (advancedOptionsContent) {
        advancedOptionsContent.addEventListener('click', (event) => {
            const target = event.target.closest('[data-action]');
            if (!target) return;
            const action = target.dataset.action;
            const categoryId = target.dataset.categoryId;
            const statusKey = target.dataset.statusKey;

            switch(action) {
                case 'bulkEdit':
                    const container = document.getElementById(`bulk-edit-container-${categoryId}`);
                    if (container) {
                        const isHidden = container.classList.contains('hidden');
                        document.querySelectorAll('[id^="bulk-edit-container-"]').forEach(c => c.classList.add('hidden'));

                        if (isHidden) {
                            container.innerHTML = bulkEditFormTemplate(categoryId, lastBulkEditSettings);
                            container.classList.remove('hidden');
                            const form = document.getElementById(`bulk-edit-form-${categoryId}`);
                            form.addEventListener('submit', (e) => {
                                e.preventDefault();
                                handleBulkEditSubmit(categoryId, form);
                            });
                        }
                    }
                    break;
                case 'deleteAllInCategory':
                     if (confirm(`Are you sure you want to permanently delete all tasks in this category? This cannot be undone.`)) {
                        tasks = tasks.filter(t => t.categoryId !== categoryId);
                        saveData();
                        renderTasks();
                        if (calendar) calendar.refetchEvents();
                        alert('All tasks in the category have been deleted.');
                    }
                    break;
                case 'deleteCategory':
                    if (confirm("Are you sure you want to delete this category and ALL of its associated tasks? The history for these tasks will NOT be deleted. This action cannot be undone.")) {
                        deleteCategory(categoryId);
                    }
                    break;
                case 'deleteCategoryTasks': deleteCategoryTasks(categoryId); break;
                case 'addCategory': addCategoryFromManager(); break;
                case 'triggerCategoryEdit': triggerCategoryEdit(categoryId); break;
                case 'saveCategoryEdit': saveCategoryEdit(categoryId); break;
                case 'cancelCategoryEdit': cancelCategoryEdit(categoryId); break;
                case 'triggerStatusNameEdit': triggerStatusNameEdit(statusKey); break;
                case 'saveStatusNameEdit': saveStatusNameEdit(statusKey); break;
                case 'cancelStatusNameEdit': cancelStatusNameEdit(); break;
                case 'restoreDefaults': triggerRestoreDefaults(); break;
                case 'confirmRestoreDefaults': confirmRestoreDefaultsAction(target.dataset.confirmed === 'true'); break;
                case 'toggleAllNotifications': handleMasterNotificationToggle(event); break;
                case 'toggleCategoryNotification':
                    toggleCategoryNotification(target.dataset.categoryId, event.target.checked);
                    break;
                case 'toggleTheme':
                    theming.enabled = event.target.checked;
                    applyTheme();
                    renderThemeControls();
                    saveData();
                    break;
                case 'randomizeTheme':
                    theming.baseColor = getRandomColor();
                    applyTheme();
                    renderThemeControls();
                    saveData();
                    break;
                case 'toggleTimeFormat':
                    appSettings.use24HourFormat = event.target.checked;
                    saveData();
                    renderTasks();
                    if (calendar) calendar.refetchEvents();
                    break;
                case 'exportData':
                    exportData(target.dataset.exportType);
                    break;
                case 'importData':
                    importData();
                    break;
                case 'openMigrationTool':
                    openDataMigrationModal();
                    break;
            }
        });

        const importFileInput = document.getElementById('import-file-input');
        if (importFileInput) {
            importFileInput.addEventListener('change', handleFileImport);
        }

        const themeModeSelector = document.getElementById('theme-mode-selector');
        if (themeModeSelector) {
            themeModeSelector.addEventListener('click', (event) => {
                const target = event.target.closest('.theme-mode-btn');
                if (!target) return;
                const mode = target.dataset.mode;
                if (mode) {
                    theming.mode = mode;
                    applyTheme();
                    renderThemeControls();
                    saveData();
                }
            });
        }
        advancedOptionsContent.addEventListener('change', (event) => {
            const target = event.target;
            if (target.id === 'app-title-input') {
                setAppTitle(target.value);
                return; // Prevent other handlers from running
            }
            if (target.classList.contains('category-color-picker')) {
                const categoryId = target.dataset.categoryId;
                const newColor = target.value;
                const category = categories.find(cat => cat.id === categoryId);
                if (category) {
                    category.color = newColor;
                    saveData();
                    renderCategoryManager();
                    renderTasks();
                }
            } else if (target.classList.contains('category-filter-checkbox')) {
                const allCheckbox = categoryFilterList.querySelector('input[value="all"]');
                const otherCheckboxes = categoryFilterList.querySelectorAll('input:not([value="all"])');
                if (target.value === 'all') {
                    otherCheckboxes.forEach(cb => cb.checked = false);
                    categoryFilter = [];
                } else {
                    allCheckbox.checked = false;
                    categoryFilter = Array.from(otherCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value === 'null' ? null : cb.value);
                }

                if (categoryFilter.length === 0) {
                    allCheckbox.checked = true;
                }
                renderTasks();
                renderPlanner();
            } else if (target.classList.contains('status-color-picker')) {
                 const statusKey = target.dataset.statusKey;
                 const newColor = target.value;
                 if (statusColors.hasOwnProperty(statusKey)) {
                     statusColors[statusKey] = newColor;
                     saveData();
                     renderTasks();
                     renderStatusManager(); // Re-render the manager to show the change
                 }
            } else if (target.id === 'notification-rate-amount' || target.id === 'notification-rate-unit') {
                updateNotificationRateLimit();
            } else if (target.id === 'theme-base-color') {
                theming.baseColor = target.value;
                applyTheme();
                saveData();
            } else if (target.id === 'planner-default-category') {
                plannerSettings.defaultCategoryId = target.value;
                saveData();
            } else if (target.classList.contains('task-display-toggle')) {
                const key = target.name;
                if (taskDisplaySettings.hasOwnProperty(key)) {
                    taskDisplaySettings[key] = target.checked;
                    saveData();
                    renderTasks();
                }
            }
        });
        sortBySelect.addEventListener('change', (e) => {
            sortBy = e.target.value;
            saveData();
            renderTasks();
        });
        sortDirectionSelect.addEventListener('change', (e) => {
            sortDirection = e.target.value;
            saveData();
            renderTasks();
        });
    }

    // Planner Navigation
    if (prevWeekBtn) {
        prevWeekBtn.addEventListener('click', () => {
            if (calendar) calendar.prev();
        });
    }
    if (nextWeekBtn) {
        nextWeekBtn.addEventListener('click', () => {
            if (calendar) calendar.next();
        });
    }
    if (todayBtn) {
        todayBtn.addEventListener('click', () => {
            if (calendar) calendar.today();
        });
    }
    if (viewBtns) {
        viewBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (calendar) {
                    const viewName = btn.dataset.view === 'month' ? 'dayGridMonth' :
                                     btn.dataset.view === 'daily' ? 'timeGridDay' : 'timeGridWeek';
                    calendar.changeView(viewName);
                }
            });
        });
    }

    // Indicator and Goal Listeners (These still seem relevant)
    if (addIndicatorBtn) {
        addIndicatorBtn.addEventListener('click', () => {
            const name = newIndicatorInput.value.trim();
            if (name) {
                const newId = appState.indicators.length > 0 ? Math.max(...appState.indicators.map(i => i.id)) + 1 : 1;
                const frequency = newIndicatorFrequency.value;
                appState.indicators.push({ id: newId, name: name, frequency: frequency });
                newIndicatorInput.value = '';
                savePlannerData();
                // renderProgressTracker(); // This function is removed, might need a replacement if progress tracker is kept
            }
        });
    }
    if (indicatorListEl) {
        indicatorListEl.addEventListener('click', e => {
            if (e.target.matches('.remove-indicator-btn')) {
                appState.indicators = appState.indicators.filter(i => i.id !== parseInt(e.target.dataset.id));
                savePlannerData();
                // renderProgressTracker();
            }
        });
    }

    if (weeklyGoalsEl) {
        weeklyGoalsEl.addEventListener('blur', () => {
            const week = appState.weeks[appState.viewingIndex];
            if (week) {
                const newGoals = weeklyGoalsEl.innerHTML;
                // Amendment checking removed as it was part of the old planner
                week.weeklyGoals = newGoals;
                savePlannerData();
            }
        });
    }

    const addNewTaskBtnPlanner = document.getElementById('addNewTaskBtnPlanner');
    if (addNewTaskBtnPlanner) {
        addNewTaskBtnPlanner.addEventListener('click', () => openModal());
    }

    // Main View Toggles
    const mainViewNav = document.getElementById('main-view-nav');
    if (mainViewNav) {
        mainViewNav.addEventListener('click', (event) => {
            const target = event.target.closest('.view-toggle-btn');
            if (!target) return;

            const views = [
                { btn: showTaskManagerBtn, view: taskManagerView },
                { btn: showCalendarBtn, view: calendarView },
                { btn: showDashboardBtn, view: dashboardView }
            ];

            views.forEach(item => {
                if (item.btn === target) {
                    item.view.classList.remove('hidden');
                    item.btn.classList.add('active-view-btn');
                    // If switching to calendar view, ensure it resizes correctly
                    if (item.view === calendarView && calendar) {
                        calendar.updateSize();
                    }
                } else {
                    item.view.classList.add('hidden');
                    item.btn.classList.remove('active-view-btn');
                }
            });
        });
    }

    // Add the listener for page visibility changes.
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            startNotificationEngine();
        } else {
            stopNotificationEngine();
        }
    });
}

function saveData() {
    try {
        localStorage.setItem('tasks', JSON.stringify(tasks));
        localStorage.setItem('categories', JSON.stringify(categories));
        localStorage.setItem('statusColors', JSON.stringify(statusColors));
        localStorage.setItem('statusNames', JSON.stringify(statusNames));
        localStorage.setItem('sortBy', sortBy);
        localStorage.setItem('sortDirection', sortDirection);
        localStorage.setItem('notificationSettings', JSON.stringify(notificationSettings));
        localStorage.setItem('notificationTimestamps', JSON.stringify(notificationEngine.lastNotificationTimestamps));
        localStorage.setItem('theming', JSON.stringify(theming));
        localStorage.setItem('calendarSettings', JSON.stringify(calendarSettings));
        localStorage.setItem('categoryFilter', JSON.stringify(categoryFilter));
        localStorage.setItem('plannerSettings', JSON.stringify(plannerSettings));
        localStorage.setItem('taskDisplaySettings', JSON.stringify(taskDisplaySettings));
        localStorage.setItem('appSettings', JSON.stringify(appSettings));
        savePlannerData();
    } catch (error) {
        console.error("Error saving data to localStorage:", error);
    }
}

function loadData() {
    const storedTasks = localStorage.getItem('tasks');
    const storedCategories = localStorage.getItem('categories');
    const storedColors = localStorage.getItem('statusColors');
    const storedNames = localStorage.getItem('statusNames');
    const storedSortBy = localStorage.getItem('sortBy');
    const storedSortDirection = localStorage.getItem('sortDirection');
    const storedNotifications = localStorage.getItem('notificationSettings');
    const storedNotificationTimestamps = localStorage.getItem('notificationTimestamps');
    const storedTheming = localStorage.getItem('theming');
    const storedCalendarSettings = localStorage.getItem('calendarSettings');
    const storedCategoryFilter = localStorage.getItem('categoryFilter');
    const storedPlannerSettings = localStorage.getItem('plannerSettings');
    const storedTaskDisplaySettings = localStorage.getItem('taskDisplaySettings');
    const storedAppSettings = localStorage.getItem('appSettings');

    tasks = [];
    categories = [];

    if (storedColors) {
        try {
            const parsedColors = JSON.parse(storedColors);
            statusColors = { ...statusColors, ...parsedColors };
        } catch (e) {
            console.error("Error parsing status colors:", e);
        }
    }
    if (storedNames) {
        try {
            const parsedNames = JSON.parse(storedNames);
            statusNames = { ...statusNames, ...parsedNames };
        } catch (e) {
            console.error("Error parsing status names:", e);
        }
    }

    if (storedSortBy) sortBy = storedSortBy;
    if (storedSortDirection) sortDirection = storedSortDirection;
    sortBySelect.value = sortBy;
    sortDirectionSelect.value = sortDirection;

    if (storedNotifications) {
        try {
            const parsedSettings = JSON.parse(storedNotifications);
            // Deep merge to handle nested objects
            notificationSettings.rateLimit = { ...notificationSettings.rateLimit, ...parsedSettings.rateLimit };
            notificationSettings.categories = { ...notificationSettings.categories, ...parsedSettings.categories };
            notificationSettings.enabled = typeof parsedSettings.enabled === 'boolean' ? parsedSettings.enabled : false;
        } catch(e) {
            console.error("Error parsing notification settings:", e);
        }
    }

    if (storedNotificationTimestamps) {
        try {
            notificationEngine.lastNotificationTimestamps = JSON.parse(storedNotificationTimestamps);
        } catch(e) {
            console.error("Error parsing notification timestamps:", e);
        }
    }

    if (storedTheming) {
        try {
            const parsedTheming = JSON.parse(storedTheming);
            theming = { ...theming, ...parsedTheming };
            if (theming.mode !== 'light' && theming.mode !== 'night' && theming.mode !== 'auto') {
                theming.mode = 'night'; // Default to night if stored value is invalid
            }
        } catch (e) {
            console.error("Error parsing theming settings:", e);
        }
    }

    if (storedCalendarSettings) {
        try {
            const parsedSettings = JSON.parse(storedCalendarSettings);
            calendarSettings = { ...calendarSettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing calendar settings:", e);
        }
    }

    if (storedCategoryFilter) {
        try {
            categoryFilter = JSON.parse(storedCategoryFilter);
        } catch (e) {
            console.error("Error parsing category filter:", e);
        }
    }

    if (storedPlannerSettings) {
        try {
            const parsedSettings = JSON.parse(storedPlannerSettings);
            plannerSettings = { ...plannerSettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing planner settings:", e);
        }
    }

    if (storedTaskDisplaySettings) {
        try {
            const parsedSettings = JSON.parse(storedTaskDisplaySettings);
            taskDisplaySettings = { ...taskDisplaySettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing task display settings:", e);
        }
    }

    if (storedAppSettings) {
        try {
            const parsedSettings = JSON.parse(storedAppSettings);
            appSettings = { ...appSettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing app settings:", e);
        }
    }


    if (storedCategories) {
        try {
            categories = JSON.parse(storedCategories);
        } catch (error) {
            console.error("Error parsing categories from localStorage:", error);
        }
    }
    if (storedTasks) {
        try {
            const parsedTasks = JSON.parse(storedTasks);
            tasks = parsedTasks.map(task => {
                let tempTask = { ...task };
                tempTask.dueDate = task.dueDate ? new Date(task.dueDate) : null;
                tempTask.createdAt = task.createdAt ? new Date(task.createdAt) : new Date();
                tempTask.cycleEndDate = task.cycleEndDate ? new Date(task.cycleEndDate) : null;
                tempTask.timerLastStarted = task.timerLastStarted ? new Date(task.timerLastStarted) : null;
                if (isNaN(tempTask.dueDate)) tempTask.dueDate = null;
                if (isNaN(tempTask.createdAt)) tempTask.createdAt = new Date();
                if (isNaN(tempTask.cycleEndDate)) tempTask.cycleEndDate = null;
                if (isNaN(tempTask.timerLastStarted)) tempTask.timerLastStarted = null;

                return sanitizeAndUpgradeTask(tempTask);
            });

            tasks.forEach(task => {
                if (task.isTimerRunning && task.timerLastStarted) {
                    const elapsedWhileAway = Date.now() - task.timerLastStarted.getTime();
                    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
                    task.currentProgress = (task.currentProgress || 0) + elapsedWhileAway;

                    if (task.currentProgress >= targetMs) {
                        task.currentProgress = targetMs;
                        task.isTimerRunning = false;
                        task.timerLastStarted = null;
                    } else {
                        task.timerLastStarted = new Date().toISOString();
                    }
                }
            });
        } catch (error) {
            console.error("Error parsing tasks from localStorage:", error);
        }
    }

    const newKpiTasks = autoGenerateDailyKpiTasks(appState.indicators, tasks);
    if (newKpiTasks.length > 0) {
        tasks.push(...newKpiTasks);
        saveData();
    }

    updateAllTaskStatuses(true);
    startMainUpdateLoop();
}

function updateAllTaskStatuses(forceRender = false) {
    let changed = false;
    const nowMs = Date.now();
    const currentTasks = [...tasks];
    tasks.forEach(task => {
        try {
            if (task.repetitionType === 'none' && task.completed) return;

            const oldStatus = task.status;
            const oldConfirmationState = task.confirmationState;

            // Step 1: Always calculate the definitive current status based on timing and misses.
            const newStatusResult = calculateStatus(task, nowMs, currentTasks);
            task.status = newStatusResult.name;

            const dueDateMs = task.dueDate ? task.dueDate.getTime() : null;
            const isPastDue = dueDateMs !== null && dueDateMs <= nowMs;

            // Step 2: Determine if a confirmation state is needed, or if it should be cleared.
            if (isPastDue && task.status !== 'blue' && !task.confirmationState) {
                // Task just became overdue. Set prompt and force status to black.
                task.confirmationState = 'awaiting_overdue_input';
                task.status = 'black'; // <-- NEW: Overdue tasks now immediately become black.
                if (!task.overdueStartDate) {
                    task.overdueStartDate = task.dueDate.toISOString();
                }
                task.pendingCycles = calculatePendingCycles(task, nowMs);
                if (task.isTimerRunning) { toggleTimer(task.id); }
            } else if (!isPastDue && (task.confirmationState === 'awaiting_overdue_input' || task.confirmationState === 'confirming_miss')) {
                // This clears the 'Done/Missed' prompt if the task is no longer past due (e.g., date was edited).
                task.confirmationState = null;
                delete task.overdueStartDate;
                delete task.pendingCycles;
            }

            // Step 3: If the status OR the confirmation state changed, flag the UI for a full update.
            // This ensures the color changes without losing the confirmation prompt.
            if (task.status !== oldStatus || task.confirmationState !== oldConfirmationState) {
                changed = true;
            }

            if (task.isTimerRunning && !taskTimers[task.id]) {
                startTimerInterval(task.id);
            }

        } catch (e) {
            console.error("Error updating status for task:", task?.id, e);
        }
    });
    if (changed || forceRender) {
        saveData();
        renderTasks();
    }
}
function startMainUpdateLoop() {
    if (mainUpdateInterval) clearInterval(mainUpdateInterval);
    // The initial update is handled in loadData(), so the immediate timeout is removed.
    mainUpdateInterval = setInterval(() => updateAllTaskStatuses(false), STATUS_UPDATE_INTERVAL);
}

// =================================================================================
// --- MISSION PLANNER SCRIPT ---
// =================================================================================
const getStartOfWeek = (date = new Date()) => { const d = new Date(date); d.setDate(d.getDate() - d.getDay()); d.setHours(0,0,0,0); return d; };
const getISOStringAtMidnight = (date) => { const d = new Date(date); d.setHours(0, 0, 0, 0); return d.toISOString(); };
const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

const createNewWeek = (startDate) => ({
    startDate: getISOStringAtMidnight(startDate),
    weeklyGoals: 'Set new goals for the week...',
    schedule: {},
    kpiData: {},
    amendedItems: { weeklyGoals: false, schedule: {}, kpi: {} },
    originalState: null
});

const savePlannerData = () => {
    // Cleanup historical tasks older than 4 weeks
    const fourWeeksAgo = new Date();
    fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
    if (appState.historicalTasks && appState.historicalTasks.length > 0) {
        appState.historicalTasks = appState.historicalTasks.filter(ht => new Date(ht.completionDate) >= fourWeeksAgo);
    }

    localStorage.setItem(DATA_KEY, JSON.stringify({
        weeks: appState.weeks,
        indicators: appState.indicators,
        historicalTasks: appState.historicalTasks
    }));
};
const saveViewState = () => localStorage.setItem(VIEW_STATE_KEY, JSON.stringify({ viewingIndex: appState.viewingIndex, currentView: appState.currentView, currentDayIndex: appState.currentDayIndex }));

const loadPlannerData = () => {
    const savedData = localStorage.getItem(DATA_KEY);
    if (!savedData) return;
    try {
        const parsedData = JSON.parse(savedData);
        appState.weeks = parsedData.weeks || [];
        appState.weeks.forEach(week => {
            if (!week.amendedItems) week.amendedItems = { weeklyGoals: false, schedule: {}, kpi: {} };
            if (week.originalState === undefined) week.originalState = null;
        });
        appState.indicators = parsedData.indicators || appState.indicators;
        appState.historicalTasks = parsedData.historicalTasks || [];
    } catch (error) { console.error("Failed to parse saved data:", error); }
};

const loadViewState = () => {
    const savedState = localStorage.getItem(VIEW_STATE_KEY);
    if (!savedState) return;
    try {
        const parsedState = JSON.parse(savedState);
        appState.viewingIndex = parsedState.viewingIndex ?? CURRENT_WEEK_INDEX;
        appState.currentView = parsedState.currentView ?? 'weekly';
        appState.currentDayIndex = parsedState.currentDayIndex ?? 0;
    } catch (error) { console.error("Failed to parse view state:", error); }
};

const getFutureWeekStartDate = (viewingIndex) => {
    const lastKnownWeek = appState.weeks[appState.weeks.length - 1];
    const lastKnownStartDate = new Date(lastKnownWeek.startDate);
    const weeksAhead = viewingIndex - (appState.weeks.length - 1);
    const futureStartDate = new Date(lastKnownStartDate);
    futureStartDate.setDate(futureStartDate.getDate() + (weeksAhead * 7));
    return futureStartDate;
};

const renderFutureWeeklyView = (startDate) => {
    const weekStartDate = startDate;
    const weekEndDate = new Date(weekStartDate);
    weekEndDate.setDate(weekEndDate.getDate() + 7);

    plannerContainer.innerHTML = ''; // Clear previous content

    // --- Render Header (copied from renderWeeklyView) ---
    plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell day-header-cell font-semibold bg-gray-800 sticky top-0 z-10" style="grid-column: 1;">Time</div>`);
    for (let i = 0; i < 7; i++) {
        const dayDate = new Date(weekStartDate);
        dayDate.setDate(weekStartDate.getDate() + i);
        plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell day-header-cell font-semibold bg-gray-800 sticky top-0 z-10" style="grid-column: ${i + 2};">${dayDate.toLocaleDateString(undefined, { weekday: 'short' })}<br>${dayDate.toLocaleDateString(undefined, { month: 'numeric', day: 'numeric' })}</div>`);
    }

    // --- Render Time Labels and Grid Cells (copied from renderWeeklyView) ---
    for (let hour = 0; hour <= 23; hour++) {
        const rowStart = hour * 4 + 2;
        const d = new Date();
        d.setHours(hour, 0);
        const timeStr = formatTime(d);
        plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell time-label-cell font-semibold bg-gray-800" style="grid-row: ${rowStart} / span 4;">${timeStr}</div>`);
        for (let day = 0; day < 7; day++) {
            for (let i = 0; i < 4; i++) {
                const slotRow = rowStart + i;
                // Note: In a read-only view, these slots are not interactive for creating new tasks.
                // We still need them for the grid structure.
                plannerContainer.insertAdjacentHTML('beforeend', `<div class="planner-slot" style="grid-column: ${day + 2}; grid-row: ${slotRow};"></div>`);
            }
        }
    }

    // --- Process and Render Tasks (copied from renderWeeklyView) ---
    const dailyTasks = Array.from({ length: 7 }, () => []);

    if (typeof tasks !== 'undefined' && tasks.length > 0) {
        const filteredTasks = tasks.filter(task => {
            if (categoryFilter.length === 0) return true;
            if (!task.categoryId) return categoryFilter.includes(null);
            return categoryFilter.includes(task.categoryId);
        });

        filteredTasks.forEach(task => {
            const occurrences = getTaskOccurrences(task, weekStartDate, weekEndDate);
            occurrences.forEach(({ occurrenceStartDate, occurrenceDueDate }) => {
                const dayOfWeek = occurrenceStartDate.getDay();
                dailyTasks[dayOfWeek].push({ task, occurrenceDate: occurrenceStartDate, dueDate: occurrenceDueDate });
            });
        });
    }

    dailyTasks.forEach((tasksForDay, dayIndex) => {
        const lanes = accommodate(tasksForDay);
        lanes.forEach((lane, laneIndex) => {
            lane.forEach(({ task, occurrenceDate, dueDate }) => {
                renderTaskOnGrid(task, occurrenceDate, dueDate, dayIndex, laneIndex, lanes.length, plannerContainer);
            });
        });
    });
};


// All the old planner rendering functions have been removed.

const initializePlannerState = () => {
    loadPlannerData();
    const today = new Date();
    const currentWeekStartDate = getStartOfWeek(today);
    if (appState.weeks.length === 0) {
        for (let i = -CURRENT_WEEK_INDEX; i < MAX_WEEKS_STORED - CURRENT_WEEK_INDEX; i++) {
            const weekStartDate = new Date(currentWeekStartDate);
            weekStartDate.setDate(weekStartDate.getDate() + (i * 7));
            appState.weeks.push(createNewWeek(weekStartDate));
        }
    } else {
        const storedCurrentWeekStart = new Date(appState.weeks[CURRENT_WEEK_INDEX].startDate);
        let weekDiff = Math.round((currentWeekStartDate.getTime() - storedCurrentWeekStart.getTime()) / (1000 * 60 * 60 * 24 * 7));
        if (weekDiff > 0) {
            promptToAdvanceWeeks(weekDiff);
        }
    }
    while(appState.weeks.length > MAX_WEEKS_STORED) appState.weeks.shift();
    loadViewState();
    if(appState.viewingIndex < 0 || appState.viewingIndex >= MAX_WEEKS_STORED) {
        appState.viewingIndex = CURRENT_WEEK_INDEX;
    }
    savePlannerData();
};

function initializeCalendar() {
    if (!calendarEl) {
        console.error("Calendar element not found!");
        return;
    }

    calendar = new Calendar(calendarEl, {
        plugins: [dayGridPlugin, timeGridPlugin, interactionPlugin],
        initialView: 'timeGridWeek',
        headerToolbar: false,
        editable: true,
        events: (fetchInfo, successCallback, failureCallback) => {
            try {
                const viewStartDate = fetchInfo.start;
                const viewEndDate = fetchInfo.end;
                const scheduledTasks = calculateScheduledTimes(tasks, viewStartDate, viewEndDate);

                const calendarEvents = [];
                const filteredTasks = scheduledTasks.filter(task => {
                    if (categoryFilter.length === 0) return true;
                    if (!task.categoryId) return categoryFilter.includes(null);
                    return categoryFilter.includes(task.categoryId);
                });

                filteredTasks.forEach(task => {
                    const occurrences = getTaskOccurrences(task, viewStartDate, viewEndDate);
                    occurrences.forEach(({ occurrenceStartDate, occurrenceDueDate }) => {
                        const category = categories.find(c => c.id === task.categoryId);
                        const eventColor = category ? category.color : (statusColors[task.status] || '#374151');

                        calendarEvents.push({
                            id: task.id + '_' + occurrenceStartDate.toISOString(), // Create a unique ID for each occurrence
                            title: task.name,
                            start: occurrenceStartDate,
                            end: occurrenceDueDate,
                            color: eventColor,
                            extendedProps: {
                                taskId: task.id,
                                occurrenceDueDate: occurrenceDueDate.toISOString()
                            }
                        });
                    });
                });
                successCallback(calendarEvents);
            } catch (e) {
                console.error("Error fetching events for FullCalendar:", e);
                failureCallback(e);
            }
        },
        datesSet: (info) => {
            // Update the custom header title
            if (weekStatusEl) {
                weekStatusEl.textContent = info.view.title;
            }

            // Update prev/next button labels and view button highlights
            const viewType = info.view.type;
            let prevText = '&lt; Prev';
            let nextText = 'Next &gt;';
            let activeView = 'weekly'; // default

            if (viewType === 'dayGridMonth') {
                prevText = '&lt; Prev Month';
                nextText = 'Next Month &gt;';
                activeView = 'month';
            } else if (viewType === 'timeGridWeek') {
                prevText = '&lt; Prev Week';
                nextText = 'Next Week &gt;';
                activeView = 'weekly';
            } else if (viewType === 'timeGridDay') {
                prevText = '&lt; Prev Day';
                nextText = 'Next Day &gt;';
                activeView = 'daily';
            }

            if (prevWeekBtn) prevWeekBtn.innerHTML = prevText;
            if (nextWeekBtn) nextWeekBtn.innerHTML = nextText;

            // Update active state on view buttons
            viewBtns.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white');
                btn.classList.add('bg-gray-700', 'hover:bg-blue-600');
                if (btn.dataset.view === activeView) {
                    btn.classList.add('bg-blue-600', 'text-white');
                    btn.classList.remove('bg-gray-700', 'hover:bg-blue-600');
                }
            });
        },
        eventClick: (info) => {
            const taskId = info.event.extendedProps.taskId;
            const occurrenceDueDate = new Date(info.event.extendedProps.occurrenceDueDate);
            openTaskView(taskId, occurrenceDueDate);
        },
        dateClick: (info) => {
            const taskStartDate = new Date(info.date);
            const taskDueDate = new Date(taskStartDate.getTime() + (60 * 60 * 1000)); // Add 1 hour

            const defaultCategoryName = plannerSettings.defaultCategoryId || 'Planner';
            let plannerCategory = categories.find(c => c.id === defaultCategoryName);
            if (!plannerCategory) {
                plannerCategory = { id: defaultCategoryName, name: defaultCategoryName, color: getRandomColor() };
                categories.push(plannerCategory);
                renderCategoryManager();
                renderCategoryFilters();
            }

            const newTaskData = {
                id: generateId(),
                name: 'New Event',
                dueDate: taskDueDate,
                estimatedDurationAmount: 1,
                estimatedDurationUnit: 'hours',
                categoryId: plannerCategory.id,
                createdAt: new Date(),
                repetitionType: 'none',
                misses: 0,
                completed: false,
                status: 'green',
            };

            const sanitizedTask = sanitizeAndUpgradeTask(newTaskData);
            tasks.push(sanitizedTask);

            saveData();
            calendar.refetchEvents();
            openModal(sanitizedTask.id, { occurrenceDate: taskDueDate });
        }
    });

    calendar.render();
}

// =================================================================================
// --- UNIFIED INITIALIZATION ---
// =================================================================================
document.addEventListener('DOMContentLoaded', () => {
    console.log("Unified DOMContentLoaded event fired.");

    // --- Initialize Task Manager ---
    try {
        console.log("Initializing Task Manager...");
        initializeDOMElements(); // From Task Manager
        setupEventListeners();   // From Task Manager
        loadData();              // From Task Manager
        setAppTitle(appSettings.title); // Set the title on load
        console.log("Task Manager initialized.");
    } catch (e) {
        console.error("Error during Task Manager initialization:", e);
        const listDiv = document.getElementById('task-list');
        if(listDiv) listDiv.innerHTML = '<p class="text-red-600 font-bold text-center">Error initializing Task Manager. Please check console.</p>';
    }

    // --- Initialize Mission Planner ---
    try {
        console.log("Initializing Mission Planner...");
        initializePlannerState(); // Renamed from initializeOrSyncState
        applyTheme(); // Apply theme after state is initialized
        initializeCalendar(); // New function to set up FullCalendar
        console.log("Mission Planner initialized.");
    } catch (e) {
        console.error("Error during Mission Planner initialization:", e);
    }
});
