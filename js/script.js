import { getDurationMs, calculateStatus, autoGenerateDailyKpiTasks, calculateScheduledTimes } from './task-logic.js';
import { taskTemplate, categoryManagerTemplate, taskViewTemplate, notificationManagerTemplate } from './templates.js';
import { Calendar } from '@fullcalendar/core';
import dayGridPlugin from '@fullcalendar/daygrid';
import timeGridPlugin from '@fullcalendar/timegrid';
import interactionPlugin from '@fullcalendar/interaction';
// =================================================================================
// SCRIPT.JS - COMBINED AND CLEANED
// =================================================================================

// =================================================================================
// SECTION 1: Global State, Constants, & DOM References
// =================================================================================
let tasks = [];
let categories = [];
const defaultStatusColors = { blue: '#00BFFF', green: '#22c55e', yellow: '#facc15', red: '#dc2626', black: '#4b5563' };
const defaultStatusNames = { blue: 'Locked', green: 'Ready', yellow: 'Start Soon', red: 'Do Right Now', black: 'Overdue' };
let statusColors = { ...defaultStatusColors };
let statusNames = { ...defaultStatusNames };
let notificationSettings = { enabled: false, rateLimit: { amount: 5, unit: 'minutes' }, categories: {} };
let notificationEngine = { timeouts: [], lastNotificationTimestamps: {} };
let theming = { enabled: false, baseColor: '#3b82f6', mode: 'auto' };
let appSettings = { title: "Task & Mission Planner", use24HourFormat: false };
let calendarSettings = { categoryFilter: [], syncFilter: true, lastView: 'timeGridWeek' };
let editingTaskId = null;
let isSimpleMode = true;
let countdownIntervals = {};
let mainUpdateInterval = null;
let taskTimers = {};
let sortBy = 'status';
let sortDirection = 'asc';
let categoryFilter = [];
let plannerSettings = { defaultCategoryId: 'Planner' };
let taskDisplaySettings = {
    showDueDate: true, showRepetition: true, showDuration: true,
    showCategory: true, showCountdown: true, showProgress: true,
};
const STATUS_UPDATE_INTERVAL = 15000;
const MS_PER_SECOND = 1000;

const iconCategories = {
    'General': ['fa-solid fa-star', 'fa-solid fa-heart', 'fa-solid fa-check', 'fa-solid fa-xmark', 'fa-solid fa-flag', 'fa-solid fa-bell', 'fa-solid fa-bolt', 'fa-solid fa-gift', 'fa-solid fa-key', 'fa-solid fa-lightbulb', 'fa-solid fa-moon', 'fa-solid fa-sun'],
    'Productivity': ['fa-solid fa-briefcase', 'fa-solid fa-bullseye', 'fa-solid fa-calendar-days', 'fa-solid fa-clock', 'fa-solid fa-file-signature', 'fa-solid fa-laptop-file', 'fa-solid fa-list-check', 'fa-solid fa-pencil', 'fa-solid fa-book-open', 'fa-solid fa-graduation-cap'],
    'Communication': ['fa-solid fa-at', 'fa-solid fa-envelope', 'fa-solid fa-phone', 'fa-solid fa-comments', 'fa-solid fa-users'],
    'Finance': ['fa-solid fa-dollar-sign', 'fa-solid fa-euro-sign', 'fa-solid fa-pound-sign', 'fa-solid fa-yen-sign', 'fa-solid fa-credit-card', 'fa-solid fa-wallet', 'fa-solid fa-piggy-bank'],
    'Health & Fitness': ['fa-solid fa-heart-pulse', 'fa-solid fa-dumbbell', 'fa-solid fa-person-running', 'fa-solid fa-apple-whole', 'fa-solid fa-pills', 'fa-solid fa-stethoscope'],
    'Travel': ['fa-solid fa-plane', 'fa-solid fa-car', 'fa-solid fa-train', 'fa-solid fa-bus', 'fa-solid fa-ship', 'fa-solid fa-earth-americas', 'fa-solid fa-map-location-dot', 'fa-solid fa-suitcase'],
    'Food & Drink': ['fa-solid fa-utensils', 'fa-solid fa-mug-hot', 'fa-solid fa-martini-glass', 'fa-solid fa-ice-cream', 'fa-solid fa-pizza-slice'],
};

const MS_PER_MINUTE = 60000;
const MS_PER_HOUR = 3600000;
const MS_PER_DAY = 86400000;
const DUE_THRESHOLD_MS = 1000;
const MAX_CYCLE_CALCULATION = 100;

// DOM Element References (Task Manager)
let taskModal, taskForm, taskListDiv, modalTitle, taskIdInput, taskNameInput, taskIconInput,
    iconPickerModal,
    timeInputTypeSelect, dueDateGroup, taskDueDateInput, startDateGroup, taskStartDateInput,
    dueDateTypeSelect, relativeDueDateGroup,
    relativeAmountInput, relativeUnitSelect, taskRepetitionSelect, repetitionRelativeGroup,
    repetitionAmountInput, repetitionUnitSelect, repeatingOptionsGroup,
    maxMissesGroup, maxMissesInput, trackMissesInput,
    completionTypeSelect, estimatedDurationGroup,
    estimatedDurationAmountInput, estimatedDurationUnitSelect,
    completionCountGroup, countTargetInput,
    completionTimeGroup, timeTargetAmountInput, timeTargetUnitSelect,
    repetitionAbsoluteGroup, absoluteFrequencySelect,
    absoluteWeeklyOptions, absoluteMonthlyOptions, absoluteYearlyOptions,
    monthlyDayNumberOptions, monthlyDayOfWeekOptions, yearlyDayNumberOptions, yearlyDayOfWeekOptions,
    weekdayCheckboxes, monthlyOccurrenceCheckboxes, yearlyOccurrenceCheckboxes, yearlyMonthCheckboxes,
    monthlyWeekdayCheckboxes, yearlyWeekdayCheckboxes, monthlyDayCheckboxes, yearlyDayCheckboxes,
    requiresFullAttentionInput,
    taskCategorySelect, newCategoryGroup, newCategoryNameInput,
    advancedOptionsModal,
    sortBySelect, sortDirectionSelect, categoryFilterList,
    plannerDefaultCategorySelect, dayNightToggle;

// DOM Element References (Planner)
let app, weeklyGoalsEl, indicatorListEl, newIndicatorInput, newIndicatorFrequency, addIndicatorBtn,
    calendarEl, // New element for FullCalendar
    progressTrackerContainer, viewBtns, startNewWeekBtn, confirmModal,
    cancelNewWeekBtn, confirmNewWeekBtn, prevWeekBtn, nextWeekBtn,
    weekStatusEl, weekDateRangeEl,
    showCalendarBtn, showDashboardBtn, calendarView, dashboardView,
    taskViewModal, taskViewContent, taskStatsContent;

// FullCalendar instance
let calendar;

// Planner State
const MAX_WEEKS_STORED = 6;
const CURRENT_WEEK_INDEX = 4;
const DATA_KEY = 'pilotPlannerDataV8';
const VIEW_STATE_KEY = 'pilotPlannerViewStateV8';

const appState = {
    weeks: [],
    indicators: [ { id: 1, name: 'Hours Studied', frequency: 'weekly' }, { id: 2, name: 'Maneuvers Practiced', frequency: 'weekly' } ],
    historicalTasks: [],
    viewingIndex: CURRENT_WEEK_INDEX, currentView: 'weekly', currentDayIndex: 0,
};


// =================================================================================
// SECTION 2: Logic & Utility Functions
// =================================================================================
function generateId() { return '_' + Math.random().toString(36).substr(2, 9); }
const pad = (num, length = 2) => String(num).padStart(length, '0');

function formatTime(date) {
    if (!date || isNaN(date)) return 'N/A';
    const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: !appSettings.use24HourFormat };
    return date.toLocaleTimeString('en-US', timeOptions);
}

function formatDateForInput(date) {
    if (!date || !(date instanceof Date) || isNaN(date)) return '';
    try {
        const yr = date.getFullYear();
        const mm = pad(date.getMonth() + 1);
        const dd = pad(date.getDate());
        const hh = pad(date.getHours());
        const min = pad(date.getMinutes());
        return `${yr}-${mm}-${dd}T${hh}:${min}`;
    } catch (e) { console.error("Error formatting date:", date, e); return ''; }
}
function calculateFutureDate(amount, unit, baseDate) {
    try {
        const date = new Date(baseDate);
        amount = parseInt(amount, 10);
        if (isNaN(amount) || amount <= 0) amount = 1;
        switch (unit) {
            case 'minutes': date.setMinutes(date.getMinutes() + amount); break;
            case 'hours': date.setHours(date.getHours() + amount); break;
            case 'days': date.setDate(date.getDate() + amount); break;
            case 'weeks': date.setDate(date.getDate() + amount * 7); break;
            case 'months': date.setMonth(date.getMonth() + amount); break;
            default: console.warn("Unknown unit:", unit);
        }
        return date;
    } catch (e) { console.error("Error calculating future date:", e); return new Date(baseDate); }
}
function parseTimeToMs(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return 0;
    const parts = timeStr.split(':').map(Number);
    let ms = 0;
    if (parts.length === 3) {
        ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_HOUR;
        ms += (isNaN(parts[1]) ? 0 : parts[1]) * MS_PER_MINUTE;
        ms += (isNaN(parts[2]) ? 0 : parts[2]) * MS_PER_SECOND;
    } else if (parts.length === 2) {
        ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_MINUTE;
        ms += (isNaN(parts[1]) ? 0 : parts[1]) * MS_PER_SECOND;
    } else if (parts.length === 1) {
        ms += (isNaN(parts[0]) ? 0 : parts[0]) * MS_PER_SECOND;
    }
    return ms;
}
function parseMinutesToMs(minutes) {
    minutes = parseInt(minutes, 10);
    return isNaN(minutes) || minutes < 0 ? 0 : minutes * MS_PER_MINUTE;
}
function calculatePendingCycles(task, nowMs) {
    let cycles = 0;
    const originalDueDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate ? new Date(task.dueDate) : null);
    if (!originalDueDate || isNaN(originalDueDate)) {
        console.warn(`Cannot calculate pending cycles for task ${task.id}: Invalid original due date.`);
        return 0;
    }
    const originalDueDateMs = originalDueDate.getTime();
    const nowDate = new Date(nowMs);
    if (task.repetitionType !== 'none' && originalDueDateMs < nowMs) {
        if (task.repetitionType === 'relative' && task.repetitionAmount && task.repetitionUnit) {
            const intervalMs = getDurationMs(task.repetitionAmount, task.repetitionUnit);
            if (intervalMs > 0) {
                cycles = Math.floor((nowMs - originalDueDateMs) / intervalMs);
                cycles = Math.max(0, cycles) + 1;
            } else {
                console.warn(`Invalid relative interval for task ${task.id}. Defaulting to 1 cycle.`);
                cycles = 1;
            }
        } else if (task.repetitionType === 'absolute') {
            try {
                const occurrences = generateAbsoluteOccurrences(task, new Date(originalDueDate), new Date(nowDate));
                const missedOccurrences = occurrences.filter(occ =>
                    occ.getTime() > originalDueDateMs && occ.getTime() <= nowMs
                );
                cycles = missedOccurrences.length + 1;
            } catch (e) {
                console.error(`Error generating occurrences for pending cycles task ${task.id}:`, e);
                cycles = 1;
            }
        } else {
            cycles = 1;
        }
    }
    return Math.max(cycles, 0);
}
function checkDayOfMonthMatch(date, daysOfMonth) {
    if (!daysOfMonth || daysOfMonth.length === 0) return false;
    const day = date.getDate();
    const year = date.getFullYear();
    const month = date.getMonth();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    for (const selectedDay of daysOfMonth) {
        const selectedDayStr = String(selectedDay);
        if (selectedDayStr === 'last' && day === daysInMonth) return true;
        if (selectedDayStr === 'second_last' && day === daysInMonth - 1) return true;
        if (selectedDayStr === 'third_last' && day === daysInMonth - 2) return true;
        const selectedDayNum = parseInt(selectedDayStr, 10);
        if (!isNaN(selectedDayNum) && selectedDayNum === day) {
            return true;
        }
    }
    return false;
}
function checkNthWeekdayMatch(date, occurrences, weekdays) {
    if (!occurrences || occurrences.length === 0 || !weekdays || weekdays.length === 0) return false;
    const targetDayOfWeek = date.getDay();
    if (!weekdays.includes(targetDayOfWeek)) {
        return false;
    }
    const dayOfMonth = date.getDate();
    const month = date.getMonth();
    const occurrenceNumber = Math.ceil(dayOfMonth / 7);
    for (const selectedOcc of occurrences) {
        const selectedOccStr = String(selectedOcc);
        if (selectedOccStr === 'last') {
            let nextWeekDate = new Date(date);
            nextWeekDate.setDate(dayOfMonth + 7);
            if (nextWeekDate.getMonth() !== month) return true;
        } else {
            const selectedOccNum = parseInt(selectedOccStr, 10);
            if (!isNaN(selectedOccNum) && selectedOccNum === occurrenceNumber) {
                return true;
            }
        }
    }
    return false;
}
function generateAbsoluteOccurrences(task, startDate, endDate) {
    if (task.repetitionType !== 'absolute' || !task.repetitionAbsoluteFrequency || !startDate || isNaN(startDate) || !endDate || isNaN(endDate) || endDate < startDate) {
        console.error(`Invalid input for generateAbsoluteOccurrences for task ${task.id}`);
        return [];
    }
    let occurrences = [];
    let currentDate = new Date(startDate);
    currentDate.setHours(0, 0, 0, 0);
    const maxDaysToScan = 366 * 10;
    let daysScanned = 0;
    const applyTime = (date) => {
        const originalTimeSource = task.dueDate || startDate;
        if (originalTimeSource && !isNaN(originalTimeSource)) {
            date.setHours(originalTimeSource.getHours(), originalTimeSource.getMinutes(), originalTimeSource.getSeconds(), originalTimeSource.getMilliseconds());
        } else {
            date.setHours(0, 0, 0, 0);
        }
        return date;
    };
    while (currentDate <= endDate && daysScanned < maxDaysToScan) {
        daysScanned++;
        let month = currentDate.getMonth();
        let dayOfWeek = currentDate.getDay();
        let isMatch = false;
        try {
            switch (task.repetitionAbsoluteFrequency) {
                case 'weekly':
                    if (task.repetitionAbsoluteWeeklyDays?.includes(dayOfWeek)) isMatch = true;
                    break;
                case 'monthly':
                    if (task.repetitionAbsoluteMonthlyMode === 'day_number') {
                        if (checkDayOfMonthMatch(currentDate, task.repetitionAbsoluteDaysOfMonth)) isMatch = true;
                    } else {
                        if (checkNthWeekdayMatch(currentDate, task.repetitionAbsoluteNthWeekdayOccurrence, task.repetitionAbsoluteNthWeekdayDays)) isMatch = true;
                    }
                    break;
                case 'yearly':
                    if (task.repetitionAbsoluteYearlyMonths?.includes(month)) {
                        if (task.repetitionAbsoluteYearlyMode === 'day_number') {
                            if (checkDayOfMonthMatch(currentDate, task.repetitionAbsoluteYearlyDaysOfMonth)) isMatch = true;
                        } else {
                            if (checkNthWeekdayMatch(currentDate, task.repetitionAbsoluteYearlyNthWeekdayOccurrence, task.repetitionAbsoluteYearlyNthWeekdayDays)) isMatch = true;
                        }
                    }
                    break;
            }
        } catch (e) {
            console.error(`Error checking match for ${task.id} on ${currentDate} in generateAbsoluteOccurrences:`, e);
        }
        if (isMatch) {
            let occurrenceDate = applyTime(new Date(currentDate));
            if (occurrenceDate.getTime() >= startDate.getTime() && occurrenceDate.getTime() <= endDate.getTime()) {
                occurrences.push(occurrenceDate);
            }
        }
        currentDate.setDate(currentDate.getDate() + 1);
        currentDate.setHours(0, 0, 0, 0);
    }
    if (daysScanned >= maxDaysToScan) {
        console.warn(`generateAbsoluteOccurrences reached scan limit (${maxDaysToScan} days) for task ${task.id}`);
    }
    occurrences.sort((a, b) => a.getTime() - b.getTime());
    return occurrences;
}
function sanitizeAndUpgradeTask(task) {
    const defaults = {
        name: 'Unnamed Task',
        icon: null,
        timeInputType: 'due',
        dueDateType: 'absolute',
        dueDate: null,
        repetitionType: 'none',
        maxMisses: null,
        trackMisses: true,
        requiresFullAttention: true,
        completionType: 'simple',
        currentProgress: 0,
        isTimerRunning: false,
        timerLastStarted: null,
        confirmationState: null,
        overdueStartDate: null,
        pendingCycles: null,
        misses: 0,
        completed: false,
        status: 'green',
        createdAt: new Date(),
        cycleEndDate: null,
        completionReducedMisses: false,
        estimatedDurationAmount: null,
        estimatedDurationUnit: 'minutes',
        categoryId: null,
        relativeAmount: null,
        relativeUnit: null,
        repetitionAmount: null,
        repetitionUnit: null,
        repetitionAbsoluteFrequency: null,
        repetitionAbsoluteWeeklyDays: null,
        repetitionAbsoluteMonthlyMode: null,
        repetitionAbsoluteDaysOfMonth: null,
        repetitionAbsoluteNthWeekdayOccurrence: null,
        repetitionAbsoluteNthWeekdayDays: null,
        repetitionAbsoluteYearlyMonths: null,
        repetitionAbsoluteYearlyMode: null,
        repetitionAbsoluteYearlyDaysOfMonth: null,
        repetitionAbsoluteYearlyNthWeekdayOccurrence: null,
        repetitionAbsoluteYearlyNthWeekdayDays: null,
        countTarget: null,
        timeTargetAmount: null,
        timeTargetUnit: null,
    };
    const originalTaskJSON = JSON.stringify(task);
    let upgradedTask = { ...defaults };
    for (const key in defaults) {
        if (task.hasOwnProperty(key) && task[key] !== undefined) {
            upgradedTask[key] = task[key];
        }
    }

    upgradedTask.id = task.id;
    if (task.createdAt) {
      upgradedTask.createdAt = task.createdAt;
    }
    if (task.estimatedDuration && !task.estimatedDurationAmount) {
        upgradedTask.estimatedDurationAmount = parseInt(task.estimatedDuration, 10);
        upgradedTask.estimatedDurationUnit = 'minutes';
    }
    if (upgradedTask.dueDateType !== 'relative') {
        upgradedTask.relativeAmount = null;
        upgradedTask.relativeUnit = null;
    }
    if (upgradedTask.repetitionType === 'none') {
        upgradedTask.repetitionAmount = null;
        upgradedTask.repetitionUnit = null;
        upgradedTask.repetitionAbsoluteFrequency = null;
        upgradedTask.maxMisses = null;
    }
    if (upgradedTask.repetitionType !== 'relative') {
        upgradedTask.repetitionAmount = null;
        upgradedTask.repetitionUnit = null;
    }
    if (upgradedTask.repetitionType !== 'absolute') {
        upgradedTask.repetitionAbsoluteFrequency = null;
    }
    if (upgradedTask.completionType !== 'count') {
        upgradedTask.countTarget = null;
    }
    if (upgradedTask.completionType !== 'time') {
        upgradedTask.timeTargetAmount = null;
        upgradedTask.timeTargetUnit = null;
    }
    if (JSON.stringify(upgradedTask) !== originalTaskJSON) {
        console.log(`Upgraded task ID ${task.id}:`, { from: JSON.parse(originalTaskJSON), to: upgradedTask });
    }
    return upgradedTask;
}
function getRandomColor() {
    // If theming is enabled, use one of the complementary colors for new categories.
    if (theming.enabled) {
        const complementaryPalette = generateComplementaryPalette(theming.baseColor);
        // Return a random color from the complementary set (excluding the main button colors)
        return complementaryPalette[Math.floor(Math.random() * (complementaryPalette.length - 2)) + 2];
    }
    // Original random pastel color logic
    const hue = Math.floor(Math.random() * 360);
    const hslToHex = (h, s, l) => {
        l /= 100;
        const a = s * Math.min(l, 1 - l) / 100;
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    };
    return hslToHex(hue, 80, 85);
}
function getContrastingTextColor(hexcolor) {
    if (!hexcolor) return { color: '#000000', textShadow: 'none' };

    const r = parseInt(hexcolor.substr(1, 2), 16);
    const g = parseInt(hexcolor.substr(3, 2), 16);
    const b = parseInt(hexcolor.substr(5, 2), 16);

    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

    let textColor = luminance > 0.5 ? '#000000' : '#FFFFFF';
    let textShadow = 'none';

    const distanceFromMiddle = Math.abs(luminance - 0.5);
    const opacity = 1 - (distanceFromMiddle / 0.5);

    if (luminance > 0.25 && luminance < 0.75) {
        let shadowColor = luminance > 0.5 ? `rgba(255, 255, 255, ${opacity * 0.7})` : `rgba(0, 0, 0, ${opacity * 0.7})`;
        textShadow = `0px 0px 1px ${shadowColor}`;
    }

    return { color: textColor, textShadow: textShadow };
}
function hexToRgb(hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
}
function interpolateColor(color1, color2, factor) {
    let rgb1 = hexToRgb(color1);
    let rgb2 = hexToRgb(color2);
    if (!rgb1 || !rgb2) return color1; // Fallback

    let result = {
        r: Math.round(rgb1.r + factor * (rgb2.r - rgb1.r)),
        g: Math.round(rgb1.g + factor * (rgb2.g - rgb1.g)),
        b: Math.round(rgb1.b + factor * (rgb2.b - rgb1.b))
    };
    return rgbToHex(result.r, result.g, result.b);
}
function interpolateFiveColors(percent) {
    const colors = [statusColors.black, statusColors.red, statusColors.yellow, statusColors.green, statusColors.blue];
    if (percent <= 0) return colors[0];
    if (percent >= 1) return colors[4];

    const scaledPercent = percent * 4; // Scale to 0-4 range
    const colorIndex = Math.floor(scaledPercent);
    const factor = scaledPercent - colorIndex;

    const interpolatedHex = interpolateColor(colors[colorIndex], colors[colorIndex + 1], factor);

    // Adjust lightness to prevent colors from becoming too pale, ensuring text contrast.
    const hsl = hexToHSL(interpolatedHex);
    hsl.l = Math.max(25, Math.min(hsl.l, 85)); // Clamp lightness between 25% and 85%
    return HSLToHex(hsl.h, hsl.s, hsl.l);
}
function getDueDateGroup(dueDate) {
    if (!dueDate || isNaN(dueDate)) return { name: 'Unscheduled', index: 12 };

    const now = new Date();
    const diffMs = dueDate.getTime() - now.getTime();

    if (diffMs <= 0) return { name: 'Overdue', index: 0 };
    if (diffMs <= MS_PER_HOUR) return { name: 'Next Hour', index: 1 };
    if (diffMs <= MS_PER_HOUR * 4) return { name: 'Next 4 Hours', index: 2 };
    if (diffMs <= MS_PER_HOUR * 8) return { name: 'Next 8 Hours', index: 3 };

    const endOfDay = new Date(now);
    endOfDay.setHours(23, 59, 59, 999);
    if (dueDate <= endOfDay) return { name: 'End of Day', index: 4 };

    const endOfTomorrow = new Date(endOfDay);
    endOfTomorrow.setDate(endOfTomorrow.getDate() + 1);
    if (dueDate <= endOfTomorrow) return { name: 'End of Tomorrow', index: 5 };

    const endOfWeek = new Date(now);
    endOfWeek.setDate(now.getDate() + (6 - now.getDay())); // Assuming Sunday is day 0
    endOfWeek.setHours(23, 59, 59, 999);
    if (dueDate <= endOfWeek) return { name: 'End of Week', index: 6 };

    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
    if (dueDate <= endOfMonth) return { name: 'End of Month', index: 7 };

    const quarter = Math.floor(now.getMonth() / 3);
    const endOfQuarter = new Date(now.getFullYear(), quarter * 3 + 3, 0, 23, 59, 59, 999);
    if (dueDate <= endOfQuarter) return { name: 'End of Quarter', index: 8 };

    const endOfYear = new Date(now.getFullYear(), 12, 0, 23, 59, 59, 999);
    if (dueDate <= endOfYear) return { name: 'End of Year', index: 9 };

    const endOf5Years = new Date(now.getFullYear() + 5, 11, 31, 23, 59, 59, 999);
    if (dueDate <= endOf5Years) return { name: 'Next 5 Years', index: 10 };

    const endOf10Years = new Date(now.getFullYear() + 10, 11, 31, 23, 59, 59, 999);
    if (dueDate <= endOf10Years) return { name: 'Next 10 Years', index: 11 };

    return { name: 'Beyond 10 Years', index: 12 };
}

function getTaskOccurrences(task, viewStartDate, viewEndDate) {
    if (!task.dueDate) return [];

    const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit) || 0;

    // We need to search for due dates in a slightly expanded window to catch tasks that start before the view
    const expandedViewStartDate = new Date(viewStartDate.getTime() - (24 * MS_PER_HOUR)); // Look back 24h as a safe buffer

    let dueDatesInExpandedWindow = [];
    const initialDueDate = new Date(task.dueDate);

    if (task.repetitionType === 'none') {
        dueDatesInExpandedWindow.push(initialDueDate);
    } else if (task.repetitionType === 'absolute') {
        // Generate all occurrences in the expanded window
        dueDatesInExpandedWindow = generateAbsoluteOccurrences(task, expandedViewStartDate, viewEndDate);
    } else if (task.repetitionType === 'relative') {
        const intervalMs = getDurationMs(task.repetitionAmount, task.repetitionUnit);
        if (intervalMs > 0) {
            let currentDate = new Date(initialDueDate);
            // Move backward from the initial due date to find the first potential occurrence before our expanded view.
            while (currentDate.getTime() > expandedViewStartDate.getTime()) {
                currentDate = new Date(currentDate.getTime() - intervalMs);
            }
            // Now, `currentDate` is before or at the start of our search window.
            // Move forward and collect all due dates that fall within the search window up to the view's end.
            let i = 0; // Safety break
            while (currentDate.getTime() < viewEndDate.getTime() && i < 500) {
                // We only need to add it if it's after the start of our search window.
                if (currentDate.getTime() >= expandedViewStartDate.getTime()) {
                    dueDatesInExpandedWindow.push(new Date(currentDate));
                }
                currentDate = new Date(currentDate.getTime() + intervalMs);
                i++;
            }
        }
    }

    // Now, map the candidate due dates to occurrence objects { start, due }
    // and filter for the ones that actually overlap with the *original* view window.
    const occurrences = dueDatesInExpandedWindow.map(dueDate => {
        // If the task has a scheduled time, and this is the first occurrence, use it.
        if (task.scheduledStartTime && dueDate.getTime() === new Date(task.dueDate).getTime()) {
            return {
                occurrenceDueDate: new Date(task.scheduledEndTime),
                occurrenceStartDate: new Date(task.scheduledStartTime)
            };
        }
        return {
            occurrenceDueDate: dueDate,
            occurrenceStartDate: new Date(dueDate.getTime() - durationMs)
        };
    }).filter(occ => {
        // Overlap condition: The task's start is before the view's end, AND the task's end is after the view's start.
        return occ.occurrenceStartDate < viewEndDate && occ.occurrenceDueDate > viewStartDate;
    });

    return occurrences;
}


// --- Theming Engine Functions ---

function hexToHSL(H) {
    let r = 0, g = 0, b = 0;
    if (H.length == 4) {
        r = "0x" + H[1] + H[1]; g = "0x" + H[2] + H[2]; b = "0x" + H[3] + H[3];
    } else if (H.length == 7) {
        r = "0x" + H[1] + H[2]; g = "0x" + H[3] + H[4]; b = "0x" + H[5] + H[6];
    }
    r /= 255; g /= 255; b /= 255;
    let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0, s = 0, l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return { h, s, l };
}

function HSLToHex(h, s, l) {
    s /= 100; l /= 100;
    let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c/2, r = 0, g = 0, b = 0;
    if (0 <= h && h < 60) { r = c; g = x; b = 0; }
    else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
    else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
    else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
    else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
    else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
    r = Math.round((r + m) * 255).toString(16);
    g = Math.round((g + m) * 255).toString(16);
    b = Math.round((b + m) * 255).toString(16);
    if (r.length == 1) r = "0" + r;
    if (g.length == 1) g = "0" + g;
    if (b.length == 1) b = "0" + b;
    return "#" + r + g + b;
}

function generateGradientPalette(baseColor) {
    const baseHSL = hexToHSL(baseColor);
    const isDarkMode = theming.mode === 'night';
    const minLightness = isDarkMode ? 45 : 0; // Ensure minimum brightness in dark mode

    const palette = {
        blue:   HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + 10), Math.max(minLightness, baseHSL.l + 15)),
        green:  HSLToHex(baseHSL.h, baseHSL.s, Math.max(minLightness, baseHSL.l)),
        yellow: HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + 15), Math.max(minLightness, baseHSL.l - 15)),
        red:    HSLToHex(baseHSL.h, Math.min(100, baseHSL.s + 25), Math.max(minLightness, baseHSL.l - 30)),
        black:  HSLToHex(baseHSL.h, baseHSL.s, Math.max(minLightness, baseHSL.l - 45))
    };
    return palette;
}

function generateComplementaryPalette(baseColor) {
    const baseHSL = hexToHSL(baseColor);
    const isDarkMode = theming.mode === 'night';
    const minLightness = isDarkMode ? 50 : 0; // Ensure minimum brightness for buttons in dark mode

    // Main buttons are a triadic color scheme (evenly spaced on the color wheel)
    const addTaskBtnColor = HSLToHex(baseHSL.h, baseHSL.s, Math.max(minLightness, baseHSL.l));
    const calendarBtnColor = HSLToHex((baseHSL.h + 120) % 360, baseHSL.s, Math.max(minLightness, baseHSL.l));
    const advancedOptionsBtnColor = HSLToHex((baseHSL.h + 240) % 360, baseHSL.s, Math.max(minLightness, baseHSL.l));

    // Category colors are more varied, derived from the complementary
    const complementaryHue = (baseHSL.h + 180) % 360;
    const catColor1 = HSLToHex(complementaryHue, baseHSL.s - 10, Math.max(minLightness, baseHSL.l + 10));
    const catColor2 = HSLToHex((complementaryHue + 60) % 360, baseHSL.s - 10, Math.max(minLightness, baseHSL.l + 10));
    const catColor3 = HSLToHex((complementaryHue - 60 + 360) % 360, baseHSL.s, Math.max(minLightness, baseHSL.l));
    return [addTaskBtnColor, calendarBtnColor, advancedOptionsBtnColor, catColor1, catColor2, catColor3];
}

function applyThemeMode() {
    document.body.classList.remove('light-mode', 'auto-theme');
    if (theming.mode === 'light') {
        document.body.classList.add('light-mode');
    } else if (theming.mode === 'auto') {
        document.body.classList.add('auto-theme');
    }
    // For 'night' mode, no class is needed as it's the default.
}

function setAppTitle(newTitle) {
    if (!newTitle || newTitle.trim() === '') {
        newTitle = "Task & Mission Planner"; // Default title
    }
    appSettings.title = newTitle;
    const headerTitle = document.querySelector('#app header h1');
    if (headerTitle) {
        headerTitle.textContent = newTitle;
    }
    document.title = newTitle;
    saveData();
}

function applyTheme() {
    applyThemeMode(); // Apply day/night/auto mode first

    const addTaskBtn = document.getElementById('add-task-btn');
    const advancedOptionsBtn = document.getElementById('advanced-options-btn');

    if (theming.enabled) {
        const gradientPalette = generateGradientPalette(theming.baseColor);
        statusColors = gradientPalette;

        const complementaryPalette = generateComplementaryPalette(theming.baseColor);

        [addTaskBtn, advancedOptionsBtn].forEach((btn, index) => {
            if (btn) {
                const bgColor = complementaryPalette[index];
                const textStyle = getContrastingTextColor(bgColor);
                btn.style.backgroundColor = bgColor;
                btn.style.color = textStyle.color;
                btn.style.textShadow = textStyle.textShadow;
            }
        });

    } else {
        // Revert to default colors
        statusColors = { ...defaultStatusColors };
        [addTaskBtn, advancedOptionsBtn].forEach(btn => {
            if (btn) {
                btn.style.backgroundColor = ''; // Revert to CSS
                btn.style.color = '';
                btn.style.textShadow = '';
            }
        });
    }
    renderTasks();
    if (calendar) calendar.refetchEvents();
}





// =================================================================================
// SECTION 3: UI Rendering Functions
// =================================================================================
function stopAllTimers() {
    stopAllCountdownTimers();
    Object.keys(taskTimers).forEach(taskId => stopTaskTimer(taskId));
}
function stopCountdownTimer(taskId) {
    if (countdownIntervals[taskId]) {
        clearInterval(countdownIntervals[taskId]);
        delete countdownIntervals[taskId];
    }
}
function stopAllCountdownTimers() {
    Object.keys(countdownIntervals).forEach(taskId => clearInterval(countdownIntervals[taskId]));
    countdownIntervals = {};
}
function stopTaskTimer(taskId) {
    if (taskTimers[taskId]) {
        clearInterval(taskTimers[taskId]);
        delete taskTimers[taskId];
    }
}
function renderTasks() {
    stopAllTimers();
    taskListDiv.innerHTML = '';
    const filteredTasks = tasks.filter(task => {
        if (categoryFilter.length === 0) return true;
        if (!task.categoryId) return categoryFilter.includes(null);
        return categoryFilter.includes(task.categoryId);
    });
    if (filteredTasks.length === 0) {
        taskListDiv.innerHTML = '<p class="text-gray-500 text-center italic">No tasks match the current filter.</p>';
        return;
    }
    const statusOrder = { 'black': 0, 'red': 1, 'yellow': 2, 'green': 3, 'blue': 4 };

    const sortedTasks = filteredTasks.sort((a, b) => {
        const completedA = a.repetitionType === 'none' && a.completed;
        const completedB = b.repetitionType === 'none' && b.completed;
        if (completedA && !completedB) return 1;
        if (!completedA && completedB) return -1;
        let comparison = 0;
        if (sortBy === 'status') {
            comparison = (statusOrder[a.status] ?? 5) - (statusOrder[b.status] ?? 5);
        } else if (sortBy === 'dueDate') {
            const dueDateA = a.dueDate ? a.dueDate.getTime() : Infinity;
            const dueDateB = b.dueDate ? b.dueDate.getTime() : Infinity;
            comparison = dueDateA - dueDateB;
        } else if (sortBy === 'category') {
            const categoryA = categories.find(c => c.id === a.categoryId)?.name || 'Uncategorized';
            const categoryB = categories.find(c => c.id === b.categoryId)?.name || 'Uncategorized';
            comparison = categoryA.localeCompare(categoryB);
        }
        if (comparison === 0) {
            const dueDateA = a.dueDate ? a.dueDate.getTime() : Infinity;
            const dueDateB = b.dueDate ? b.dueDate.getTime() : Infinity;
            comparison = dueDateA - dueDateB;
        }
        return sortDirection === 'asc' ? comparison : -comparison;
    });

    const renderTaskItem = (task, groupName) => {
        const taskElement = document.createElement('div');
        const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;

        taskElement.className = `task-item p-2 rounded-lg shadow flex justify-between items-start`;
        taskElement.dataset.taskId = task.id;
        taskElement.dataset.action = 'viewTask'; // Make the whole card clickable
        taskElement.dataset.status = task.status;
        if (groupName) {
            taskElement.dataset.group = groupName;
        }
        taskElement.dataset.confirming = !!task.confirmationState;

        const statusColor = statusColors[task.status] || statusColors.green;
        taskElement.style.backgroundColor = statusColor;
        const category = categories.find(c => c.id === task.categoryId);
        const categoryColor = category ? category.color : 'transparent';
        taskElement.style.borderLeft = `5px solid ${categoryColor}`;
        const textStyle = getContrastingTextColor(statusColor);
        taskElement.style.color = textStyle.color;
        taskElement.style.textShadow = textStyle.textShadow;

        if (isCompletedNonRepeating) taskElement.classList.add('task-completed');
        if (task.confirmationState === 'confirming_delete') taskElement.classList.add('task-confirming-delete');

        taskElement.innerHTML = taskTemplate(task, { categories, taskDisplaySettings, getContrastingTextColor, appSettings });

        taskListDiv.appendChild(taskElement);

        const actionArea = taskElement.querySelector(`#action-area-${task.id}`);
        const commonButtonsArea = taskElement.querySelector(`#common-buttons-${task.id}`);
        if (actionArea) actionArea.innerHTML = generateActionHtml(task);
        if (commonButtonsArea) commonButtonsArea.innerHTML = generateCommonButtonsHtml(task);
    };

    if (sortBy === 'dueDate') {
        const groupedByDate = {};
        sortedTasks.forEach(task => {
            const group = getDueDateGroup(task.dueDate);
            if (!groupedByDate[group.index]) {
                groupedByDate[group.index] = { name: group.name, tasks: [] };
            }
            groupedByDate[group.index].tasks.push(task);
        });

        const groupOrder = Object.keys(groupedByDate).sort((a, b) => a - b);
        if (sortDirection === 'desc') groupOrder.reverse();

        groupOrder.forEach((groupIndex, i) => {
            const group = groupedByDate[groupIndex];
            const header = document.createElement('div');
            header.className = 'collapsible-header p-2 rounded-md cursor-pointer flex justify-between items-center mt-4';
            const percent = groupOrder.length <= 1 ? 0 : (sortDirection === 'asc' ? i / (groupOrder.length - 1) : (groupOrder.length - 1 - i) / (groupOrder.length - 1));
            const bgColor = interpolateFiveColors(percent);
            const textStyle = getContrastingTextColor(bgColor);
            header.style.backgroundColor = bgColor;
            header.style.color = textStyle.color;
            header.style.textShadow = textStyle.textShadow;
            header.innerHTML = `<h4 class="font-bold">${group.name}</h4><span class="transform transition-transform duration-200"> ▼ </span>`;
            header.dataset.group = group.name;
            taskListDiv.appendChild(header);

            group.tasks.forEach(task => renderTaskItem(task, group.name));
        });

    } else { // Handles 'status' and 'category' sorting
        let lastGroup = null;
        sortedTasks.forEach(task => {
            let currentGroup = '';
            let groupColor = '#e5e7eb';

            if (sortBy === 'status') {
                currentGroup = statusNames[task.status] || task.status;
                groupColor = statusColors[task.status] || '#e5e7eb';
            } else if (sortBy === 'category') {
                const category = categories.find(c => c.id === task.categoryId);
                currentGroup = category ? category.name : 'Uncategorized';
                groupColor = category ? category.color : '#FFFFFF';
            }

            if (currentGroup !== lastGroup) {
                const header = document.createElement('div');
                header.className = 'collapsible-header p-2 rounded-md cursor-pointer flex justify-between items-center mt-4';
                const textStyle = getContrastingTextColor(groupColor);
                header.style.backgroundColor = groupColor;
                header.style.color = textStyle.color;
                header.style.textShadow = textStyle.textShadow;
                header.innerHTML = `<h4 class="font-bold">${currentGroup}</h4><span class="transform transition-transform duration-200"> ▼ </span>`;
                header.dataset.group = currentGroup;
                taskListDiv.appendChild(header);
                lastGroup = currentGroup;
            }
            renderTaskItem(task, currentGroup);
        });
    }

    startAllCountdownTimers();
}

function generateActionHtml(task) {
    const cycles = task.pendingCycles || 1;
    switch (task.confirmationState) {
        case 'confirming_complete':
            const text = cycles > 1 ? `Confirm Completion (${cycles} cycles)?` : 'Confirm Completion?';
            return `<div class="flex items-center space-x-1"><span class="action-area-text">${text}</span> <button data-action="confirmCompletion" data-task-id="${task.id}" data-confirmed="true" class="font-bold py-2 px-4 rounded shadow focus:outline-none focus:ring-2 focus:ring-opacity-50 bg-green-500 hover:bg-green-600 text-white focus:ring-green-400">Yes</button> <button data-action="confirmCompletion" data-task-id="${task.id}" data-confirmed="false" class="font-bold py-2 px-4 rounded shadow focus:outline-none focus:ring-2 focus:ring-opacity-50 bg-red-500 hover:bg-red-600 text-white focus:ring-red-400">No</button></div>`;
        case 'awaiting_overdue_input':
            return `<div class="flex items-center space-x-1"><span class="action-area-text">Past Due:</span> <button data-action="handleOverdue" data-task-id="${task.id}" data-choice="completed" class="control-button control-button-green">Done</button> <button data-action="handleOverdue" data-task-id="${task.id}" data-choice="missed" class="control-button control-button-red">Missed</button></div>`;
        case 'confirming_miss':
            const input = cycles > 1 ? `<input type="number" id="miss-count-input-${task.id}" value="${cycles}" min="0" max="${cycles}" class="miss-input"> / ${cycles} cycles?` : '?';
            return `<div class="flex items-center space-x-1"><span class="action-area-text">Confirm Misses ${input}</span> <button data-action="confirmMiss" data-task-id="${task.id}" data-confirmed="true" class="control-button control-button-green">Yes</button> <button data-action="confirmMiss" data-task-id="${task.id}" data-confirmed="false" class="control-button control-button-red">No</button></div>`;
        case 'confirming_delete':
            return `<div class="flex items-center space-x-1"><span class="action-area-text">Delete Task?</span> <button data-action="confirmDelete" data-task-id="${task.id}" data-confirmed="true" class="control-button control-button-red">Yes</button> <button data-action="confirmDelete" data-task-id="${task.id}" data-confirmed="false" class="control-button control-button-gray">Cancel</button></div>`;
        case 'confirming_undo':
            return `<div class="flex items-center space-x-1"><span class="action-area-text">Undo Completion?</span> <button data-action="confirmUndo" data-task-id="${task.id}" data-confirmed="true" class="control-button control-button-yellow">Yes</button> <button data-action="confirmUndo" data-task-id="${task.id}" data-confirmed="false" class="control-button control-button-gray">Cancel</button></div>`;
    }
    const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;
    if (isCompletedNonRepeating) {
        return '<span class="text-xs text-gray-500 italic">Done</span>';
    }
    if (task.status === 'blue') {
        return `<button data-action="triggerUndo" data-task-id="${task.id}" class="control-button control-button-gray" title="Undo Completion / Reactivate Early">Undo</button>`;
    }
    switch (task.completionType) {
        case 'count':
            const target = task.countTarget || Infinity;
            return (task.currentProgress < target)
                ? `<div class="flex items-center space-x-1"> <button data-action="decrementCount" data-task-id="${task.id}" class="control-button control-button-gray w-6 h-6 flex items-center justify-center">-</button> <button data-action="incrementCount" data-task-id="${task.id}" class="control-button control-button-blue w-6 h-6 flex items-center justify-center">+</button> </div>`
                : `<button data-action="triggerCompletion" data-task-id="${task.id}" class="control-button control-button-green">Complete</button>`;
        case 'time':
            const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
            if (task.currentProgress >= targetMs) {
                return `<button data-action="triggerCompletion" data-task-id="${task.id}" class="control-button control-button-green">Complete</button>`;
            }
            const btnText = task.isTimerRunning ? 'Pause' : (task.currentProgress > 0 ? 'Resume' : 'Start');
            const btnClass = task.isTimerRunning ? 'control-button-yellow' : 'control-button-green';
            return `<button data-action="toggleTimer" data-task-id="${task.id}" id="timer-btn-${task.id}" class="control-button ${btnClass}">${btnText}</button>`;
        default:
            return `<button data-action="triggerCompletion" data-task-id="${task.id}" class="control-button control-button-green">Complete</button>`;
    }
}
function generateCommonButtonsHtml(task) {
    if (task.confirmationState) return '';
    const isCompletedNonRepeating = task.repetitionType === 'none' && task.completed;

    if (isCompletedNonRepeating) {
        return `<button data-action="triggerDelete" data-task-id="${task.id}" class="control-button control-button-red" title="Delete Task">Delete</button>`;
    }
    return `
        <div class="flex space-x-1">
            <button data-action="edit" data-task-id="${task.id}" class="control-button control-button-yellow" title="Edit Task">Edit</button>
            <button data-action="triggerDelete" data-task-id="${task.id}" class="control-button control-button-red" title="Delete Task">Delete</button>
        </div>
    `;
}
function formatTimeRemaining(ms) {
    try {
        if (ms <= DUE_THRESHOLD_MS && ms > -DUE_THRESHOLD_MS) return "Due!";
        const isOverdue = ms < 0;
        const absMs = Math.abs(ms);
        const s = Math.floor(absMs / 1000) % 60;
        const m = Math.floor(absMs / MS_PER_MINUTE) % 60;
        const h = Math.floor(absMs / MS_PER_HOUR) % 24;
        const d = Math.floor(absMs / MS_PER_DAY);
        let parts = [];
        if (d > 0) parts.push(`${d} day${d > 1 ? 's' : ''}`);
        if (h > 0) parts.push(`${h} hr${h > 1 ? 's' : ''}`);
        if ((d === 0 || parts.length < 2) && m > 0) parts.push(`${m} min${m > 1 ? 's' : ''}`);
        if (d === 0 && h === 0 && (parts.length < 2 || m === 0) && s > 0) parts.push(`${s} sec${s > 1 ? 's' : ''}`);
        const timeStr = parts.slice(0, 2).join(' ') || (isOverdue ? 'just now' : 'Less than a minute');
        return isOverdue ? `Overdue by: ${timeStr}` : timeStr;
    } catch (e) {
        console.error("Error formatting time remaining:", ms, e);
        return "Error";
    }
}
function updateCountdown(taskId) {
    try {
        const task = tasks.find(t => t.id === taskId);
        const countdownElement = document.getElementById(`countdown-${taskId}`);
        if (!task || !countdownElement) { stopCountdownTimer(taskId); return; }
        if (task.repetitionType === 'none' && task.completed) {
            countdownElement.textContent = '';
            stopCountdownTimer(taskId);
            return;
        }
        const nowMs = Date.now();
        let targetDateMs = null;
        let prefix = '';
        if (task.status === 'blue' && task.cycleEndDate && !isNaN(task.cycleEndDate)) {
            targetDateMs = task.cycleEndDate.getTime();
            prefix = 'Unlocks in: ';
            if (targetDateMs - nowMs <= 0) {
                countdownElement.textContent = '';
                stopCountdownTimer(taskId);
                return;
            }
        } else if (task.dueDate && !isNaN(task.dueDate)) {
            targetDateMs = task.dueDate.getTime();
        } else {
            countdownElement.textContent = '';
            stopCountdownTimer(taskId);
            return;
        }
        const timeRemaining = targetDateMs - nowMs;
        if (task.confirmationState && timeRemaining < 0) prefix = '';
        countdownElement.textContent = prefix + formatTimeRemaining(timeRemaining);
    } catch (e) {
        console.error("Error updating countdown for task:", taskId, e);
        stopCountdownTimer(taskId);
    }
}
function startAllCountdownTimers() {
    stopAllCountdownTimers();
    tasks.forEach(task => {
        try {
            if (task.repetitionType === 'none' && task.completed) return;
            let targetDate = null;
            if (task.status === 'blue' && task.cycleEndDate && !isNaN(task.cycleEndDate)) {
                targetDate = task.cycleEndDate;
            } else if (task.dueDate && !isNaN(task.dueDate)) {
                targetDate = task.dueDate;
            }
            if (targetDate) {
                updateCountdown(task.id);
                const timeRemaining = targetDate.getTime() - Date.now();
                if ((task.status === 'blue' && timeRemaining > 0) || task.status !== 'blue') {
                    if (!countdownIntervals[task.id]) {
                        countdownIntervals[task.id] = setInterval(() => updateCountdown(task.id), 1000);
                    }
                }
            }
        } catch(e) {
            console.error("Error starting countdown timer for task:", task?.id, e);
        }
    });
}
function activateModal(modalElement) {
    if (!modalElement) return;
    modalElement.classList.add('active');
    document.body.classList.add('modal-open');
}

function deactivateModal(modalElement) {
    if (!modalElement) return;
    modalElement.classList.remove('active');
    document.body.classList.remove('modal-open');
}

function openModal(taskId = null, options = {}) {
    try {
        taskForm.reset();
        editingTaskId = taskId;

        // Reset all dynamic fields to their default state
        dueDateGroup.classList.remove('hidden');
        startDateGroup.classList.add('hidden');
        relativeDueDateGroup.classList.add('hidden');
        repetitionRelativeGroup.classList.add('hidden');
        repetitionAbsoluteGroup.classList.add('hidden');
        repeatingOptionsGroup.classList.add('hidden');
        completionCountGroup.classList.add('hidden');
        completionTimeGroup.classList.add('hidden');
        estimatedDurationGroup.classList.remove('hidden');
        newCategoryGroup.classList.add('hidden');

        while (taskCategorySelect.options.length > 2) {
            taskCategorySelect.remove(2);
        }
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.id;
            option.textContent = cat.name;
            taskCategorySelect.appendChild(option);
        });

        if (taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) { console.error("Task not found for editing:", taskId); return; }
            modalTitle.textContent = 'Edit Task';
            taskIdInput.value = task.id;
            taskNameInput.value = task.name;
            taskIconInput.value = task.icon || '';

            // Set Time Input Type and corresponding date fields
            timeInputTypeSelect.value = task.timeInputType || 'due';
            const dateToUse = options.occurrenceDate || task.dueDate;

            if (task.timeInputType === 'start') {
                dueDateGroup.classList.add('hidden');
                startDateGroup.classList.remove('hidden');
                const durationMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit);
                const startDate = new Date(dateToUse.getTime() - durationMs);
                taskStartDateInput.value = formatDateForInput(startDate);
            } else {
                dueDateGroup.classList.remove('hidden');
                startDateGroup.classList.add('hidden');
                taskDueDateInput.value = formatDateForInput(dateToUse);
            }

            dueDateTypeSelect.value = task.dueDateType || 'absolute';
            relativeDueDateGroup.classList.toggle('hidden', task.dueDateType !== 'relative');
            if (task.dueDateType === 'relative') {
                relativeAmountInput.value = task.relativeAmount || 1;
                relativeUnitSelect.value = task.relativeUnit || 'days';
            }

            taskRepetitionSelect.value = task.repetitionType || 'none';
            repetitionRelativeGroup.classList.toggle('hidden', task.repetitionType !== 'relative');
            repetitionAbsoluteGroup.classList.toggle('hidden', task.repetitionType !== 'absolute');
            repeatingOptionsGroup.classList.toggle('hidden', task.repetitionType === 'none');
            if (task.repetitionType === 'relative') {
                repetitionAmountInput.value = task.repetitionAmount || 1;
                repetitionUnitSelect.value = task.repetitionUnit || 'days';
            } else if (task.repetitionType === 'absolute') {
                absoluteFrequencySelect.value = task.repetitionAbsoluteFrequency || 'weekly';
                toggleAbsoluteRepetitionFields(absoluteFrequencySelect.value);
                if (task.repetitionAbsoluteFrequency === 'weekly') {
                    (task.repetitionAbsoluteWeeklyDays || []).forEach(day => {
                        const cb = taskForm.querySelector(`input[name="weekday"][value="${day}"]`);
                        if (cb) cb.checked = true;
                    });
                } else if (task.repetitionAbsoluteFrequency === 'monthly') {
                    taskForm.monthlyOption.value = task.repetitionAbsoluteMonthlyMode || 'day_number';
                    toggleMonthlyOptions(taskForm.monthlyOption.value);
                    if (task.repetitionAbsoluteMonthlyMode === 'day_of_week') {
                        (task.repetitionAbsoluteNthWeekdayOccurrence || []).forEach(occ => { const cb = taskForm.querySelector(`input[name="monthlyOccurrence"][value="${occ}"]`); if (cb) cb.checked = true; });
                        (task.repetitionAbsoluteNthWeekdayDays || []).forEach(day => { const cb = taskForm.querySelector(`input[name="monthlyWeekday"][value="${day}"]`); if (cb) cb.checked = true; });
                    } else {
                        (task.repetitionAbsoluteDaysOfMonth || []).forEach(day => { const cb = taskForm.querySelector(`input[name="monthlyDay"][value="${day}"]`); if (cb) cb.checked = true; });
                    }
                } else if (task.repetitionAbsoluteFrequency === 'yearly') {
                    (task.repetitionAbsoluteYearlyMonths || []).forEach(month => { const cb = taskForm.querySelector(`input[name="yearlyMonth"][value="${month}"]`); if (cb) cb.checked = true; });
                    taskForm.yearlyOption.value = task.repetitionAbsoluteYearlyMode || 'day_number';
                    toggleYearlyOptions(taskForm.yearlyOption.value);
                    if (task.repetitionAbsoluteYearlyMode === 'day_of_week') {
                        (task.repetitionAbsoluteNthWeekdayOccurrence || []).forEach(occ => { const cb = taskForm.querySelector(`input[name="yearlyOccurrence"][value="${occ}"]`); if (cb) cb.checked = true; });
                        (task.repetitionAbsoluteNthWeekdayDays || []).forEach(day => { const cb = taskForm.querySelector(`input[name="yearlyWeekday"][value="${day}"]`); if (cb) cb.checked = true; });
                    } else {
                        (task.repetitionAbsoluteYearlyDaysOfMonth || []).forEach(day => { const cb = taskForm.querySelector(`input[name="yearlyDay"][value="${day}"]`); if (cb) cb.checked = true; });
                    }
                }
            }
            maxMissesInput.value = task.maxMisses || '';
            trackMissesInput.checked = typeof task.trackMisses === 'boolean' ? task.trackMisses : true;
            requiresFullAttentionInput.checked = typeof task.requiresFullAttention === 'boolean' ? task.requiresFullAttention : true;
            completionTypeSelect.value = task.completionType || 'simple';
            estimatedDurationAmountInput.value = task.estimatedDurationAmount || '';
            estimatedDurationUnitSelect.value = task.estimatedDurationUnit || 'minutes';
            countTargetInput.value = task.countTarget || '';
            timeTargetAmountInput.value = task.timeTargetAmount || '';
            timeTargetUnitSelect.value = task.timeTargetUnit || 'minutes';
            taskCategorySelect.value = task.categoryId || '';

            const isComplex = (task.repetitionType && task.repetitionType !== 'none') ||
                (task.completionType && task.completionType !== 'simple') ||
                task.icon || task.categoryId ||
                (task.timeInputType && task.timeInputType === 'start') ||
                (task.dueDateType && task.dueDateType === 'relative');
            isSimpleMode = !isComplex;

        } else {
            modalTitle.textContent = 'Add New Task';
            taskIdInput.value = '';
            isSimpleMode = true; // Default to simple mode for new tasks
        }

        toggleSimpleMode(); // Set the view based on isSimpleMode

        // Ensure estimated duration requirement is set based on time input type
        if (estimatedDurationAmountInput) {
            estimatedDurationAmountInput.required = (timeInputTypeSelect.value === 'start');
        }

        toggleCompletionFields(completionTypeSelect.value);
        activateModal(taskModal);
    } catch (e) {
        console.error("Error opening modal:", e);
    }
}
function closeModal() {
    deactivateModal(taskModal);
    editingTaskId = null;
}

function toggleSimpleMode() {
    const advancedFields = document.getElementById('advanced-task-fields');
    const simpleModeToggle = document.getElementById('simple-mode-toggle');

    if (advancedFields && simpleModeToggle) {
        advancedFields.classList.toggle('hidden', isSimpleMode);
        simpleModeToggle.checked = !isSimpleMode;
    }
}

function toggleCompletionFields(type) {
    completionCountGroup.classList.toggle('hidden', type !== 'count');
    completionTimeGroup.classList.toggle('hidden', type !== 'time');
    const isTimeType = type === 'time';
    estimatedDurationGroup.classList.toggle('hidden', isTimeType);

    // If completion type is 'time', the duration is derived from the time target,
    // so the separate estimated duration input is not needed and should not be required.
    if (isTimeType) {
        if (estimatedDurationAmountInput) {
            estimatedDurationAmountInput.required = false;
        }
    } else {
        // Otherwise, the requirement depends on the time input type (due vs start)
        if (estimatedDurationAmountInput && timeInputTypeSelect) {
             estimatedDurationAmountInput.required = (timeInputTypeSelect.value === 'start');
        }
    }
}
function toggleAbsoluteRepetitionFields(frequency) {
    absoluteWeeklyOptions.classList.toggle('hidden', frequency !== 'weekly');
    absoluteMonthlyOptions.classList.toggle('hidden', frequency !== 'monthly');
    absoluteYearlyOptions.classList.toggle('hidden', frequency !== 'yearly');
    if(frequency === 'monthly') toggleMonthlyOptions(taskForm.monthlyOption.value);
    if(frequency === 'yearly') toggleYearlyOptions(taskForm.yearlyOption.value);
}
function toggleMonthlyOptions(mode) {
    monthlyDayNumberOptions.classList.toggle('hidden', mode !== 'day_number');
    monthlyDayOfWeekOptions.classList.toggle('hidden', mode !== 'day_of_week');
}
function toggleYearlyOptions(mode) {
    yearlyDayNumberOptions.classList.toggle('hidden', mode !== 'day_number');
    yearlyDayOfWeekOptions.classList.toggle('hidden', mode !== 'day_of_week');
}
function renderCategoryManager() {
    const list = document.getElementById('category-manager-list');
    if (!list) return;
    list.innerHTML = categoryManagerTemplate(categories);
}
function renderPlannerSettings() {
    if (!plannerDefaultCategorySelect) return;

    plannerDefaultCategorySelect.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = 'Planner';
    defaultOption.textContent = 'Planner (Default)';
    plannerDefaultCategorySelect.appendChild(defaultOption);

    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        plannerDefaultCategorySelect.appendChild(option);
    });

    plannerDefaultCategorySelect.value = plannerSettings.defaultCategoryId || 'Planner';
}

function renderTaskDisplaySettings() {
    const container = document.getElementById('task-card-display-options');
    if (!container) return;
    for (const key in taskDisplaySettings) {
        const checkbox = container.querySelector(`input[name="${key}"]`);
        if (checkbox) {
            checkbox.checked = taskDisplaySettings[key];
        }
    }
}

function renderAppSettings() {
    const titleInput = document.getElementById('app-title-input');
    if (titleInput) {
        titleInput.value = appSettings.title;
    }
    const timeFormatToggle = document.getElementById('time-format-toggle');
    if (timeFormatToggle) {
        timeFormatToggle.checked = appSettings.use24HourFormat;
    }
}

function openAdvancedOptionsModal() {
    renderCategoryManager();
    renderCategoryFilters();
    renderNotificationManager();
    renderThemeControls();
    renderStatusManager();
    renderPlannerSettings();
    renderTaskDisplaySettings();
    renderAppSettings();
    activateModal(advancedOptionsModal);
}

function openTaskView(taskId, occurrenceDate) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) {
        console.error("Task not found for view:", taskId);
        return;
    }

    // Ensure stats content is hidden and view content is visible initially
    taskViewContent.innerHTML = taskViewTemplate(task, { categories, appSettings });
    taskViewContent.classList.remove('hidden');
    taskStatsContent.classList.add('hidden');
    taskStatsContent.innerHTML = ''; // Clear old stats

    // Add event listeners for the buttons inside the view
    const viewStatsBtn = taskViewContent.querySelector('[data-action="viewTaskStats"]');
    const editTaskBtn = taskViewContent.querySelector('[data-action="editTaskFromView"]');

    if (viewStatsBtn) {
        viewStatsBtn.addEventListener('click', () => renderTaskStats(taskId), { once: true });
    }
    if (editTaskBtn) {
        editTaskBtn.addEventListener('click', () => {
            deactivateModal(taskViewModal);
            openModal(taskId, { occurrenceDate });
        });
    }


    activateModal(taskViewModal);
}

function renderTaskStats(taskId) {
    const task = tasks.find(t => t.id === taskId);
    const history = appState.historicalTasks.filter(ht => ht.originalTaskId === taskId);

    if (!task) return;

    taskViewContent.classList.add('hidden');
    taskStatsContent.classList.remove('hidden');

    const completions = history.filter(h => h.status === 'completed').length;
    const misses = history.filter(h => h.status === 'missed').length;
    const total = completions + misses;
    const completionRate = total > 0 ? ((completions / total) * 100).toFixed(1) : 'N/A';

    let historyHtml = history.length > 0
        ? history.map(h => `<li>${new Date(h.completionDate).toLocaleDateString()}: ${h.status}</li>`).join('')
        : '<li>No history yet.</li>';

    taskStatsContent.innerHTML = `
        <h3 class="text-xl font-semibold mb-4">Stats for: ${task.name}</h3>
        <div class="space-y-2">
            <p><strong>Completion Rate:</strong> ${completionRate}% (${completions} / ${total})</p>
            <p><strong>Total Completions:</strong> ${completions}</p>
            <p><strong>Total Misses:</strong> ${misses}</p>
        </div>
        <h4 class="text-lg font-semibold mt-4 mb-2">History</h4>
        <ul class="list-disc list-inside max-h-48 overflow-y-auto">
            ${historyHtml}
        </ul>
        <button data-action="backToTaskView" class="control-button control-button-gray mt-4">Back to Details</button>
    `;

    const backBtn = taskStatsContent.querySelector('[data-action="backToTaskView"]');
    if (backBtn) {
        backBtn.addEventListener('click', () => {
            taskStatsContent.classList.add('hidden');
            taskViewContent.classList.remove('hidden');
        }, { once: true });
    }
}
function renderCategoryFilters() {
    if (!categoryFilterList) return;
    categoryFilterList.innerHTML = '';
    if (categories.length === 0) {
        categoryFilterList.innerHTML = '<p class="text-gray-500 italic">No categories to filter.</p>';
        return;
    }
    const allLabel = document.createElement('label');
    allLabel.className = 'flex items-center space-x-2';
    allLabel.innerHTML = `
        <input type="checkbox" class="category-filter-checkbox" value="all" ${categoryFilter.length === 0 ? 'checked' : ''}>
        <span>Show All</span>
    `;
    categoryFilterList.appendChild(allLabel);
    const uncategorizedLabel = document.createElement('label');
    uncategorizedLabel.className = 'flex items-center space-x-2';
    uncategorizedLabel.innerHTML = `
        <input type="checkbox" class="category-filter-checkbox" value="null" ${categoryFilter.includes(null) ? 'checked' : ''}>
        <span>Uncategorized</span>
    `;
    categoryFilterList.appendChild(uncategorizedLabel);
    categories.forEach(cat => {
        const label = document.createElement('label');
        label.className = 'flex items-center space-x-2';
        label.innerHTML = `
            <input type="checkbox" class="category-filter-checkbox" value="${cat.id}" ${categoryFilter.includes(cat.id) ? 'checked' : ''}>
            <span>${cat.name}</span>
        `;
        categoryFilterList.appendChild(label);
    });
}

function renderStatusManager() {
    const manager = document.getElementById('status-manager-list');
    if (!manager) return;
    manager.innerHTML = '';

    // Use defaultStatusNames to iterate, ensuring a consistent order.
    Object.keys(defaultStatusNames).forEach(statusKey => {
        const displayName = statusNames[statusKey] || defaultStatusNames[statusKey];
        const color = statusColors[statusKey] || '#ccc';

        const item = document.createElement('div');
        item.className = 'flex items-center justify-between p-2 border-b';
        item.id = `status-item-${statusKey}`;

        item.innerHTML = `
            <div id="status-display-${statusKey}" class="flex-grow flex items-center space-x-3">
                <div class="w-4 h-4 rounded-full" style="background-color: ${color};"></div>
                <span class="font-medium cursor-pointer" data-action="triggerStatusNameEdit" data-status-key="${statusKey}">${displayName}</span>
            </div>
            <div class="flex items-center space-x-2">
                <input type="color" value="${color}" data-status-key="${statusKey}" class="status-color-picker h-8 w-12 border-none cursor-pointer rounded">
            </div>
        `;
        manager.appendChild(item);
    });
}

function renderNotificationManager() {
    const container = document.getElementById('notification-manager-content');
    if (!container) return;

    // Ensure all categories have a setting. Default to true.
    categories.forEach(cat => {
        if (notificationSettings.categories[cat.id] === undefined) {
            notificationSettings.categories[cat.id] = true;
        }
    });

    container.innerHTML = notificationManagerTemplate(notificationSettings, categories);
}

function renderThemeControls() {
    const themeModeSelector = document.getElementById('theme-mode-selector');
    if (themeModeSelector) {
        themeModeSelector.querySelectorAll('.theme-mode-btn').forEach(btn => {
            btn.classList.remove('active-theme-btn');
            if (btn.dataset.mode === theming.mode) {
                btn.classList.add('active-theme-btn');
            }
        });
    }

    const themeToggle = document.getElementById('theme-enabled-toggle');
    const themeControls = document.getElementById('theme-controls');
    const themeColorPicker = document.getElementById('theme-base-color');

    if (themeToggle) themeToggle.checked = theming.enabled;
    if (themeColorPicker) themeColorPicker.value = theming.baseColor;
    if (themeControls) themeControls.classList.toggle('hidden', !theming.enabled);
}

function renderIconPicker() {
    const content = document.getElementById('icon-picker-content');
    if (!content) return;
    content.innerHTML = '';

    for (const category in iconCategories) {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'icon-picker-category';

        const header = document.createElement('div');
        header.className = 'icon-picker-category-header p-2 bg-gray-200 text-gray-800 font-bold rounded cursor-pointer flex justify-between items-center';
        header.textContent = category;
        header.innerHTML += '<span class="transform transition-transform duration-200"> ▼ </span>';

        const grid = document.createElement('div');
        grid.className = 'icon-grid hidden p-2 grid grid-cols-6 sm:grid-cols-8 md:grid-cols-10 gap-2';

        iconCategories[category].forEach(iconClass => {
            const iconWrapper = document.createElement('div');
            iconWrapper.className = 'p-2 flex justify-center items-center rounded-md hover:bg-gray-300 cursor-pointer';
            iconWrapper.dataset.icon = iconClass;
            iconWrapper.innerHTML = `<i class="${iconClass} fa-2x text-gray-700"></i>`;
            grid.appendChild(iconWrapper);
        });

        categoryDiv.appendChild(header);
        categoryDiv.appendChild(grid);
        content.appendChild(categoryDiv);
    }
}

function openIconPicker() {
    renderIconPicker();
    activateModal(iconPickerModal);
}


// =================================================================================
// SECTION 4: User Action Handlers
// =================================================================================

function startTimerInterval(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || !task.isTimerRunning || task.completionType !== 'time') return;

    stopTaskTimer(taskId);

    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
    const progressBeforeStart = (task.currentProgress || 0);
    const timerLastStartedTimestamp = (task.timerLastStarted ? new Date(task.timerLastStarted).getTime() : Date.now());


    taskTimers[taskId] = setInterval(() => {
        const currentTask = tasks.find(t => t.id === taskId);
        if (!currentTask || !currentTask.isTimerRunning) {
            stopTaskTimer(taskId);
            return;
        }

        const elapsedSinceStart = Date.now() - timerLastStartedTimestamp;
        const totalCurrentProgress = progressBeforeStart + elapsedSinceStart;

        const progressElement = document.getElementById(`progress-${taskId}`);
        if (progressElement) {
            progressElement.textContent = `${formatMsToTime(Math.min(totalCurrentProgress, targetMs))} / ${formatMsToTime(targetMs)}`;
        }

        if (totalCurrentProgress >= targetMs) {
            toggleTimer(taskId);
        }
    }, 1000);
}

function handleFormSubmit(event) {
    event.preventDefault();
    try {
        const now = new Date();

        const taskData = {
            name: taskNameInput.value.trim(),
            icon: taskIconInput.value.trim(),
            timeInputType: timeInputTypeSelect.value,
            dueDateType: dueDateTypeSelect.value,
            dueDate: null,
            repetitionType: taskRepetitionSelect.value,
            maxMisses: null,
            trackMisses: true,
            requiresFullAttention: requiresFullAttentionInput.checked,
            completionType: completionTypeSelect.value,
            currentProgress: 0,
            isTimerRunning: false,
            confirmationState: null,
            overdueStartDate: null,
            pendingCycles: null,
            categoryId: null
        };

        if (taskData.dueDateType === 'absolute') {
            if (taskData.timeInputType === 'start') {
                const startDate = taskStartDateInput.value ? new Date(taskStartDateInput.value) : null;
                if (startDate) {
                    const durationMs = getDurationMs(estimatedDurationAmountInput.value, estimatedDurationUnitSelect.value);
                    taskData.dueDate = new Date(startDate.getTime() + durationMs);
                }
            } else {
                taskData.dueDate = taskDueDateInput.value ? new Date(taskDueDateInput.value) : null;
            }
        } else if (taskData.dueDateType === 'relative') {
            const amount = parseInt(relativeAmountInput.value, 10);
            const unit = relativeUnitSelect.value;
            taskData.dueDate = calculateFutureDate(amount, unit, now);
            taskData.relativeAmount = amount;
            taskData.relativeUnit = unit;
        }

        if (taskData.repetitionType === 'relative') {
            taskData.repetitionAmount = parseInt(repetitionAmountInput.value, 10);
            taskData.repetitionUnit = repetitionUnitSelect.value;
            taskData.maxMisses = maxMissesInput.value ? parseInt(maxMissesInput.value, 10) : null;
            taskData.trackMisses = trackMissesInput.checked;
        } else if (taskData.repetitionType === 'absolute') {
            taskData.repetitionAbsoluteFrequency = absoluteFrequencySelect.value;
            if (taskData.repetitionAbsoluteFrequency === 'weekly') {
                taskData.repetitionAbsoluteWeeklyDays = Array.from(weekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
            } else if (taskData.repetitionAbsoluteFrequency === 'monthly') {
                taskData.repetitionAbsoluteMonthlyMode = taskForm.monthlyOption.value;
                if (taskData.repetitionAbsoluteMonthlyMode === 'day_of_week') {
                    taskData.repetitionAbsoluteNthWeekdayOccurrence = Array.from(monthlyOccurrenceCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                    taskData.repetitionAbsoluteNthWeekdayDays = Array.from(monthlyWeekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
                } else {
                    taskData.repetitionAbsoluteDaysOfMonth = Array.from(monthlyDayCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                }
            } else if (taskData.repetitionAbsoluteFrequency === 'yearly') {
                taskData.repetitionAbsoluteYearlyMonths = Array.from(yearlyMonthCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
                taskData.repetitionAbsoluteYearlyMode = taskForm.yearlyOption.value;
                if (taskData.repetitionAbsoluteYearlyMode === 'day_of_week') {
                    taskData.repetitionAbsoluteNthWeekdayOccurrence = Array.from(yearlyOccurrenceCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                    taskData.repetitionAbsoluteNthWeekdayDays = Array.from(yearlyWeekdayCheckboxes).filter(cb => cb.checked).map(cb => parseInt(cb.value, 10));
                } else {
                    taskData.repetitionAbsoluteYearlyDaysOfMonth = Array.from(yearlyDayCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                }
            }
            taskData.maxMisses = maxMissesInput.value ? parseInt(maxMissesInput.value, 10) : null;
            taskData.trackMisses = trackMissesInput.checked;
        }
        const categoryValue = taskCategorySelect.value;
        if (categoryValue === 'new_category') {
            const newCategoryName = newCategoryNameInput.value.trim();
            if (newCategoryName && !categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
                const newCategory = {
                    id: newCategoryName,
                    name: newCategoryName,
                    color: getRandomColor()
                };
                categories.push(newCategory);
                taskData.categoryId = newCategory.id;
            } else if (newCategoryName) {
                taskData.categoryId = categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase()).id;
            }
        } else if (categoryValue) {
            taskData.categoryId = categoryValue;
        }
        if (taskData.completionType === 'count') {
            taskData.countTarget = countTargetInput.value ? parseInt(countTargetInput.value, 10) : null;
            taskData.estimatedDurationAmount = estimatedDurationAmountInput.value ? parseInt(estimatedDurationAmountInput.value, 10) : null;
            taskData.estimatedDurationUnit = estimatedDurationUnitSelect.value;
        } else if (taskData.completionType === 'time') {
            taskData.timeTargetAmount = timeTargetAmountInput.value ? parseInt(timeTargetAmountInput.value, 10) : null;
            taskData.timeTargetUnit = timeTargetUnitSelect.value;
            taskData.estimatedDurationAmount = taskData.timeTargetAmount;
            taskData.estimatedDurationUnit = taskData.timeTargetUnit;
        } else {
            taskData.estimatedDurationAmount = estimatedDurationAmountInput.value ? parseInt(estimatedDurationAmountInput.value, 10) : null;
            taskData.estimatedDurationUnit = estimatedDurationUnitSelect.value;
        }
        if (editingTaskId) {
            const taskIndex = tasks.findIndex(t => t.id === editingTaskId);
            if (taskIndex > -1) {
                const originalTask = tasks[taskIndex];
                const mergedTask = { ...originalTask, ...taskData };
                let updatedTask = sanitizeAndUpgradeTask(mergedTask);
                if (originalTask.repetitionType !== 'none' && updatedTask.repetitionType !== 'none') {
                    updatedTask.misses = originalTask.misses;
                } else {
                    updatedTask.misses = 0;
                }
                if (originalTask.completionType === updatedTask.completionType) {
                    updatedTask.currentProgress = originalTask.currentProgress;
                } else {
                    updatedTask.currentProgress = 0;
                }
                const otherTasks = tasks.filter(t => t.id !== editingTaskId);
                const newStatus = calculateStatus(updatedTask, now.getTime(), otherTasks);
                updatedTask.status = (originalTask.status === 'blue' && originalTask.cycleEndDate?.getTime() > now.getTime()) ? 'blue' : newStatus.name;
                tasks[taskIndex] = updatedTask;
            }
        } else {
            taskData.id = generateId();
            taskData.createdAt = now;
            taskData.misses = 0;
            taskData.completed = false;
            taskData.status = 'green';
            const newTask = sanitizeAndUpgradeTask(taskData);
            const otherTasks = [...tasks];
            newTask.status = calculateStatus(newTask, now.getTime(), otherTasks).name;
            tasks.push(newTask);
        }
        saveData();
        updateAllTaskStatuses(true);
        if (calendar) calendar.refetchEvents();
        closeModal();
    } catch (e) {
        console.error("Error handling form submit:", e);
    }
}
function editTask(taskId) { openModal(taskId); }
function triggerDelete(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (task) {
        task.confirmationState = 'confirming_delete';
        saveData();
        renderTasks();
    }
}
function triggerUndoConfirmation(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (task && task.status === 'blue' && task.repetitionType !== 'none') {
        task.confirmationState = 'confirming_undo';
        saveData();
        renderTasks();
    }
}
function confirmDeleteAction(taskId, confirmed) {
    if (confirmed) {
        stopAllTimers();
        tasks = tasks.filter(t => t.id !== taskId);
        saveData();
        renderTasks();
        if (calendar) calendar.refetchEvents();
    } else {
        const task = tasks.find(t => t.id === taskId);
        if (task) {
            task.confirmationState = null;
            saveData();
            renderTasks();
        }
    }
}
function triggerCompletion(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    if (task.isTimerRunning) toggleTimer(taskId);
    task.confirmationState = 'confirming_complete';
    const nowMs = Date.now();
    if (task.dueDate && nowMs >= task.dueDate.getTime()) {
        if (!task.overdueStartDate) task.overdueStartDate = task.dueDate.toISOString();
        task.pendingCycles = calculatePendingCycles(task, nowMs);
    } else {
        task.pendingCycles = 1;
        delete task.overdueStartDate;
    }
    saveData();
    renderTasks();
}
function confirmCompletionAction(taskId, confirmed) {
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    if (taskIndex === -1) return;

    let task = tasks[taskIndex];
    const cyclesToComplete = task.pendingCycles || 1;
    const wasOverdue = !!task.overdueStartDate;
    const baseDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate || new Date());

    if (confirmed) {
        stopTaskTimer(taskId);

        if (task.repetitionType !== 'none') {
            // Logic for repeating tasks
            const historicalTask = {
                originalTaskId: task.id, name: task.name, completionDate: baseDate, status: 'completed',
                categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
            };
            appState.historicalTasks.push(historicalTask);

            const missesBefore = task.misses || 0;
            task.misses = Math.max(0, missesBefore - cyclesToComplete);
            let missCountReduced = task.misses < missesBefore;

            let nextDueDate = null;
            if (task.repetitionType === 'relative') {
                let current = new Date(baseDate);
                for (let i = 0; i < cyclesToComplete; i++) current = calculateFutureDate(task.repetitionAmount, task.repetitionUnit, current);
                nextDueDate = current;
            } else { // absolute
                const futureOccurrences = generateAbsoluteOccurrences(task, new Date(baseDate.getTime() + 1), new Date(baseDate.getFullYear() + 5, 0, 1));
                if (futureOccurrences.length >= cyclesToComplete) nextDueDate = futureOccurrences[cyclesToComplete - 1];
            }

            if (nextDueDate) {
                task.dueDate = nextDueDate;
                task.status = wasOverdue ? calculateStatus(task, Date.now(), tasks).name : 'blue';
                task.cycleEndDate = wasOverdue ? null : baseDate;
                task.completionReducedMisses = missCountReduced;
            } else {
                task.status = calculateStatus(task, Date.now(), tasks).name;
                delete task.completionReducedMisses;
            }
            task.currentProgress = 0;
            task.completed = false;
            task.confirmationState = null;
            delete task.pendingCycles;
            delete task.overdueStartDate;
            saveData();
            updateAllTaskStatuses(true);

        } else { // Logic for non-repeating tasks
            const historicalTask = {
                originalTaskId: task.id, name: task.name, completionDate: new Date(), status: 'completed',
                categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
            };
            appState.historicalTasks.push(historicalTask);
            tasks = tasks.filter(t => t.id !== taskId);
            saveData();
            updateAllTaskStatuses(true);
            return;
        }
    } else { // User clicked "No"
        if (wasOverdue) {
            task.confirmationState = 'awaiting_overdue_input';
        } else {
            task.confirmationState = null;
            const target = (task.completionType === 'count') ? task.countTarget : getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
            if (target && task.currentProgress >= target) {
                task.currentProgress = target - (task.completionType === 'time' ? 1000 : 1);
            }
        }
        delete task.pendingCycles;
        delete task.overdueStartDate;
        // Do not nullify confirmationState here if it was just set
        if (task.confirmationState !== 'awaiting_overdue_input') {
            task.confirmationState = null;
        }
        saveData();
        updateAllTaskStatuses(true);
    }
}
function confirmUndoAction(taskId, confirmed) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    if (confirmed) {
        if (task.status !== 'blue' || task.repetitionType === 'none') return;

        // Find and remove the last completed instance from history
        const lastCompletedIndex = appState.historicalTasks.map(t => t.originalTaskId).lastIndexOf(taskId);
        if (lastCompletedIndex > -1 && appState.historicalTasks[lastCompletedIndex].status === 'completed') {
            appState.historicalTasks.splice(lastCompletedIndex, 1);
        }

        task.dueDate = task.cycleEndDate ? new Date(task.cycleEndDate) : new Date();
        task.cycleEndDate = null;
        if (task.completionReducedMisses && task.trackMisses && task.maxMisses > 0) {
            task.misses = Math.min(task.maxMisses, (task.misses || 0) + 1);
        }
        delete task.completionReducedMisses;
    }
    task.confirmationState = null;
    saveData();
    updateAllTaskStatuses(true);
}
function confirmMissAction(taskId, confirmed) {
    const taskIndex = tasks.findIndex(t => t.id === taskId);
    if (taskIndex === -1) return;
    let task = tasks[taskIndex];

    if (confirmed) {
        const totalCycles = task.pendingCycles || 1;
        const inputEl = document.getElementById(`miss-count-input-${taskId}`);
        const missesToApply = (inputEl && totalCycles > 1) ? parseInt(inputEl.value, 10) : totalCycles;
        const completionsToApply = totalCycles - missesToApply;
        const baseDate = task.overdueStartDate ? new Date(task.overdueStartDate) : (task.dueDate || new Date());

        if (task.repetitionType !== 'none') {
            // Logic for repeating tasks
            if (missesToApply > 0) {
                const historicalTask = {
                    originalTaskId: task.id, name: task.name, completionDate: baseDate, status: 'missed',
                    categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
                };
                appState.historicalTasks.push(historicalTask);
            }

            if (completionsToApply > 0) task.misses = Math.max(0, (task.misses || 0) - completionsToApply);
            if (missesToApply > 0 && task.trackMisses) {
                task.misses = Math.min(task.maxMisses || Infinity, (task.misses || 0) + missesToApply);
            }

            let nextDueDate = null;
            if (task.repetitionType === 'relative') {
                let current = new Date(baseDate);
                for (let i = 0; i < totalCycles; i++) current = calculateFutureDate(task.repetitionAmount, task.repetitionUnit, current);
                nextDueDate = current;
            } else { // absolute
                const futureOccurrences = generateAbsoluteOccurrences(task, new Date(baseDate.getTime() + 1), new Date(baseDate.getFullYear() + 5, 0, 1));
                if (futureOccurrences.length >= totalCycles) nextDueDate = futureOccurrences[totalCycles - 1];
            }
            task.dueDate = nextDueDate;
            task.cycleEndDate = null;
            task.currentProgress = 0;
            task.confirmationState = null;
            delete task.pendingCycles;
            delete task.overdueStartDate;
        } else { // Logic for non-repeating tasks
            const historicalTask = {
                originalTaskId: task.id, name: task.name, completionDate: new Date(), status: 'missed',
                categoryId: task.categoryId, durationAmount: task.estimatedDurationAmount, durationUnit: task.estimatedDurationUnit,
            };
            appState.historicalTasks.push(historicalTask);
            tasks = tasks.filter(t => t.id !== taskId);
            // Save and render immediately, then exit function.
            saveData();
            updateAllTaskStatuses(true);
            return;
        }
    } else {
        task.confirmationState = 'awaiting_overdue_input';
        delete task.pendingCycles;
        delete task.overdueStartDate;
    }

    task.confirmationState = null;
    saveData();
    updateAllTaskStatuses(true);
}
function handleOverdueChoice(taskId, choice) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    if (!task.overdueStartDate) task.overdueStartDate = task.dueDate ? task.dueDate.toISOString() : null;
    task.pendingCycles = calculatePendingCycles(task, Date.now());
    task.confirmationState = (choice === 'completed') ? 'confirming_complete' : 'confirming_miss';
    saveData();
    renderTasks();
}
function incrementCount(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.completionType !== 'count' || !task.countTarget) return;
    task.currentProgress = (task.currentProgress || 0) + 1;
    if (task.currentProgress >= task.countTarget) {
        task.currentProgress = task.countTarget;
        triggerCompletion(taskId);
    } else {
        saveData();
        renderTasks();
    }
}
function decrementCount(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.completionType !== 'count') return;
    task.currentProgress = Math.max(0, (task.currentProgress || 0) - 1);
    saveData();
    renderTasks();
}
function toggleTimer(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.completionType !== 'time') return;
    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);

    if (task.isTimerRunning) {
        const elapsed = Date.now() - (new Date(task.timerLastStarted).getTime() || Date.now());
        stopTaskTimer(taskId);

        task.currentProgress = (task.currentProgress || 0) + elapsed;
        if (task.currentProgress >= targetMs) {
            task.currentProgress = targetMs;
        }
        task.isTimerRunning = false;
        task.timerLastStarted = null;

        saveData();
        renderTasks();

        if (task.currentProgress >= targetMs) {
            triggerCompletion(taskId);
        }

    } else {
        if (task.currentProgress >= targetMs) {
            triggerCompletion(taskId);
            return;
        }
        task.isTimerRunning = true;
        task.timerLastStarted = new Date().toISOString();

        startTimerInterval(taskId);

        const timerButton = document.getElementById(`timer-btn-${taskId}`);
        if (timerButton) {
            timerButton.textContent = 'Pause';
            timerButton.classList.remove('control-button-green');
            timerButton.classList.add('control-button-yellow');
        }
        saveData();
    }
}
function editProgress(taskId) {
    const task = tasks.find(t => t.id === taskId);
    const container = document.getElementById(`progress-container-${taskId}`);
    if (!task || !container) return;

    if (task.isTimerRunning) {
        toggleTimer(taskId);
    }

    let currentValue, max;
    if (task.completionType === 'count') {
        currentValue = task.currentProgress || 0;
        max = task.countTarget || Infinity;
    } else if (task.completionType === 'time') {
        currentValue = Math.round((task.currentProgress || 0) / MS_PER_MINUTE);
        max = Math.round(getDurationMs(task.timeTargetAmount, task.timeTargetUnit) / MS_PER_MINUTE);
    } else return;
    container.innerHTML = `
        <input type="number" id="edit-progress-input-${taskId}" value="${currentValue}" min="0" ${max !== Infinity ? `max="${max}"` : ''} class="progress-input">
        <button data-action="saveProgress" data-task-id="${taskId}" class="control-button control-button-green text-xs ml-1">Save</button>
        <button data-action="cancelProgress" data-task-id="${taskId}" class="control-button control-button-gray text-xs ml-1">Cancel</button>
    `;
    document.getElementById(`edit-progress-input-${taskId}`).focus();
}
function saveProgressEdit(taskId) {
    const task = tasks.find(t => t.id === taskId);
    const input = document.getElementById(`edit-progress-input-${taskId}`);
    if (!task || !input) return;
    let newValue = parseInt(input.value, 10);
    if (isNaN(newValue)) { renderTasks(); return; }
    if (task.completionType === 'count') {
        const target = task.countTarget || Infinity;
        task.currentProgress = Math.max(0, Math.min(newValue, target));
        if (task.currentProgress >= target) { triggerCompletion(taskId); }
    } else if (task.completionType === 'time') {
        const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
        task.currentProgress = Math.max(0, Math.min(parseMinutesToMs(newValue), targetMs));
        if (task.currentProgress >= targetMs) { triggerCompletion(taskId); }
    }
    saveData();
    renderTasks();
}
function cancelProgressEdit(taskId) { renderTasks(); }
function deleteCategory(categoryId) {
    tasks.forEach(task => {
        if (task.categoryId === categoryId) {
            task.categoryId = null;
        }
    });
    categories = categories.filter(cat => cat.id !== categoryId);
    saveData();
    renderCategoryManager();
    renderTasks();
}
function addCategoryFromManager() {
    const newCategoryName = prompt("Enter new category name:");
    if (newCategoryName && !categories.find(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
        const newCategory = {
            id: newCategoryName,
            name: newCategoryName,
            color: getRandomColor()
        };
        categories.push(newCategory);
        saveData();
        renderCategoryManager();
        renderCategoryFilters();
    } else if (newCategoryName) {
        alert("A category with that name already exists.");
    }
}

function triggerCategoryEdit(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    if (!category) return;

    renderCategoryManager();

    const displayDiv = document.getElementById(`category-display-${categoryId}`);
    if (!displayDiv) return;

    displayDiv.innerHTML = `
        <input type="text" id="edit-category-input-${categoryId}" value="${category.name}" class="progress-input flex-grow">
        <button data-action="saveCategoryEdit" data-category-id="${categoryId}" class="control-button control-button-green text-xs ml-1">Save</button>
        <button data-action="cancelCategoryEdit" data-category-id="${categoryId}" class="control-button control-button-gray text-xs ml-1">Cancel</button>
    `;
    document.getElementById(`edit-category-input-${categoryId}`).focus();
}

function saveCategoryEdit(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    const input = document.getElementById(`edit-category-input-${categoryId}`);
    if (!category || !input) return;

    const newName = input.value.trim();
    if (newName && newName !== '' && !categories.find(c => c.name.toLowerCase() === newName.toLowerCase() && c.id !== categoryId)) {
        const oldId = category.id;
        category.name = newName;
        category.id = newName;
        tasks.forEach(task => {
            if (task.categoryId === oldId) {
                task.categoryId = category.id;
            }
        });
        saveData();
        renderCategoryManager();
        renderTasks();
        renderCategoryFilters();
    } else if (newName) {
        alert("A category with that name already exists or the name is invalid.");
        renderCategoryManager();
    }
}

function deleteActiveCategoryTasks(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    if (!category) return;

    const tasksToDelete = tasks.filter(task =>
        task.categoryId === categoryId &&
        task.status !== 'blue'
    );

    if (tasksToDelete.length === 0) {
        alert(`No active tasks to delete in the "${category.name}" category.`);
        return;
    }

    if (confirm(`Are you sure you want to delete ${tasksToDelete.length} active task(s) in the "${category.name}" category? This is irreversible. Your history for these tasks will be preserved.`)) {
        const idsToDelete = tasksToDelete.map(t => t.id);
        tasks = tasks.filter(task => !idsToDelete.includes(task.id));
        saveData();
        renderTasks();
        if (calendar) calendar.refetchEvents();
        alert('Active tasks deleted.');
    }
}

function deleteCategoryTasks(categoryId) {
    const category = categories.find(c => c.id === categoryId);
    if (!category) return;

    const tasksToDelete = tasks.filter(task => task.categoryId === categoryId);

    if (tasksToDelete.length === 0) {
        alert(`There are no tasks in the "${category.name}" category to delete.`);
        return;
    }

    if (confirm(`Are you sure you want to delete all ${tasksToDelete.length} task(s) in the "${category.name}" category? This action cannot be undone.`)) {
        const idsToDelete = tasksToDelete.map(t => t.id);
        tasks = tasks.filter(task => !idsToDelete.includes(task.id));
        saveData();
        renderTasks();
        if (calendar) calendar.refetchEvents();
        alert('All tasks in the category have been deleted.');
    }
}

function cancelCategoryEdit(categoryId) {
    renderCategoryManager();
}

function triggerStatusNameEdit(statusKey) {
    const status = statusNames[statusKey];
    if (status === undefined) return;
    renderStatusManager();
    const displayDiv = document.getElementById(`status-display-${statusKey}`);
    if (!displayDiv) return;
    displayDiv.innerHTML = `
        <input type="text" id="edit-status-input-${statusKey}" value="${status}" class="progress-input flex-grow">
        <button data-action="saveStatusNameEdit" data-status-key="${statusKey}" class="control-button control-button-green text-xs ml-1">Save</button>
        <button data-action="cancelStatusNameEdit" data-status-key="${statusKey}" class="control-button control-button-gray text-xs ml-1">Cancel</button>
    `;
    document.getElementById(`edit-status-input-${statusKey}`).focus();
}

function saveStatusNameEdit(statusKey) {
    const input = document.getElementById(`edit-status-input-${statusKey}`);
    if (!input) return;
    const newName = input.value.trim();
    if (newName && newName !== '') {
        statusNames[statusKey] = newName;
        saveData();
        renderStatusManager();
        renderTasks();
    } else {
        alert("Status name cannot be empty.");
        renderStatusManager();
    }
}

function cancelStatusNameEdit(statusKey) {
    renderStatusManager();
}


function triggerRestoreDefaults() {
    const container = document.getElementById('restore-defaults-container');
    if (container) {
        container.innerHTML = `
            <div class="flex flex-col items-center gap-2 text-center">
                <p class="text-sm">Reset all view and theme settings to their original defaults? Your tasks, categories, and planner entries will not be affected.</p>
                <div class="flex gap-2 mt-2">
                    <button data-action="confirmRestoreDefaults" data-confirmed="true" class="control-button control-button-red">Yes, Reset</button>
                    <button data-action="confirmRestoreDefaults" data-confirmed="false" class="control-button control-button-gray">No, Cancel</button>
                </div>
            </div>
        `;
    }
}

function confirmRestoreDefaultsAction(confirmed) {
    const container = document.getElementById('restore-defaults-container');
    if (confirmed) {
        statusColors = { ...defaultStatusColors };
        statusNames = { ...defaultStatusNames };
        sortBy = 'status';
        sortDirection = 'asc';
        theming.enabled = false;

        saveData();
        sortBySelect.value = sortBy;
        sortDirectionSelect.value = sortDirection;
        applyTheme();
        openAdvancedOptionsModal();
    }

    if (container) {
        container.innerHTML = `<button data-action="restoreDefaults" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Restore All Defaults</button>`;
    }
}

// --- Data Portability Functions ---

function exportData(exportType) {
    const dataToExport = {
        exportFormatVersion: '1.0',
        exportDate: new Date().toISOString(),
        dataType: exportType,
        data: {}
    };

    const allSettings = {
        statusColors, statusNames, sortBy, sortDirection, notificationSettings, theming,
        calendarSettings, categoryFilter, plannerSettings, taskDisplaySettings, appSettings
    };

    switch (exportType) {
        case 'all':
            dataToExport.data = {
                tasks,
                categories,
                appState,
                settings: allSettings
            };
            break;
        case 'tasks':
            dataToExport.data = { tasks };
            break;
        case 'categories':
            dataToExport.data = { categories };
            break;
        case 'history':
            dataToExport.data = { appState: { historicalTasks: appState.historicalTasks } };
            break;
        case 'settings':
            dataToExport.data = { settings: allSettings };
            break;
        default:
            console.error("Unknown export type:", exportType);
            return;
    }

    const dataStr = JSON.stringify(dataToExport, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    link.download = `task-planner-backup-${exportType}-${timestamp}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}


function importData() {
    const fileInput = document.getElementById('import-file-input');
    fileInput.click();
}

function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importedData = JSON.parse(e.target.result);

            if (!importedData.exportFormatVersion || !importedData.dataType || !importedData.data) {
                alert('Error: Invalid or corrupted backup file.');
                return;
            }

            if (!confirm('This will overwrite existing data. Are you sure you want to continue?')) {
                return;
            }

            const importContent = importedData.data;

            if (importedData.dataType === 'all') {
                if(importContent.tasks) localStorage.setItem('tasks', JSON.stringify(importContent.tasks));
                if(importContent.categories) localStorage.setItem('categories', JSON.stringify(importContent.categories));
                if(importContent.appState) localStorage.setItem(DATA_KEY, JSON.stringify(importContent.appState));
                if(importContent.settings) {
                    Object.keys(importContent.settings).forEach(key => {
                        localStorage.setItem(key, JSON.stringify(importContent.settings[key]));
                    });
                }
            } else if (importedData.dataType === 'tasks' && importContent.tasks) {
                 localStorage.setItem('tasks', JSON.stringify(importContent.tasks));
            } else if (importedData.dataType === 'categories' && importContent.categories) {
                 localStorage.setItem('categories', JSON.stringify(importContent.categories));
            } else if (importedData.dataType === 'history' && importContent.appState) {
                const existingPlannerData = JSON.parse(localStorage.getItem(DATA_KEY)) || {};
                existingPlannerData.historicalTasks = importContent.appState.historicalTasks;
                localStorage.setItem(DATA_KEY, JSON.stringify(existingPlannerData));
            } else if (importedData.dataType === 'settings' && importContent.settings) {
                 Object.keys(importContent.settings).forEach(key => {
                    localStorage.setItem(key, JSON.stringify(importContent.settings[key]));
                });
            } else {
                alert('Error: The data type in the file is not recognized or data is missing.');
                return;
            }


            alert('Import successful! The application will now reload.');
            location.reload();

        } catch (error) {
            console.error('Error importing data:', error);
            alert('Error: Could not parse the file. Please ensure it is a valid JSON backup file.');
        } finally {
            // Reset the file input so the user can import the same file again if needed
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

// --- Notification Handlers ---

function handleMasterNotificationToggle(event) {
    const isEnabled = event.target.checked;

    const updateState = (enabled) => {
        notificationSettings.enabled = enabled;
        event.target.checked = enabled;
        event.target.classList.toggle('bg-green-500', enabled);
        document.getElementById('notification-details').classList.toggle('hidden', !enabled);
        saveData();
    };

    if (isEnabled) {
        if (Notification.permission === 'granted') {
            updateState(true);
        } else if (Notification.permission === 'denied') {
            alert("Notifications are blocked by your browser. Please update your site settings to allow them.");
            updateState(false);
        } else {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    updateState(true);
                    new Notification("Task Manager", { body: "Notifications have been enabled!" });
                } else {
                    alert("You have denied permission for notifications.");
                    updateState(false);
                }
            });
        }
    } else {
        updateState(false);
    }
}

function toggleCategoryNotification(categoryId, isEnabled) {
    if (notificationSettings.categories.hasOwnProperty(categoryId)) {
        notificationSettings.categories[categoryId] = isEnabled;
        saveData();
    }
}

function updateNotificationRateLimit() {
    const amountInput = document.getElementById('notification-rate-amount');
    const unitInput = document.getElementById('notification-rate-unit');
    if (amountInput && unitInput) {
        notificationSettings.rateLimit.amount = parseInt(amountInput.value, 10) || 5;
        notificationSettings.rateLimit.unit = unitInput.value;
        saveData();
    }
}







// =================================================================================
// SECTION 5: Initialization & Notification Engine
// =================================================================================

// --- Notification Engine ---

/**
 * Schedules a single notification to be sent in the future.
 * @param {object} task - The task object for the notification.
 * @param {string} futureStatus - The status the task is changing to (e.g., 'yellow', 'red').
 * @param {number} triggerTimestamp - The future timestamp (in ms) when the notification should be sent.
 */
function scheduleNotification(task, futureStatus, triggerTimestamp) {
    const now = Date.now();
    const delay = triggerTimestamp - now;

    if (delay <= 0) return; // Don't schedule notifications for the past.

    // 1. Check if notifications are globally enabled.
    if (!notificationSettings.enabled) return;

    // 2. Check if the task's category is enabled for notifications.
    const categoryId = task.categoryId || 'null'; // Use 'null' for uncategorized
    if (notificationSettings.categories[categoryId] === false) return;

    // 3. Check the rate limit.
    const rateLimitMs = getDurationMs(notificationSettings.rateLimit.amount, notificationSettings.rateLimit.unit);
    const lastNotified = notificationEngine.lastNotificationTimestamps[task.id] || 0;
    if (now - lastNotified < rateLimitMs) {
        console.log(`Notification for task "${task.name}" suppressed due to rate limit.`);
        return;
    }

    const timeoutId = setTimeout(() => {
        const notificationBody = `Task "${task.name}" is now ${futureStatus}.`;
        new Notification("Task Status Change", {
            body: notificationBody,
            tag: task.id // Using a tag prevents multiple notifications for the same task.
        });
        // Update the timestamp after sending the notification.
        notificationEngine.lastNotificationTimestamps[task.id] = Date.now();
        saveData(); // Save the updated timestamps.
    }, delay);

    // Store the timeout ID so we can cancel it if the user returns to the page.
    notificationEngine.timeouts.push(timeoutId);
}

/**
 * Calculates all future status changes for active tasks and schedules notifications.
 */
function calculateAndScheduleAllNotifications() {
    const now = Date.now();

    tasks.forEach(task => {
        // Skip completed, locked, or tasks with pending user actions.
        if (task.completed || task.status === 'blue' || task.confirmationState) return;
        if (!task.dueDate || isNaN(task.dueDate)) return;

        const dueDateMs = task.dueDate.getTime();
        const estimateMs = getDurationMs(task.estimatedDurationAmount, task.estimatedDurationUnit) || (30 * MS_PER_MINUTE);

        // Define potential trigger points for status changes.
        const triggerPoints = [
            { status: 'yellow', timestamp: dueDateMs - (estimateMs * 2) },
            { status: 'red', timestamp: dueDateMs - estimateMs },
            { status: 'red', timestamp: dueDateMs } // Becomes overdue
        ];

        triggerPoints.forEach(point => {
            if (point.timestamp > now) {
                scheduleNotification(task, point.status, point.timestamp);
            }
        });
    });

    console.log(`Scheduled ${notificationEngine.timeouts.length} potential notifications.`);
}

/**
 * Starts the notification engine when the page becomes hidden.
 */
function startNotificationEngine() {
    console.log("Page hidden. Starting notification engine...");
    // Ensure the engine is clean before starting.
    stopNotificationEngine();
    calculateAndScheduleAllNotifications();
}

/**
 * Stops the notification engine and clears all scheduled notifications.
 */
function stopNotificationEngine() {
    console.log(`Page visible. Stopping notification engine and clearing ${notificationEngine.timeouts.length} scheduled notifications.`);
    notificationEngine.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
    notificationEngine.timeouts = [];
}


// --- Initialization ---

function initializeDOMElements() {
    // Task Manager
    taskModal = document.getElementById('task-modal'); taskForm = document.getElementById('task-form'); taskListDiv = document.getElementById('task-list'); modalTitle = document.getElementById('modal-title'); taskIdInput = document.getElementById('task-id'); taskNameInput = document.getElementById('task-name');
    taskIconInput = document.getElementById('task-icon');
    iconPickerModal = document.getElementById('icon-picker-modal');
    timeInputTypeSelect = document.getElementById('time-input-type');
    dueDateGroup = document.getElementById('due-date-group');
    taskDueDateInput = document.getElementById('task-due-date');
    startDateGroup = document.getElementById('start-date-group');
    taskStartDateInput = document.getElementById('task-start-date');
    dueDateTypeSelect = document.getElementById('due-date-type');
    relativeDueDateGroup = document.getElementById('relative-due-date-group');
    relativeAmountInput = document.getElementById('relative-amount');
    relativeUnitSelect = document.getElementById('relative-unit');
    taskRepetitionSelect = document.getElementById('task-repetition');
    repetitionRelativeGroup = document.getElementById('repetition-relative-group');
    repetitionAmountInput = document.getElementById('repetition-amount');
    repetitionUnitSelect = document.getElementById('repetition-unit');
    repeatingOptionsGroup = document.getElementById('repeating-options-group');
    maxMissesGroup = document.getElementById('max-misses-group'); maxMissesInput = document.getElementById('max-misses');
    trackMissesInput = document.getElementById('track-misses');
    completionTypeSelect = document.getElementById('completion-type'); estimatedDurationGroup = document.getElementById('estimated-duration-group'); estimatedDurationAmountInput = document.getElementById('estimated-duration-amount'); estimatedDurationUnitSelect = document.getElementById('estimated-duration-unit'); completionCountGroup = document.getElementById('completion-count-group'); countTargetInput = document.getElementById('count-target'); completionTimeGroup = document.getElementById('completion-time-group'); timeTargetAmountInput = document.getElementById('time-target-amount'); timeTargetUnitSelect = document.getElementById('time-target-unit');
    repetitionAbsoluteGroup = document.getElementById('repetition-absolute-group');
    absoluteFrequencySelect = document.getElementById('absolute-frequency');
    absoluteWeeklyOptions = document.getElementById('absolute-weekly-options');
    absoluteMonthlyOptions = document.getElementById('absolute-monthly-options');
    absoluteYearlyOptions = document.getElementById('absolute-yearly-options');
    weekdayCheckboxes = document.querySelectorAll('input[name="weekday"]');
    monthlyDayNumberOptions = document.getElementById('monthly-day-number-options');
    monthlyDayOfWeekOptions = document.getElementById('monthly-day-of-week-options');
    yearlyDayNumberOptions = document.getElementById('yearly-day-number-options');
    yearlyDayOfWeekOptions = document.getElementById('yearly-day-of-week-options');
    monthlyOccurrenceCheckboxes = document.querySelectorAll('input[name="monthlyOccurrence"]');
    monthlyWeekdayCheckboxes = document.querySelectorAll('input[name="monthlyWeekday"]');
    monthlyDayCheckboxes = document.querySelectorAll('input[name="monthlyDay"]');
    yearlyOccurrenceCheckboxes = document.querySelectorAll('input[name="yearlyOccurrence"]');
    yearlyMonthCheckboxes = document.querySelectorAll('input[name="yearlyMonth"]');
    yearlyWeekdayCheckboxes = document.querySelectorAll('input[name="yearlyWeekday"]');
    yearlyDayCheckboxes = document.querySelectorAll('input[name="yearlyDay"]');
    requiresFullAttentionInput = document.getElementById('requires-full-attention');
    taskCategorySelect = document.getElementById('task-category');
    newCategoryGroup = document.getElementById('new-category-group');
    newCategoryNameInput = document.getElementById('new-category-name');
    advancedOptionsModal = document.getElementById('advanced-options-modal');
    sortBySelect = document.getElementById('sort-by');
    sortDirectionSelect = document.getElementById('sort-direction');
    categoryFilterList = document.getElementById('category-filter-list');
    plannerDefaultCategorySelect = document.getElementById('planner-default-category');
    dayNightToggle = document.getElementById('day-night-toggle');
    taskViewModal = document.getElementById('task-view-modal');
    taskViewContent = document.getElementById('task-view-content');
    taskStatsContent = document.getElementById('task-stats-content');

    // Pilot Planner
    app = document.getElementById('app');
    weeklyGoalsEl = document.getElementById('weeklyGoals');
    indicatorListEl = document.getElementById('indicatorList');
    newIndicatorInput = document.getElementById('newIndicatorInput');
    newIndicatorFrequency = document.getElementById('newIndicatorFrequency');
    addIndicatorBtn = document.getElementById('addIndicatorBtn');
    calendarEl = document.getElementById('calendar');
    progressTrackerContainer = document.getElementById('progressTrackerContainer');
    viewBtns = document.querySelectorAll('.view-btn');
    startNewWeekBtn = document.getElementById('startNewWeekBtn');
    confirmModal = document.getElementById('confirmModal');
    cancelNewWeekBtn = document.getElementById('cancelNewWeek');
    confirmNewWeekBtn = document.getElementById('confirmNewWeek');
    prevWeekBtn = document.getElementById('prevWeekBtn');
    nextWeekBtn = document.getElementById('nextWeekBtn');
    weekStatusEl = document.getElementById('weekStatus');
    weekDateRangeEl = document.getElementById('weekDateRange');

    // View-switching elements
    showCalendarBtn = document.getElementById('show-calendar-btn');
    showDashboardBtn = document.getElementById('show-dashboard-btn');
    calendarView = document.getElementById('calendar-view');
    dashboardView = document.getElementById('dashboard-view');
}
function promptToAdvanceWeeks(weekDiff) {
    const modalTitle = confirmModal.querySelector('h3');
    const modalText = confirmModal.querySelector('p');
    const confirmBtn = document.getElementById('confirmNewWeek');
    const cancelBtn = document.getElementById('cancelNewWeek');

    if (weekDiff === 1) {
        modalTitle.textContent = 'Advance to Next Week?';
        modalText.textContent = 'This will archive the current week, make your "Next Week Preview" the new current week, and remove the oldest week\'s data. This action cannot be undone.';
    } else {
        modalTitle.textContent = `Catch up by ${weekDiff} weeks?`;
        modalText.textContent = `You are ${weekDiff} weeks behind. This will archive all past weeks and catch you up to the current date. This action cannot be undone.`;
    }

    const onConfirm = () => {
        for (let i = 0; i < weekDiff; i++) {
            const weekToSnapshot = appState.weeks[CURRENT_WEEK_INDEX];
            if (!weekToSnapshot.originalState) {
                weekToSnapshot.originalState = {
                    weeklyGoals: weekToSnapshot.weeklyGoals,
                    schedule: deepClone(weekToSnapshot.schedule),
                    kpiData: deepClone(weekToSnapshot.kpiData)
                };
            }
            const lastWeek = appState.weeks[appState.weeks.length - 1];
            const nextWeekStartDate = new Date(lastWeek.startDate); nextWeekStartDate.setDate(nextWeekStartDate.getDate() + 7);
            appState.weeks.push(createNewWeek(nextWeekStartDate)); appState.weeks.shift();
        }
        appState.viewingIndex = CURRENT_WEEK_INDEX;
        savePlannerData();
        saveViewState();
        if (calendar) calendar.refetchEvents();
        confirmModal.classList.add('hidden');
        cleanup();
    };

    const onCancel = () => {
        confirmModal.classList.add('hidden');
        cleanup();
    };

    const cleanup = ()_> {
        confirmBtn.removeEventListener('click', onConfirm);
        cancelBtn.removeEventListener('click', onCancel);
    };

    confirmBtn.addEventListener('click', onConfirm, { once: true });
    cancelBtn.addEventListener('click', onCancel, { once: true });

    confirmModal.classList.remove('hidden');
}

function setupEventListeners() {
    // Task Manager
    const taskManagerModal = document.getElementById('taskManagerModal');
    const toggleTaskManagerBtn = document.getElementById('toggleTaskManagerBtn');
    if (toggleTaskManagerBtn) {
        toggleTaskManagerBtn.addEventListener('click', () => {
            const isHidden = taskManagerModal.classList.toggle('hidden');
            if (isHidden) {
                document.body.classList.remove('modal-open');
            } else {
                document.body.classList.add('modal-open');
            }
        });
    }
    const closeTaskManagerBtn = document.getElementById('closeTaskManagerBtn');
    if (closeTaskManagerBtn) {
        closeTaskManagerBtn.addEventListener('click', () => {
            taskManagerModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
        });
    }

    const addTaskBtn = document.getElementById('add-task-btn');
    if (addTaskBtn) {
        addTaskBtn.addEventListener('click', () => openModal());
    }
    const advancedOptionsBtn = document.getElementById('advanced-options-btn');
    if(advancedOptionsBtn) {
        advancedOptionsBtn.addEventListener('click', openAdvancedOptionsModal);
    }
    const advancedOptionsBtnMain = document.getElementById('advancedOptionsBtnMain');
    if(advancedOptionsBtnMain) {
        advancedOptionsBtnMain.addEventListener('click', openAdvancedOptionsModal);
    }
    const advOptionsCloseButton = advancedOptionsModal.querySelector('.close-button');
    if(advOptionsCloseButton) {
        advOptionsCloseButton.addEventListener('click', () => {
            deactivateModal(advancedOptionsModal);
        });
    }

    const taskViewCloseButton = taskViewModal.querySelector('.close-button');
    if (taskViewCloseButton) {
        taskViewCloseButton.addEventListener('click', () => deactivateModal(taskViewModal));
    }

    if (taskForm) {
        taskForm.addEventListener('submit', handleFormSubmit);
    }

    const closeButton = taskModal.querySelector('.close-button');
    const cancelButton = taskModal.querySelector('button[type="button"]');
    if (closeButton) closeButton.addEventListener('click', closeModal);
    if (cancelButton) cancelButton.addEventListener('click', closeModal);

    const simpleModeToggle = document.getElementById('simple-mode-toggle');
    if (simpleModeToggle) {
        simpleModeToggle.addEventListener('change', (e) => {
            isSimpleMode = !e.target.checked;
            toggleSimpleMode();
        });
    }

    const openIconPickerBtn = document.getElementById('open-icon-picker');
    if (openIconPickerBtn) {
        openIconPickerBtn.addEventListener('click', openIconPicker);
    }

    if (iconPickerModal) {
        const closeBtn = iconPickerModal.querySelector('.close-button');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => deactivateModal(iconPickerModal));
        }

        const content = document.getElementById('icon-picker-content');
        content.addEventListener('click', (e) => {
            // Handle category header clicks for accordion behavior
            const header = e.target.closest('.icon-picker-category-header');
            if (header) {
                const grid = header.nextElementSibling;
                const icon = header.querySelector('span');
                grid.classList.toggle('hidden');
                icon.style.transform = grid.classList.contains('hidden') ? 'rotate(0deg)' : 'rotate(180deg)';
                return;
            }

            // Handle icon selection
            const iconWrapper = e.target.closest('[data-icon]');
            if (iconWrapper) {
                const iconClass = iconWrapper.dataset.icon;
                if (taskIconInput) {
                    taskIconInput.value = iconClass;
                }
                deactivateModal(iconPickerModal);
            }
        });
    }

    timeInputTypeSelect.addEventListener('change', (e) => {
        const isStart = e.target.value === 'start';
        dueDateGroup.classList.toggle('hidden', isStart);
        startDateGroup.classList.toggle('hidden', !isStart);
        if (estimatedDurationAmountInput) {
            estimatedDurationAmountInput.required = isStart;
        }
    });

    taskRepetitionSelect.addEventListener('change', (e) => {
        const type = e.target.value;
        repetitionRelativeGroup.classList.toggle('hidden', type !== 'relative');
        repetitionAbsoluteGroup.classList.toggle('hidden', type !== 'absolute');
        repeatingOptionsGroup.classList.toggle('hidden', type === 'none');
        if(type === 'absolute') { toggleAbsoluteRepetitionFields(absoluteFrequencySelect.value); }
        if (type === 'none') { maxMissesInput.value = ''; trackMissesInput.checked = true; }
    });
    absoluteFrequencySelect.addEventListener('change', (e) => {
        toggleAbsoluteRepetitionFields(e.target.value);
    });
    taskForm.querySelectorAll('input[name="monthlyOption"]').forEach(radio => {
        radio.addEventListener('change', (e) => toggleMonthlyOptions(e.target.value));
    });
    taskForm.querySelectorAll('input[name="yearlyOption"]').forEach(radio => {
        radio.addEventListener('change', (e) => toggleYearlyOptions(e.target.value));
    });
    dueDateTypeSelect.addEventListener('change', (e) => {
        relativeDueDateGroup.classList.toggle('hidden', e.target.value !== 'relative');
    });
    completionTypeSelect.addEventListener('change', (e) => {
        toggleCompletionFields(e.target.value);
    });
    taskCategorySelect.addEventListener('change', (e) => {
        const isNew = e.target.value === 'new_category';
        newCategoryGroup.classList.toggle('hidden', !isNew);
        if (isNew) {
            newCategoryNameInput.focus();
        }
    });
    window.addEventListener('mousedown', (event) => {
        if (event.target === taskModal) {
            closeModal();
        }
        if (event.target === advancedOptionsModal) {
            deactivateModal(advancedOptionsModal);
        }
    });
    taskListDiv.addEventListener('click', (event) => {
        if (event.target.closest('.collapsible-header')) {
            const header = event.target.closest('.collapsible-header');
            const group = header.dataset.group;
            const tasksToToggle = taskListDiv.querySelectorAll(`.task-item[data-group="${group}"]`);
            const icon = header.querySelector('span');
            header.classList.toggle('collapsed');
            if (header.classList.contains('collapsed')) {
                icon.style.transform = 'rotate(-90deg)';
                tasksToToggle.forEach(t => t.style.display = 'none');
            } else {
                icon.style.transform = 'rotate(0deg)';
                tasksToToggle.forEach(t => t.style.display = 'flex');
            }
            return;
        }
        const actionTarget = event.target.closest('[data-action]');
        if (!actionTarget) return;

        const action = actionTarget.dataset.action;
        const taskId = actionTarget.dataset.taskId;

        // If the action is to view the task, but the user actually clicked on an interactive element
        // inside the task card, we ignore the 'viewTask' action and let the more specific action handle it.
        if (action === 'viewTask' && event.target.closest('button, a, input, .edit-progress-button')) {
            return;
        }

        switch (action) {
            case 'viewTask':
                openTaskView(taskId);
                break;
            case 'edit':
                editTask(taskId);
                break;
            case 'triggerDelete':
                triggerDelete(taskId);
                break;
            case 'triggerCompletion':
                triggerCompletion(taskId);
                break;
            case 'confirmCompletion':
                confirmCompletionAction(taskId, actionTarget.dataset.confirmed === 'true');
                break;
            case 'handleOverdue':
                handleOverdueChoice(taskId, actionTarget.dataset.choice);
                break;
            case 'confirmMiss':
                confirmMissAction(taskId, actionTarget.dataset.confirmed === 'true');
                break;
            case 'confirmDelete':
                confirmDeleteAction(taskId, actionTarget.dataset.confirmed === 'true');
                break;
            case 'triggerUndo':
                triggerUndoConfirmation(taskId);
                break;
            case 'confirmUndo':
                confirmUndoAction(taskId, actionTarget.dataset.confirmed === 'true');
                break;
            case 'incrementCount':
                incrementCount(taskId);
                break;
            case 'decrementCount':
                decrementCount(taskId);
                break;
            case 'toggleTimer':
                toggleTimer(taskId);
                break;
            case 'editProgress':
                editProgress(taskId);
                break;
            case 'saveProgress':
                saveProgressEdit(taskId);
                break;
            case 'cancelProgress':
                cancelProgressEdit(taskId);
                break;
        }
    });
    const advancedOptionsContent = document.getElementById('advanced-options-content');
    if (advancedOptionsContent) {
        advancedOptionsContent.addEventListener('click', (event) => {
            const target = event.target.closest('[data-action]');
            if (!target) return;
            const action = target.dataset.action;
            const categoryId = target.dataset.categoryId;
            const statusKey = target.dataset.statusKey;

            switch(action) {
                case 'deleteCategory': deleteCategory(categoryId); break;
                case 'deleteActiveCategoryTasks': deleteActiveCategoryTasks(categoryId); break;
                case 'deleteCategoryTasks': deleteCategoryTasks(categoryId); break;
                case 'addCategory': addCategoryFromManager(); break;
                case 'triggerCategoryEdit': triggerCategoryEdit(categoryId); break;
                case 'saveCategoryEdit': saveCategoryEdit(categoryId); break;
                case 'cancelCategoryEdit': cancelCategoryEdit(categoryId); break;
                case 'triggerStatusNameEdit': triggerStatusNameEdit(statusKey); break;
                case 'saveStatusNameEdit': saveStatusNameEdit(statusKey); break;
                case 'cancelStatusNameEdit': cancelStatusNameEdit(); break;
                case 'restoreDefaults': triggerRestoreDefaults(); break;
                case 'confirmRestoreDefaults': confirmRestoreDefaultsAction(target.dataset.confirmed === 'true'); break;
                case 'toggleAllNotifications': handleMasterNotificationToggle(event); break;
                case 'toggleCategoryNotification':
                    toggleCategoryNotification(target.dataset.categoryId, event.target.checked);
                    break;
                case 'toggleTheme':
                    theming.enabled = event.target.checked;
                    applyTheme();
                    renderThemeControls();
                    saveData();
                    break;
                case 'randomizeTheme':
                    theming.baseColor = getRandomColor();
                    applyTheme();
                    renderThemeControls();
                    saveData();
                    break;
                case 'toggleTimeFormat':
                    appSettings.use24HourFormat = event.target.checked;
                    saveData();
                    renderTasks();
                    if (calendar) calendar.refetchEvents();
                    break;
                case 'exportData':
                    exportData(target.dataset.exportType);
                    break;
                case 'importData':
                    importData();
                    break;
            }
        });

        const importFileInput = document.getElementById('import-file-input');
        if (importFileInput) {
            importFileInput.addEventListener('change', handleFileImport);
        }

        const themeModeSelector = document.getElementById('theme-mode-selector');
        if (themeModeSelector) {
            themeModeSelector.addEventListener('click', (event) => {
                const target = event.target.closest('.theme-mode-btn');
                if (!target) return;
                const mode = target.dataset.mode;
                if (mode) {
                    theming.mode = mode;
                    applyTheme();
                    renderThemeControls();
                    saveData();
                }
            });
        }
        advancedOptionsContent.addEventListener('change', (event) => {
            const target = event.target;
            if (target.id === 'app-title-input') {
                setAppTitle(target.value);
                return; // Prevent other handlers from running
            }
            if (target.classList.contains('category-color-picker')) {
                const categoryId = target.dataset.categoryId;
                const newColor = target.value;
                const category = categories.find(cat => cat.id === categoryId);
                if (category) {
                    category.color = newColor;
                    saveData();
                    renderCategoryManager();
                    renderTasks();
                }
            } else if (target.classList.contains('category-filter-checkbox')) {
                const allCheckbox = categoryFilterList.querySelector('input[value="all"]');
                const otherCheckboxes = categoryFilterList.querySelectorAll('input:not([value="all"])');
                if (target.value === 'all') {
                    otherCheckboxes.forEach(cb => cb.checked = false);
                    categoryFilter = [];
                } else {
                    allCheckbox.checked = false;
                    categoryFilter = Array.from(otherCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value === 'null' ? null : cb.value);
                }

                if (categoryFilter.length === 0) {
                    allCheckbox.checked = true;
                }
                renderTasks();
                renderPlanner();
            } else if (target.classList.contains('status-color-picker')) {
                 const statusKey = target.dataset.statusKey;
                 const newColor = target.value;
                 if (statusColors.hasOwnProperty(statusKey)) {
                     statusColors[statusKey] = newColor;
                     saveData();
                     renderTasks();
                     renderStatusManager(); // Re-render the manager to show the change
                 }
            } else if (target.id === 'notification-rate-amount' || target.id === 'notification-rate-unit') {
                updateNotificationRateLimit();
            } else if (target.id === 'theme-base-color') {
                theming.baseColor = target.value;
                applyTheme();
                saveData();
            } else if (target.id === 'planner-default-category') {
                plannerSettings.defaultCategoryId = target.value;
                saveData();
            } else if (target.classList.contains('task-display-toggle')) {
                const key = target.name;
                if (taskDisplaySettings.hasOwnProperty(key)) {
                    taskDisplaySettings[key] = target.checked;
                    saveData();
                    renderTasks();
                }
            }
        });
        sortBySelect.addEventListener('change', (e) => {
            sortBy = e.target.value;
            saveData();
            renderTasks();
        });
        sortDirectionSelect.addEventListener('change', (e) => {
            sortDirection = e.target.value;
            saveData();
            renderTasks();
        });
    }

    // Planner Navigation
    if (prevWeekBtn) {
        prevWeekBtn.addEventListener('click', () => {
            if (calendar) calendar.prev();
        });
    }
    if (nextWeekBtn) {
        nextWeekBtn.addEventListener('click', () => {
            if (calendar) calendar.next();
        });
    }
    if (viewBtns) {
        viewBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (calendar) {
                    const viewName = btn.dataset.view === 'month' ? 'dayGridMonth' :
                                     btn.dataset.view === 'daily' ? 'timeGridDay' : 'timeGridWeek';
                    calendar.changeView(viewName);
                }
            });
        });
    }

    // Indicator and Goal Listeners (These still seem relevant)
    if (addIndicatorBtn) {
        addIndicatorBtn.addEventListener('click', () => {
            const name = newIndicatorInput.value.trim();
            if (name) {
                const newId = appState.indicators.length > 0 ? Math.max(...appState.indicators.map(i => i.id)) + 1 : 1;
                const frequency = newIndicatorFrequency.value;
                appState.indicators.push({ id: newId, name: name, frequency: frequency });
                newIndicatorInput.value = '';
                savePlannerData();
                // renderProgressTracker(); // This function is removed, might need a replacement if progress tracker is kept
            }
        });
    }
    if (indicatorListEl) {
        indicatorListEl.addEventListener('click', e => {
            if (e.target.matches('.remove-indicator-btn')) {
                appState.indicators = appState.indicators.filter(i => i.id !== parseInt(e.target.dataset.id));
                savePlannerData();
                // renderProgressTracker();
            }
        });
    }

    if (weeklyGoalsEl) {
        weeklyGoalsEl.addEventListener('blur', () => {
            const week = appState.weeks[appState.viewingIndex];
            if (week) {
                const newGoals = weeklyGoalsEl.innerHTML;
                // Amendment checking removed as it was part of the old planner
                week.weeklyGoals = newGoals;
                savePlannerData();
            }
        });
    }

    const addNewTaskBtnPlanner = document.getElementById('addNewTaskBtnPlanner');
    if (addNewTaskBtnPlanner) {
        addNewTaskBtnPlanner.addEventListener('click', () => openModal());
    }

    // Main View Toggles
    if (showCalendarBtn && showDashboardBtn && calendarView && dashboardView) {
        showCalendarBtn.addEventListener('click', () => {
            calendarView.classList.remove('hidden');
            dashboardView.classList.add('hidden');
            showCalendarBtn.classList.add('active-view-btn');
            showDashboardBtn.classList.remove('active-view-btn');
            if (calendar) {
                calendar.updateSize();
            }
        });

        showDashboardBtn.addEventListener('click', () => {
            calendarView.classList.add('hidden');
            dashboardView.classList.remove('hidden');
            showCalendarBtn.classList.remove('active-view-btn');
            showDashboardBtn.classList.add('active-view-btn');
        });
    }

    // Add the listener for page visibility changes.
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            startNotificationEngine();
        } else {
            stopNotificationEngine();
        }
    });
}

function saveData() {
    try {
        localStorage.setItem('tasks', JSON.stringify(tasks));
        localStorage.setItem('categories', JSON.stringify(categories));
        localStorage.setItem('statusColors', JSON.stringify(statusColors));
        localStorage.setItem('statusNames', JSON.stringify(statusNames));
        localStorage.setItem('sortBy', sortBy);
        localStorage.setItem('sortDirection', sortDirection);
        localStorage.setItem('notificationSettings', JSON.stringify(notificationSettings));
        localStorage.setItem('notificationTimestamps', JSON.stringify(notificationEngine.lastNotificationTimestamps));
        localStorage.setItem('theming', JSON.stringify(theming));
        localStorage.setItem('calendarSettings', JSON.stringify(calendarSettings));
        localStorage.setItem('categoryFilter', JSON.stringify(categoryFilter));
        localStorage.setItem('plannerSettings', JSON.stringify(plannerSettings));
        localStorage.setItem('taskDisplaySettings', JSON.stringify(taskDisplaySettings));
        localStorage.setItem('appSettings', JSON.stringify(appSettings));
        savePlannerData();
    } catch (error) {
        console.error("Error saving data to localStorage:", error);
    }
}

function loadData() {
    const storedTasks = localStorage.getItem('tasks');
    const storedCategories = localStorage.getItem('categories');
    const storedColors = localStorage.getItem('statusColors');
    const storedNames = localStorage.getItem('statusNames');
    const storedSortBy = localStorage.getItem('sortBy');
    const storedSortDirection = localStorage.getItem('sortDirection');
    const storedNotifications = localStorage.getItem('notificationSettings');
    const storedNotificationTimestamps = localStorage.getItem('notificationTimestamps');
    const storedTheming = localStorage.getItem('theming');
    const storedCalendarSettings = localStorage.getItem('calendarSettings');
    const storedCategoryFilter = localStorage.getItem('categoryFilter');
    const storedPlannerSettings = localStorage.getItem('plannerSettings');
    const storedTaskDisplaySettings = localStorage.getItem('taskDisplaySettings');
    const storedAppSettings = localStorage.getItem('appSettings');

    tasks = [];
    categories = [];

    if (storedColors) {
        try {
            const parsedColors = JSON.parse(storedColors);
            statusColors = { ...statusColors, ...parsedColors };
        } catch (e) {
            console.error("Error parsing status colors:", e);
        }
    }
    if (storedNames) {
        try {
            const parsedNames = JSON.parse(storedNames);
            statusNames = { ...statusNames, ...parsedNames };
        } catch (e) {
            console.error("Error parsing status names:", e);
        }
    }

    if (storedSortBy) sortBy = storedSortBy;
    if (storedSortDirection) sortDirection = storedSortDirection;
    sortBySelect.value = sortBy;
    sortDirectionSelect.value = sortDirection;

    if (storedNotifications) {
        try {
            const parsedSettings = JSON.parse(storedNotifications);
            // Deep merge to handle nested objects
            notificationSettings.rateLimit = { ...notificationSettings.rateLimit, ...parsedSettings.rateLimit };
            notificationSettings.categories = { ...notificationSettings.categories, ...parsedSettings.categories };
            notificationSettings.enabled = typeof parsedSettings.enabled === 'boolean' ? parsedSettings.enabled : false;
        } catch(e) {
            console.error("Error parsing notification settings:", e);
        }
    }

    if (storedNotificationTimestamps) {
        try {
            notificationEngine.lastNotificationTimestamps = JSON.parse(storedNotificationTimestamps);
        } catch(e) {
            console.error("Error parsing notification timestamps:", e);
        }
    }

    if (storedTheming) {
        try {
            const parsedTheming = JSON.parse(storedTheming);
            theming = { ...theming, ...parsedTheming };
            if (theming.mode !== 'day' && theming.mode !== 'night') {
                theming.mode = 'night';
            }
        } catch (e) {
            console.error("Error parsing theming settings:", e);
        }
    }

    if (storedCalendarSettings) {
        try {
            const parsedSettings = JSON.parse(storedCalendarSettings);
            calendarSettings = { ...calendarSettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing calendar settings:", e);
        }
    }

    if (storedCategoryFilter) {
        try {
            categoryFilter = JSON.parse(storedCategoryFilter);
        } catch (e) {
            console.error("Error parsing category filter:", e);
        }
    }

    if (storedPlannerSettings) {
        try {
            const parsedSettings = JSON.parse(storedPlannerSettings);
            plannerSettings = { ...plannerSettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing planner settings:", e);
        }
    }

    if (storedTaskDisplaySettings) {
        try {
            const parsedSettings = JSON.parse(storedTaskDisplaySettings);
            taskDisplaySettings = { ...taskDisplaySettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing task display settings:", e);
        }
    }

    if (storedAppSettings) {
        try {
            const parsedSettings = JSON.parse(storedAppSettings);
            appSettings = { ...appSettings, ...parsedSettings };
        } catch (e) {
            console.error("Error parsing app settings:", e);
        }
    }


    if (storedCategories) {
        try {
            categories = JSON.parse(storedCategories);
        } catch (error) {
            console.error("Error parsing categories from localStorage:", error);
        }
    }
    if (storedTasks) {
        try {
            const parsedTasks = JSON.parse(storedTasks);
            tasks = parsedTasks.map(task => {
                let tempTask = { ...task };
                tempTask.dueDate = task.dueDate ? new Date(task.dueDate) : null;
                tempTask.createdAt = task.createdAt ? new Date(task.createdAt) : new Date();
                tempTask.cycleEndDate = task.cycleEndDate ? new Date(task.cycleEndDate) : null;
                tempTask.timerLastStarted = task.timerLastStarted ? new Date(task.timerLastStarted) : null;
                if (isNaN(tempTask.dueDate)) tempTask.dueDate = null;
                if (isNaN(tempTask.createdAt)) tempTask.createdAt = new Date();
                if (isNaN(tempTask.cycleEndDate)) tempTask.cycleEndDate = null;
                if (isNaN(tempTask.timerLastStarted)) tempTask.timerLastStarted = null;

                return sanitizeAndUpgradeTask(tempTask);
            });

            tasks.forEach(task => {
                if (task.isTimerRunning && task.timerLastStarted) {
                    const elapsedWhileAway = Date.now() - task.timerLastStarted.getTime();
                    const targetMs = getDurationMs(task.timeTargetAmount, task.timeTargetUnit);
                    task.currentProgress = (task.currentProgress || 0) + elapsedWhileAway;

                    if (task.currentProgress >= targetMs) {
                        task.currentProgress = targetMs;
                        task.isTimerRunning = false;
                        task.timerLastStarted = null;
                    } else {
                        task.timerLastStarted = new Date().toISOString();
                    }
                }
            });
        } catch (error) {
            console.error("Error parsing tasks from localStorage:", error);
        }
    }

    const newKpiTasks = autoGenerateDailyKpiTasks(appState.indicators, tasks);
    if (newKpiTasks.length > 0) {
        tasks.push(...newKpiTasks);
        saveData();
    }

    updateAllTaskStatuses(true);
    startMainUpdateLoop();
}

function updateAllTaskStatuses(forceRender = false) {
    let changed = false;
    const nowMs = Date.now();
    const currentTasks = [...tasks];
    tasks.forEach(task => {
        try {
            if (task.repetitionType === 'none' && task.completed) return;

            const oldStatus = task.status;
            const oldConfirmationState = task.confirmationState;

            // Step 1: Always calculate the definitive current status based on timing and misses.
            const newStatusResult = calculateStatus(task, nowMs, currentTasks);
            task.status = newStatusResult.name;

            const dueDateMs = task.dueDate ? task.dueDate.getTime() : null;
            const isPastDue = dueDateMs !== null && dueDateMs <= nowMs;

            // Step 2: Determine if a confirmation state is needed, or if it should be cleared.
            if (isPastDue && task.status !== 'blue' && !task.confirmationState) {
                // Task just became overdue. Set prompt and force status to black.
                task.confirmationState = 'awaiting_overdue_input';
                task.status = 'black'; // <-- NEW: Overdue tasks now immediately become black.
                if (!task.overdueStartDate) {
                    task.overdueStartDate = task.dueDate.toISOString();
                }
                task.pendingCycles = calculatePendingCycles(task, nowMs);
                if (task.isTimerRunning) { toggleTimer(task.id); }
            } else if (!isPastDue && (task.confirmationState === 'awaiting_overdue_input' || task.confirmationState === 'confirming_miss')) {
                // This clears the 'Done/Missed' prompt if the task is no longer past due (e.g., date was edited).
                task.confirmationState = null;
                delete task.overdueStartDate;
                delete task.pendingCycles;
            }

            // Step 3: If the status OR the confirmation state changed, flag the UI for a full update.
            // This ensures the color changes without losing the confirmation prompt.
            if (task.status !== oldStatus || task.confirmationState !== oldConfirmationState) {
                changed = true;
            }

            if (task.isTimerRunning && !taskTimers[task.id]) {
                startTimerInterval(task.id);
            }

        } catch (e) {
            console.error("Error updating status for task:", task?.id, e);
        }
    });
    if (changed || forceRender) {
        saveData();
        renderTasks();
    }
}
function startMainUpdateLoop() {
    if (mainUpdateInterval) clearInterval(mainUpdateInterval);
    // The initial update is handled in loadData(), so the immediate timeout is removed.
    mainUpdateInterval = setInterval(() => updateAllTaskStatuses(false), STATUS_UPDATE_INTERVAL);
}

// =================================================================================
// --- MISSION PLANNER SCRIPT ---
// =================================================================================
const getStartOfWeek = (date = new Date()) => { const d = new Date(date); d.setDate(d.getDate() - d.getDay()); d.setHours(0,0,0,0); return d; };
const getISOStringAtMidnight = (date) => { const d = new Date(date); d.setHours(0, 0, 0, 0); return d.toISOString(); };
const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

const createNewWeek = (startDate) => ({
    startDate: getISOStringAtMidnight(startDate),
    weeklyGoals: 'Set new goals for the week...',
    schedule: {},
    kpiData: {},
    amendedItems: { weeklyGoals: false, schedule: {}, kpi: {} },
    originalState: null
});

const savePlannerData = () => {
    // Cleanup historical tasks older than 4 weeks
    const fourWeeksAgo = new Date();
    fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
    if (appState.historicalTasks && appState.historicalTasks.length > 0) {
        appState.historicalTasks = appState.historicalTasks.filter(ht => new Date(ht.completionDate) >= fourWeeksAgo);
    }

    localStorage.setItem(DATA_KEY, JSON.stringify({
        weeks: appState.weeks,
        indicators: appState.indicators,
        historicalTasks: appState.historicalTasks
    }));
};
const saveViewState = () => localStorage.setItem(VIEW_STATE_KEY, JSON.stringify({ viewingIndex: appState.viewingIndex, currentView: appState.currentView, currentDayIndex: appState.currentDayIndex }));

const loadPlannerData = () => {
    const savedData = localStorage.getItem(DATA_KEY);
    if (!savedData) return;
    try {
        const parsedData = JSON.parse(savedData);
        appState.weeks = parsedData.weeks || [];
        appState.weeks.forEach(week => {
            if (!week.amendedItems) week.amendedItems = { weeklyGoals: false, schedule: {}, kpi: {} };
            if (week.originalState === undefined) week.originalState = null;
        });
        appState.indicators = parsedData.indicators || appState.indicators;
        appState.historicalTasks = parsedData.historicalTasks || [];
    } catch (error) { console.error("Failed to parse saved data:", error); }
};

const loadViewState = () => {
    const savedState = localStorage.getItem(VIEW_STATE_KEY);
    if (!savedState) return;
    try {
        const parsedState = JSON.parse(savedState);
        appState.viewingIndex = parsedState.viewingIndex ?? CURRENT_WEEK_INDEX;
        appState.currentView = parsedState.currentView ?? 'weekly';
        appState.currentDayIndex = parsedState.currentDayIndex ?? 0;
    } catch (error) { console.error("Failed to parse view state:", error); }
};

const getFutureWeekStartDate = (viewingIndex) => {
    const lastKnownWeek = appState.weeks[appState.weeks.length - 1];
    const lastKnownStartDate = new Date(lastKnownWeek.startDate);
    const weeksAhead = viewingIndex - (appState.weeks.length - 1);
    const futureStartDate = new Date(lastKnownStartDate);
    futureStartDate.setDate(futureStartDate.getDate() + (weeksAhead * 7));
    return futureStartDate;
};

const renderFutureWeeklyView = (startDate) => {
    const weekStartDate = startDate;
    const weekEndDate = new Date(weekStartDate);
    weekEndDate.setDate(weekEndDate.getDate() + 7);

    plannerContainer.innerHTML = ''; // Clear previous content

    // --- Render Header (copied from renderWeeklyView) ---
    plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell day-header-cell font-semibold bg-gray-800 sticky top-0 z-10" style="grid-column: 1;">Time</div>`);
    for (let i = 0; i < 7; i++) {
        const dayDate = new Date(weekStartDate);
        dayDate.setDate(weekStartDate.getDate() + i);
        plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell day-header-cell font-semibold bg-gray-800 sticky top-0 z-10" style="grid-column: ${i + 2};">${dayDate.toLocaleDateString(undefined, { weekday: 'short' })}<br>${dayDate.toLocaleDateString(undefined, { month: 'numeric', day: 'numeric' })}</div>`);
    }

    // --- Render Time Labels and Grid Cells (copied from renderWeeklyView) ---
    for (let hour = 0; hour <= 23; hour++) {
        const rowStart = hour * 4 + 2;
        const d = new Date();
        d.setHours(hour, 0);
        const timeStr = formatTime(d);
        plannerContainer.insertAdjacentHTML('beforeend', `<div class="table-cell time-label-cell font-semibold bg-gray-800" style="grid-row: ${rowStart} / span 4;">${timeStr}</div>`);
        for (let day = 0; day < 7; day++) {
            for (let i = 0; i < 4; i++) {
                const slotRow = rowStart + i;
                // Note: In a read-only view, these slots are not interactive for creating new tasks.
                // We still need them for the grid structure.
                plannerContainer.insertAdjacentHTML('beforeend', `<div class="planner-slot" style="grid-column: ${day + 2}; grid-row: ${slotRow};"></div>`);
            }
        }
    }

    // --- Process and Render Tasks (copied from renderWeeklyView) ---
    const dailyTasks = Array.from({ length: 7 }, () => []);

    if (typeof tasks !== 'undefined' && tasks.length > 0) {
        const filteredTasks = tasks.filter(task => {
            if (categoryFilter.length === 0) return true;
            if (!task.categoryId) return categoryFilter.includes(null);
            return categoryFilter.includes(task.categoryId);
        });

        filteredTasks.forEach(task => {
            const occurrences = getTaskOccurrences(task, weekStartDate, weekEndDate);
            occurrences.forEach(({ occurrenceStartDate, occurrenceDueDate }) => {
                const dayOfWeek = occurrenceStartDate.getDay();
                dailyTasks[dayOfWeek].push({ task, occurrenceDate: occurrenceStartDate, dueDate: occurrenceDueDate });
            });
        });
    }

    dailyTasks.forEach((tasksForDay, dayIndex) => {
        const lanes = accommodate(tasksForDay);
        lanes.forEach((lane, laneIndex) => {
            lane.forEach(({ task, occurrenceDate, dueDate }) => {
                renderTaskOnGrid(task, occurrenceDate, dueDate, dayIndex, laneIndex, lanes.length, plannerContainer);
            });
        });
    });
};


// All the old planner rendering functions have been removed.

const initializePlannerState = () => {
    loadPlannerData();
    const today = new Date();
    const currentWeekStartDate = getStartOfWeek(today);
    if (appState.weeks.length === 0) {
        for (let i = -CURRENT_WEEK_INDEX; i < MAX_WEEKS_STORED - CURRENT_WEEK_INDEX; i++) {
            const weekStartDate = new Date(currentWeekStartDate);
            weekStartDate.setDate(weekStartDate.getDate() + (i * 7));
            appState.weeks.push(createNewWeek(weekStartDate));
        }
    } else {
        const storedCurrentWeekStart = new Date(appState.weeks[CURRENT_WEEK_INDEX].startDate);
        let weekDiff = Math.round((currentWeekStartDate.getTime() - storedCurrentWeekStart.getTime()) / (1000 * 60 * 60 * 24 * 7));
        if (weekDiff > 0) {
            promptToAdvanceWeeks(weekDiff);
        }
    }
    while(appState.weeks.length > MAX_WEEKS_STORED) appState.weeks.shift();
    loadViewState();
    if(appState.viewingIndex < 0 || appState.viewingIndex >= MAX_WEEKS_STORED) {
        appState.viewingIndex = CURRENT_WEEK_INDEX;
    }
    savePlannerData();
};

function initializeCalendar() {
    if (!calendarEl) {
        console.error("Calendar element not found!");
        return;
    }

    calendar = new Calendar(calendarEl, {
        plugins: [dayGridPlugin, timeGridPlugin, interactionPlugin],
        initialView: 'timeGridWeek',
        headerToolbar: {
            left: 'prev,next today',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
        },
        editable: true,
        events: (fetchInfo, successCallback, failureCallback) => {
            try {
                const viewStartDate = fetchInfo.start;
                const viewEndDate = fetchInfo.end;
                const scheduledTasks = calculateScheduledTimes(tasks, viewStartDate, viewEndDate);

                const calendarEvents = [];
                const filteredTasks = scheduledTasks.filter(task => {
                    if (categoryFilter.length === 0) return true;
                    if (!task.categoryId) return categoryFilter.includes(null);
                    return categoryFilter.includes(task.categoryId);
                });

                filteredTasks.forEach(task => {
                    const occurrences = getTaskOccurrences(task, viewStartDate, viewEndDate);
                    occurrences.forEach(({ occurrenceStartDate, occurrenceDueDate }) => {
                        const category = categories.find(c => c.id === task.categoryId);
                        const eventColor = category ? category.color : (statusColors[task.status] || '#374151');

                        calendarEvents.push({
                            id: task.id + '_' + occurrenceStartDate.toISOString(), // Create a unique ID for each occurrence
                            title: task.name,
                            start: occurrenceStartDate,
                            end: occurrenceDueDate,
                            color: eventColor,
                            extendedProps: {
                                taskId: task.id,
                                occurrenceDueDate: occurrenceDueDate.toISOString()
                            }
                        });
                    });
                });
                successCallback(calendarEvents);
            } catch (e) {
                console.error("Error fetching events for FullCalendar:", e);
                failureCallback(e);
            }
        },
        eventClick: (info) => {
            const taskId = info.event.extendedProps.taskId;
            const occurrenceDueDate = new Date(info.event.extendedProps.occurrenceDueDate);
            openTaskView(taskId, occurrenceDueDate);
        },
        dateClick: (info) => {
            const taskStartDate = new Date(info.date);
            const taskDueDate = new Date(taskStartDate.getTime() + (60 * 60 * 1000)); // Add 1 hour

            const defaultCategoryName = plannerSettings.defaultCategoryId || 'Planner';
            let plannerCategory = categories.find(c => c.id === defaultCategoryName);
            if (!plannerCategory) {
                plannerCategory = { id: defaultCategoryName, name: defaultCategoryName, color: getRandomColor() };
                categories.push(plannerCategory);
                renderCategoryManager();
                renderCategoryFilters();
            }

            const newTaskData = {
                id: generateId(),
                name: 'New Event',
                dueDate: taskDueDate,
                estimatedDurationAmount: 1,
                estimatedDurationUnit: 'hours',
                categoryId: plannerCategory.id,
                createdAt: new Date(),
                repetitionType: 'none',
                misses: 0,
                completed: false,
                status: 'green',
            };

            const sanitizedTask = sanitizeAndUpgradeTask(newTaskData);
            tasks.push(sanitizedTask);

            saveData();
            calendar.refetchEvents();
            openModal(sanitizedTask.id, { occurrenceDate: taskDueDate });
        }
    });

    calendar.render();
}

// =================================================================================
// --- UNIFIED INITIALIZATION ---
// =================================================================================
document.addEventListener('DOMContentLoaded', () => {
    console.log("Unified DOMContentLoaded event fired.");

    // --- Initialize Task Manager ---
    try {
        console.log("Initializing Task Manager...");
        initializeDOMElements(); // From Task Manager
        setupEventListeners();   // From Task Manager
        loadData();              // From Task Manager
        setAppTitle(appSettings.title); // Set the title on load
        console.log("Task Manager initialized.");
    } catch (e) {
        console.error("Error during Task Manager initialization:", e);
        const listDiv = document.getElementById('task-list');
        if(listDiv) listDiv.innerHTML = '<p class="text-red-600 font-bold text-center">Error initializing Task Manager. Please check console.</p>';
    }

    // --- Initialize Mission Planner ---
    try {
        console.log("Initializing Mission Planner...");
        initializePlannerState(); // Renamed from initializeOrSyncState
        applyTheme(); // Apply theme after state is initialized
        initializeCalendar(); // New function to set up FullCalendar
        console.log("Mission Planner initialized.");
    } catch (e) {
        console.error("Error during Mission Planner initialization:", e);
    }
});
